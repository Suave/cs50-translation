1
00:00:00,000 --> 00:00:03,444
[温柔的管弦乐演奏]
[GENTLE ORCHESTRAL MUSIC PLAYING]

2
00:00:24,110 --> 00:00:26,840
大卫. 马兰: 好的，这是 CS50的介绍
DAVID MALAN: All right, this is CS50's Introduction

3
00:00:26,840 --> 00:00:28,190
用 Python 编程。
to Programming with Python.

4
00:00:28,190 --> 00:00:32,009
我的名字是大卫马兰，这是我们关于函数和变量的一周。
My name is David Malan and this is our week on functions and variables.

5
00:00:32,009 --> 00:00:35,690
但很可能你们中的大多数，从来没有真正编程过。
But odds are, many of you, most of you, have never actually programmed before.

6
00:00:35,690 --> 00:00:37,790
让我们从这个开始。
So let's start by doing just that.

7
00:00:37,790 --> 00:00:40,250
让我打开我的电脑
Let me go ahead here and open up my computer

8
00:00:40,250 --> 00:00:43,220
上面有一个叫做 Visual Studio Code 或者 VS 的程序
and on it, a program called Visual Studio Code or VS

9
00:00:43,220 --> 00:00:45,650
代码，这只是一个非常流行的程序现在
Code, which is just a very popular program nowadays

10
00:00:45,650 --> 00:00:47,220
实际编写代码。
for actually writing code.

11
00:00:47,220 --> 00:00:49,840
现在，您不必使用这个特定的工具编写代码。
Now, you don't have to write code using this particular tool.

12
00:00:49,840 --> 00:00:51,590
事实上，在一天结束的时候，我们所需要的
In fact, all we need at the end of the day

13
00:00:51,590 --> 00:00:54,742
是一个所谓的文本编辑器，一个编写文本的程序。
is a so-called text editor, a program for writing text.

14
00:00:54,742 --> 00:00:57,200
而且，如果你真的想要，你甚至可以用一些东西
And, heck, if you really want, you could even use something

15
00:00:57,200 --> 00:00:59,180
比如谷歌文档或微软 Word。
like Google Docs or Microsoft Word.

16
00:00:59,180 --> 00:01:00,952
你得用正确的格式保存,
You'd have to save it in the right format,

17
00:01:00,952 --> 00:01:04,160
但实际上，到最后，你所需要的只是一个写文本的程序
but really, at the end of the day, all you need is a program for writing text

18
00:01:04,160 --> 00:01:06,170
因为代码就是短信。
because that's what code is-- text.

19
00:01:06,170 --> 00:01:08,090
现在在这个特殊的程序中，我要去
Now within this particular program, I'm going

20
00:01:08,090 --> 00:01:10,550
能够创建一个或多个文件
to have the ability to create one or more files

21
00:01:10,550 --> 00:01:12,500
通过屏幕的顶部。
via this top portion of the screen.

22
00:01:12,500 --> 00:01:14,810
我会直接跳进去
And I'm going to do so by diving right in

23
00:01:14,810 --> 00:01:17,030
然后在屏幕底部做这个动作。
and doing this at the bottom of my screen.

24
00:01:17,030 --> 00:01:20,060
在我的屏幕底部有一个所谓的终端窗口
At the bottom of my screen is a so-called terminal window

25
00:01:20,060 --> 00:01:25,310
这是一个命令行接口或 CLI 接口
and this is a command line interface or CLI interface to the underlying

26
00:01:25,310 --> 00:01:29,340
计算机，无论是你的 Mac 或 PC，甚至是云中的某个服务器。
computer, be it your Mac or your PC or even some server in the cloud.

27
00:01:29,340 --> 00:01:32,240
我现在要写的就是“代码”然后
And what I'm going to do here is literally write, "code" and then

28
00:01:32,240 --> 00:01:36,530
我想要编码的文件的名称，例如 Hello.py。
the name of the file that I want to code, for instance, Hello.py.

29
00:01:36,530 --> 00:01:40,310
我们很快就会看到，用 Python 编写的任何程序通常都有一个文件
As we'll soon see, any program that you write in Python generally has a file

30
00:01:40,310 --> 00:01:44,210
以. py 结尾的名称，向计算机表明它确实是一个程序
name that ends in .py to indicate to the computer that it's indeed a program

31
00:01:44,210 --> 00:01:45,320
用 Python 写的。
written in Python.

32
00:01:45,320 --> 00:01:48,440
现在你可以看到在我的屏幕顶部，我有一个闪烁的光标,
Now you'll see here at the top of my screen, I have a blinking cursor,

33
00:01:48,440 --> 00:01:51,800
第一行，也就是我代码的第一行要去的地方
a line one-- which is where the very first line of my code is going to go--

34
00:01:51,800 --> 00:01:55,730
然后只有一个标签，提醒我这个文件的名称 Hello.py。
and then just a tab that reminds me of the name of this file Hello.py.

35
00:01:55,730 --> 00:01:58,370
我对巨蟒一无所知
And without even knowing much Python, I'm

36
00:01:58,370 --> 00:02:00,770
我将在这里写我的第一个程序，如下所示
going to write my very first program here as follows--

37
00:02:00,770 --> 00:02:02,120
Print (“ hello，world”)。
print("hello,world").

38
00:02:08,396 --> 00:02:10,729
你会在我的键盘上看到我的一些想法
And you'll see that, at my keyboard, some of my thoughts

39
00:02:10,729 --> 00:02:11,604
对我来说已经结束了。
were finished for me.

40
00:02:11,604 --> 00:02:14,870
我只要输入一个括号另一个就会自动出现,
I only had to type one parenthesis and the other one automatically appeared,

41
00:02:14,870 --> 00:02:18,590
这就是我们将要看到的工具的特性，比如这个工具。
and that's just the feature that we'll see of tools like this tool here.

42
00:02:18,590 --> 00:02:21,080
即使你以前没有编过程序,
Now even if you've never programmed before,

43
00:02:21,080 --> 00:02:25,610
你可以猜测，推断这个简单的程序将要做什么。
odds are you can guess, infer what this simple program is going to do.

44
00:02:25,610 --> 00:02:28,250
而且只有一行。 print (“ hello，world”)。
And it's only one line. print("hello,world").

45
00:02:32,030 --> 00:02:33,830
事实上，当我最终运行这个程序时,
Indeed, when I run this program ultimately,

46
00:02:33,830 --> 00:02:35,948
它只会说，你好，世界。
it's just going to say, Hello to the world.

47
00:02:35,948 --> 00:02:37,490
事实上，这是一个非常著名的
And, in fact, this is a very famous--

48
00:02:37,490 --> 00:02:39,440
也许是最正统的... 程序
perhaps the most canonical-- program that you

49
00:02:39,440 --> 00:02:42,530
可以用 Python 或任何其他语言编写第一个程序,
can write as your very first program in Python or any other language,

50
00:02:42,530 --> 00:02:44,280
这就是我在这里所做的。
and so that's what I've done here.

51
00:02:44,280 --> 00:02:48,230
但是在我的 Mac，PC，甚至我的手机上，我通常都有这个习惯,
But on my Mac, my PC, even my phone, I'm generally in the habit,

52
00:02:48,230 --> 00:02:51,170
像你一样，通过双击图标来运行程序
like you, of running programs by double clicking an icon

53
00:02:51,170 --> 00:02:52,760
或者只是点击屏幕。
or just tapping on the screen.

54
00:02:52,760 --> 00:02:54,920
但我在这里没有看到这样的图标。
But I see no such icons here.

55
00:02:54,920 --> 00:02:58,730
事实上，这是因为我的界面，至少我现在的 Mac
And in fact, that's because my interface to at least my current Mac

56
00:02:58,730 --> 00:03:02,180
或者 PC 或者云中的某个服务器，也只是一个 CLI ——
or PC or some server in the cloud, is again only a CLI--

57
00:03:02,180 --> 00:03:04,340
命令行界面-即使它
command line interface-- which even though it

58
00:03:04,340 --> 00:03:07,820
可能会觉得这是从菜单、按钮和图标退后了一步
might feel like it's a step back from the menus and buttons and icons

59
00:03:07,820 --> 00:03:10,730
我们每天都认为理所当然你会发现，我们认为,
that you and I take for granted every day, you'll find, we think,

60
00:03:10,730 --> 00:03:13,670
它最终是一个更加强大的界面
that it's ultimately a much more powerful interface and incredibly

61
00:03:13,670 --> 00:03:16,920
在现实世界中很受程序员的欢迎。
popular to use among programmers in the real world.

62
00:03:16,920 --> 00:03:20,245
要运行这个程序，我必须使用一个命令
So to run this program, I'm going to have to use a command

63
00:03:20,245 --> 00:03:23,120
我要把光标移回屏幕底部
and I'm going to move my cursor back down to the bottom of the screen

64
00:03:23,120 --> 00:03:25,790
在这里我已经运行了一个命令——
here where previously I already ran one command--

65
00:03:25,790 --> 00:03:30,410
命令代码，它具有在我的计算机中打开 VS 代码的效果,
the command Code which has the effect of opening VS Code in my computer,

66
00:03:30,410 --> 00:03:33,560
然后我把我想要编码的文件的名字传过去。
and then I passed in the name of the file that I wanted to code up.

67
00:03:33,560 --> 00:03:36,000
现在我有机会输入第二条命令,
Now I have a chance to type a second command,

68
00:03:36,000 --> 00:03:38,090
你会看到第二个美元符号。
and you'll see I see a second dollar sign.

69
00:03:38,090 --> 00:03:41,360
这里的美元符号并不代表任何货币,
Now the dollar sign here doesn't indicate any kind of currency or money,

70
00:03:41,360 --> 00:03:43,340
它只是通常使用的符号
it just is the symbol that's generally used

71
00:03:43,340 --> 00:03:46,610
来指示提示符——命令行接口所需的位置
to indicate your prompt-- where the command line interface wants

72
00:03:46,610 --> 00:03:47,990
你来下达命令。
you to put those commands.

73
00:03:47,990 --> 00:03:51,530
现在我可以运行的命令是这样的——
Now the command I can run here is going to be this--

74
00:03:51,530 --> 00:03:55,310
我要运行 Python of Hello.py。
I'm going to run Python of Hello.py.

75
00:03:55,310 --> 00:03:56,490
为什么？
Now why is that?

76
00:03:56,490 --> 00:04:00,380
事实证明，当我用 Python 这样的语言编写代码时,
Well, it turns out that when I actually write code in a language like Python,

77
00:04:00,380 --> 00:04:02,120
当然存在那个文件里
it's of course stored in that file--

78
00:04:02,120 --> 00:04:07,063
Py，但我需要从头到尾解释代码,
Hello.py, but I need to interpret the code top to bottom,

79
00:04:07,063 --> 00:04:09,230
从左到右，以便计算机知道该做什么。
left to right so that the computer knows what to do.

80
00:04:09,230 --> 00:04:10,940
事实上，在一天结束的时候，即使你真的不知道
Indeed, at the end of the day, even if you don't really

81
00:04:10,940 --> 00:04:12,920
你可能对电脑很了解
know much about computers, you've probably

82
00:04:12,920 --> 00:04:16,790
听说计算机只能理解零和一，所谓的二进制
heard the computers only understand zeros and ones, the so-called binary

83
00:04:16,790 --> 00:04:17,390
系统。
system.

84
00:04:17,390 --> 00:04:21,769
如果是这样的话，那就写上“打印”和括号
Well if that's the case, then something that says "print" and parentheses

85
00:04:21,769 --> 00:04:25,430
引用“你好世界”，不一定是0和1。
and quote unquote hello world, is not surely zeros and ones.

86
00:04:25,430 --> 00:04:27,750
我们得想办法把它翻译成0和1
We have to somehow translate it into the zeros and ones

87
00:04:27,750 --> 00:04:29,000
计算机能够理解的。
that the computer understands.

88
00:04:29,000 --> 00:04:33,360
幸运的是，只要你提前安装了这样的程序,
Now fortunately, so long as you've installed such a program in advance,

89
00:04:33,360 --> 00:04:36,380
除了 Python 语言，还有一个程序。
there's a program as well as a language called Python.

90
00:04:36,380 --> 00:04:39,390
所以 Python 不仅仅是一种我们用来编写代码的语言,
So Python is not only a language in which we're going to write code,

91
00:04:39,390 --> 00:04:42,590
它也是一个程序，也被称为解释器
it's also a program otherwise known as an interpreter

92
00:04:42,590 --> 00:04:46,490
你可以在自己的 Mac 或 PC 或者云服务器上免费安装
that you install for free on your own Mac or PC or some server in the cloud

93
00:04:46,490 --> 00:04:50,990
然后你可以运行这个程序，这个解释器，作为输入传递给它
and you can then run that program, that interpreter, passing to it as input

94
00:04:50,990 --> 00:04:53,870
你的文件名就像我的一样 Hello.py。
the name of your file like mine here, Hello.py.

95
00:04:53,870 --> 00:04:56,000
然后那个程序，那个解释器
And then that program, that interpreter, will

96
00:04:56,000 --> 00:04:59,210
处理从上到下，从左到右的阅读过程
handle the process of reading it top to bottom, left to right

97
00:04:59,210 --> 00:05:02,210
然后有效地转换成那些0和1
and translating it effectively into those zeros and ones

98
00:05:02,210 --> 00:05:04,170
计算机能够理解的。
that the computer can understand.

99
00:05:04,170 --> 00:05:05,360
那我们就这么做吧。
So let's do just that.

100
00:05:05,360 --> 00:05:07,190
让我们回到 VS 代码。
Let me go back to VS Code here.

101
00:05:07,190 --> 00:05:11,030
我已经输入了 Python of Hello.py，但是没有按回车键。
I already typed out Python of Hello.py but I didn't get hit Enter.

102
00:05:11,030 --> 00:05:13,430
这就是现在开始执行这个命令的原因
And that's what's now going to kick off this command

103
00:05:13,430 --> 00:05:16,190
希望如果我没有搞砸这一切,
and hopefully, if I didn't mess any of this up,

104
00:05:16,190 --> 00:05:20,370
我应该能看到我的第一个程序在屏幕上的输出。
I should see my very first program's output to the screen.

105
00:05:20,370 --> 00:05:23,480
瞧，你好，世界。
And voila, hello, world.

106
00:05:23,480 --> 00:05:25,970
所以如果你也输入了完全相同的代码
So if you too have typed exactly that same code

107
00:05:25,970 --> 00:05:28,400
并执行完全相同的命令,
and have executed exactly that same command,

108
00:05:28,400 --> 00:05:32,840
在这个例子中，您已经用 Python 编写了第一个程序。
you will have written your very first program in this case in Python.

109
00:05:32,840 --> 00:05:34,790
现在让我们退一步想想,
Well now let's take a step back and consider,

110
00:05:34,790 --> 00:05:37,190
我们到底做了什么
what is it that we actually just did and what

111
00:05:37,190 --> 00:05:38,930
我们在屏幕上看到的是这个吗？
is it we're looking here on the screen?

112
00:05:38,930 --> 00:05:41,450
首先，在大多数编程语言中,
Well first and foremost, in most any programming language,

113
00:05:41,450 --> 00:05:43,950
你可以访问所谓的函数。
you tend to have access to what are called functions.

114
00:05:43,950 --> 00:05:46,460
一个函数就像一个动作或动词
A function is like an action or a verb that

115
00:05:46,460 --> 00:05:48,800
让你在程序中做一些事情。
lets you do something in the program.

116
00:05:48,800 --> 00:05:52,730
一般来说，任何语言都有一些预设的集合
And generally speaking, any language comes with some predetermined set

117
00:05:52,730 --> 00:05:57,097
一些非常基本的动作或动词
of functions-- some very basic actions or verbs that the computer will already

118
00:05:57,097 --> 00:05:59,180
知道如何为你做，语言，真的,
know how to do for you, that the language, really,

119
00:05:59,180 --> 00:06:00,530
会知道如何为你做。
will know how to do for you.

120
00:06:00,530 --> 00:06:04,640
而你，程序员，人类，可以随意使用这些函数
And you, the programmer, the human, can use those functions at will

121
00:06:04,640 --> 00:06:07,020
让电脑来做这些事情。
to get the computer to do those things.

122
00:06:07,020 --> 00:06:11,835
现在这里讨论的程序 Hello.py 正在使用一个函数。
Now the program in question here, Hello.py is using one function.

123
00:06:11,835 --> 00:06:13,460
你也许能猜到是什么。
And you could perhaps guess what it is.

124
00:06:13,460 --> 00:06:16,760
当然，这个函数就是这个函数 print
That function is, of course, going to be this function print

125
00:06:16,760 --> 00:06:19,430
而打印功能，当然，没有
and that print function, of course, doesn't

126
00:06:19,430 --> 00:06:22,340
打印一些预定的文本字符串。
print some preordained string of text.

127
00:06:22,340 --> 00:06:26,240
也就是说，你想打印什么它就打印什么。
That is to say, it prints whatever it is you want it to print.

128
00:06:26,240 --> 00:06:29,600
在这里，我们是否还有另一个术语
And here too, do we have another piece of terminology in the world

129
00:06:29,600 --> 00:06:31,430
指编程，即参数。
of programming, namely arguments.

130
00:06:31,430 --> 00:06:36,830
参数是函数的输入，它会以某种方式影响函数的行为。
An argument is an input to a function that somehow influences its behavior.

131
00:06:36,830 --> 00:06:38,660
当然，发明巨蟒的人,
The people who invented Python, of course,

132
00:06:38,660 --> 00:06:40,790
不一定知道你和我是什么关系
didn't necessarily know what it is you and I

133
00:06:40,790 --> 00:06:43,850
想要打印到屏幕上，所以他们设计了这个打印
are going to want to print to the screen, so they designed this print

134
00:06:43,850 --> 00:06:46,580
函数使用这些括号的能力
function using these parentheses with the ability

135
00:06:46,580 --> 00:06:49,340
输入一些文本字符串
to take as input some string of text, be it

136
00:06:49,340 --> 00:06:52,250
在英语或任何其他人类语言，这是
in English or any other human language, that is

137
00:06:52,250 --> 00:06:56,540
你希望这个函数最终打印到屏幕上的内容。
what you want this function ultimately to print onto the screen.

138
00:06:56,540 --> 00:06:59,640
那么这个程序最终在屏幕上做什么呢？
And what is it that the program is ultimately doing on the screen?

139
00:06:59,640 --> 00:07:01,070
当然是印刷了。
Well, it's printing, of course.

140
00:07:01,070 --> 00:07:03,230
它在向我们问好，屏幕上的世界。
It's showing us hello, world on the screen.

141
00:07:03,230 --> 00:07:05,743
这通常在编程中被称为副作用。
And that's generally in programming known as a side effect.

142
00:07:05,743 --> 00:07:07,160
它可以是视觉的，也可以是音频的。
It can be visual, it can be audio.

143
00:07:07,160 --> 00:07:09,470
在这种情况下，它是出现在屏幕上的东西
In this case, it's something that appears on the screen

144
00:07:09,470 --> 00:07:12,690
和功能，因此，确实可以有这些副作用。
and functions, therefore, can indeed have these side effects.

145
00:07:12,690 --> 00:07:15,650
作为动词或动作，他们可以做的事情之一是
One of the things they can do as this verb or action is

146
00:07:15,650 --> 00:07:19,100
显示在屏幕上作为副作用，类似这些话
to display on the screen as a side effect, something like those words

147
00:07:19,100 --> 00:07:20,240
我们想..
that we wanted--

148
00:07:20,240 --> 00:07:21,870
你好，世界。
hello, world.

149
00:07:21,870 --> 00:07:25,080
这是我的第一个项目，我感觉很好。
So that's my first program and, you know, I'm feeling pretty good.

150
00:07:25,080 --> 00:07:26,570
一切都按计划进行。
Everything worked as planned.

151
00:07:26,570 --> 00:07:28,490
我没有犯任何错误，但是，说实话,
I didn't make any mistakes, but, honestly,

152
00:07:28,490 --> 00:07:30,560
当你学习如何编程，甚至
when you're learning how to program and even

153
00:07:30,560 --> 00:07:34,250
一旦你多年后学会了如何编程，你就会犯错误。
once you've learned how to program years later, you're going to make mistakes.

154
00:07:34,250 --> 00:07:36,615
当然，这些错误都是提到的
And those mistakes, of course, are referred

155
00:07:36,615 --> 00:07:38,990
一个你可能已经知道的术语，那就是 bug。
to a term you might already know, which is that of a bug.

156
00:07:38,990 --> 00:07:42,230
Bug 是程序中的一个错误，它们可以有很多种形式。
A bug is a mistake in a program and they can take so many forms.

157
00:07:42,230 --> 00:07:46,460
也许你会感到欣慰，因为你知道在接下来的几周里,
And take comfort, perhaps, in knowing that over the coming weeks,

158
00:07:46,460 --> 00:07:48,450
你会犯很多错误。
you're going to make so many mistakes.

159
00:07:48,450 --> 00:07:51,320
你的代码会有很多错误，就像我一样
You're going to have so many bugs in your code, just like I did

160
00:07:51,320 --> 00:07:53,490
就像现在一样。
and just as I still do.

161
00:07:53,490 --> 00:07:55,610
那些虫子本身就是错误
And those bugs themselves are just mistakes

162
00:07:55,610 --> 00:07:57,230
都是你要解决的问题。
that are problems for you to solve.

163
00:07:57,230 --> 00:07:59,540
在接下来的几周里，我们会给你
And over the weeks to come, we're going to give you

164
00:07:59,540 --> 00:08:03,760
有很多脑力和技术工具可以帮助你解决这些问题。
a lot of tools both mental and technical via which you can solve those problems.

165
00:08:03,760 --> 00:08:07,010
但是，如果在第一次编写程序时遇到这种情况，请不要气馁
But just don't get discouraged if when writing your program for the first time

166
00:08:07,010 --> 00:08:11,630
甚至第一次都不管用，随着时间的推移，随着练习,
it doesn't even work that first time, it will with time, with practice,

167
00:08:11,630 --> 00:08:12,810
而且经验丰富。
and with experience.

168
00:08:12,810 --> 00:08:15,200
现在让我故意犯一个错误
So let me deliberately now make a mistake

169
00:08:15,200 --> 00:08:18,710
有一个非零的机会，我可能已经意外地做了,
that there was a non-zero chance I might have done accidentally already,

170
00:08:18,710 --> 00:08:19,760
但我很幸运。
but I got lucky.

171
00:08:19,760 --> 00:08:22,280
让我继续，假设我忘了
Let me go ahead and just suppose I forgot

172
00:08:22,280 --> 00:08:24,950
包括括括号之类的东西
to include something like the closing parenthesis

173
00:08:24,950 --> 00:08:26,570
在这行代码的末尾。
at the end of this line of code.

174
00:08:26,570 --> 00:08:30,451
代码几乎是正确的，差不多99% 都是正确的,
The code is almost correct, it's like 99% of the way there,

175
00:08:30,451 --> 00:08:32,659
但现在我已经指出来了，这很明显
but now that I've pointed it out, it's pretty obvious

176
00:08:32,659 --> 00:08:34,820
少了一个括号。
that it's missing that closed parenthesis.

177
00:08:34,820 --> 00:08:39,530
但即使是那些看似微不足道的小细节，你和我作为人类
But even little, seemingly minor details like that, that you and I as humans

178
00:08:39,530 --> 00:08:40,740
也不会在乎。
wouldn't really care about.

179
00:08:40,740 --> 00:08:44,300
如果你正在发送电子邮件或短信，无论如何，这只是一个打印错误。
And if you're sending an email or a text message, whatever, it's just a typo.

180
00:08:44,300 --> 00:08:45,605
没什么大不了的。
It's not that big a deal.

181
00:08:45,605 --> 00:08:47,480
这对电脑来说将是一件大事。
It is going to be a big deal to the computer.

182
00:08:47,480 --> 00:08:49,230
一台电脑会直接把你带到,
A computer is going to take you literally,

183
00:08:49,230 --> 00:08:53,210
如果你没有以语言所期望的方式完成你的思想,
and if you don't finish your thought in the way the language expects,

184
00:08:53,210 --> 00:08:55,380
它根本就不会运行。
it's not going to necessarily run at all.

185
00:08:55,380 --> 00:08:56,112
我们开始吧。
So let's do this.

186
00:08:56,112 --> 00:08:58,820
我现在要清空底部的屏幕
I'm going to go ahead here and clear my screen down at the bottom

187
00:08:58,820 --> 00:09:01,340
这样我就可以重新开始，我要继续跑了
just so I can start fresh, and I'm going to go ahead and run

188
00:09:01,340 --> 00:09:05,420
我的程序的这个版本后，已经作出了更改，删除
this version of my program after having made that change by deleting

189
00:09:05,420 --> 00:09:06,410
括号。
the parenthesis.

190
00:09:06,410 --> 00:09:10,490
我将继续输入 Python，这次是 Hello.py
I'm going to go ahead and type Python again of Hello.py and this time

191
00:09:10,490 --> 00:09:13,040
当我点击回车，我希望我能看到你好，世界,
when I hit Enter, I'm hoping I'm going to see hello, world,

192
00:09:13,040 --> 00:09:16,850
但是这里我们在屏幕上有一个错误，一个所谓的语法
but here we have an error on the screen, a so-called syntax

193
00:09:16,850 --> 00:09:21,140
错误，指的是我在键盘上犯了一个错误。
error, which refers to my having made a mistake at my keyboard.

194
00:09:21,140 --> 00:09:24,030
幸运的是，这个很简单。
And this one, fortunately, is pretty straightforward.

195
00:09:24,030 --> 00:09:28,410
它确实说明了这个开括号从来没有关闭过。
It indeed says that this open parenthesis was never closed.

196
00:09:28,410 --> 00:09:30,945
所以这可能是相当直观的。
And so that's probably pretty intuitive.

197
00:09:30,945 --> 00:09:33,320
现在我需要做的，当然是关闭它。
Now what I need to do, I need to, of course, to close it.

198
00:09:33,320 --> 00:09:36,530
不幸的是，有时我们将在未来几周看到的错误消息
Unfortunately, sometimes the error messages we'll see in the coming weeks

199
00:09:36,530 --> 00:09:38,840
就不会那么方便用户了。
are not going to be nearly that user-friendly.

200
00:09:38,840 --> 00:09:41,720
但是，再一次，用经验，用实践，你会
But there too again, with experience, with practice, will you

201
00:09:41,720 --> 00:09:44,360
更好地调试这些程序。
get better at debugging such programs.

202
00:09:44,360 --> 00:09:46,650
现在让我确认一下我确实正确地修复了它。
Let me now make sure that I indeed fixed it correctly.

203
00:09:46,650 --> 00:09:50,420
现在让我继续运行 Hello.py 并点击 Enter，瞧,
Let me go ahead and run now Hello.py and hit Enter and, voila,

204
00:09:50,420 --> 00:09:51,890
我们又有生意了。
we're back in business.

205
00:09:51,890 --> 00:09:55,430
让我在这里暂停一下，看看我们现在是否有任何问题
Well let me pause here and see if we have any questions now

206
00:09:55,430 --> 00:10:02,480
关于 Python 本身，编写或运行这些程序中最简单的一个。
about Python itself, writing, or running even the simplest of these programs.

207
00:10:02,480 --> 00:10:06,890
观众: 我可以在一个单词中写代码吗? 或者，比如，微软的 Excel？
AUDIENCE: Could I write code inside a word or, for example, Microsoft Excel?

208
00:10:06,890 --> 00:10:09,473
这样做的障碍是什么？
And what's the barrier to doing that?

209
00:10:09,473 --> 00:10:11,390
大卫 · 马兰: 一个非常好的问题，允许
DAVID MALAN: A really good question, and allow

210
00:10:11,390 --> 00:10:14,630
我非常明确地对整个互联网说
me to very explicitly say to the entire internet

211
00:10:14,630 --> 00:10:17,810
您不应该使用 MicrosoftWord 编写代码。
that you should not write code with Microsoft Word.

212
00:10:17,810 --> 00:10:20,480
我提到这个只是因为它是一个工具
I mentioned that only because it's a tool via which

213
00:10:20,480 --> 00:10:23,283
你可以写文本，代码，在一天结束的时候，只是文本。
you can write text and code is, at the end of the day, just text.

214
00:10:23,283 --> 00:10:24,950
但这不是做这项工作的合适工具。
But it's not the right tool for the job.

215
00:10:24,950 --> 00:10:27,890
我们不需要大胆的面对，下划线，段落等等。
We don't need bold facing, underlining, paragraphs and the like.

216
00:10:27,890 --> 00:10:31,580
我们通常想要一些比微软 Word 或谷歌文档简单得多的东西。
We generally want something much simpler than Microsoft Word or Google Docs.

217
00:10:31,580 --> 00:10:36,110
因此 VS Code 只是一个更通用的文本编辑器的例子。
And so VS Code is an example of just a more general purpose text editor.

218
00:10:36,110 --> 00:10:39,110
它在生活中的目的是允许你，人类，编辑文本。
Its purpose in life is to allow you, the human, to edit text.

219
00:10:39,110 --> 00:10:42,050
如今，这些文本编辑器具有更多的特性。
Nowadays these text editors come with many more features.

220
00:10:42,050 --> 00:10:44,600
事实上，你会注意到即使在我的代码中,
In fact, you'll notice that even in my code here,

221
00:10:44,600 --> 00:10:47,570
虽然只是一行字，但还是有点色彩的。
even though it's just one line, there's a bit of color to it.

222
00:10:47,570 --> 00:10:49,910
“印刷”这个词对我来说是蓝色的。
The word "print" for me is appearing in blue.

223
00:10:49,910 --> 00:10:51,050
括号是黑色的。
The parentheses are black.

224
00:10:51,050 --> 00:10:54,290
我们会看到，当我们编写更多的代码行，越来越多的行
And we'll see as we write more lines of code, more and more of the lines

225
00:10:54,290 --> 00:10:56,630
将以各种颜色复活。
will come to life in various colors.

226
00:10:56,630 --> 00:10:58,993
这只是文本编辑器的一个特性。
Now that's just one feature of a text editor.

227
00:10:58,993 --> 00:11:01,910
我们还将看到它具有类似这个内置终端窗口的特性。
We'll see too that it has features like this built-in terminal window.

228
00:11:01,910 --> 00:11:05,120
它将拥有一个用于调试或查找问题的内置工具
It's going to have a built-in tool for debugging or finding problems

229
00:11:05,120 --> 00:11:05,780
用密码。
with code.

230
00:11:05,780 --> 00:11:07,760
现在它是一种非常流行的工具,
And it's just a very popular tool nowadays,

231
00:11:07,760 --> 00:11:09,560
但外面还有很多很多其他人。
but there are many, many others out there.

232
00:11:09,560 --> 00:11:11,900
你可以在这门课和以后的课上使用它们。
You're welcome to use them for this course and beyond.

233
00:11:11,900 --> 00:11:14,120
我们只是碰巧在很大程度上用到了这个
We just happen to use this one in large part

234
00:11:14,120 --> 00:11:18,980
因为现在你也可以在云端免费使用 VS 代码。
too because you can also use VS Code nowadays for free in the cloud.

235
00:11:18,980 --> 00:11:22,190
这里还有一个关于 Python 编程的问题怎么样
How about one other question here on programming with Python

236
00:11:22,190 --> 00:11:24,950
还是 hello，world 或者更一般的语法？
or hello, world or syntax more generally?

237
00:11:24,950 --> 00:11:28,850
观众: 是的，我想问如果它不是
AUDIENCE: Yeah I was trying to ask if it's not

238
00:11:28,850 --> 00:11:31,923
可以使用终端窗口运行计算机吗？
possible to run the computer using the terminal window?

239
00:11:31,923 --> 00:11:33,590
大卫. 马兰: 我想我听到的是不是——
DAVID MALAN: I think I heard is it not--

240
00:11:33,590 --> 00:11:37,530
是否有可能在没有终端窗口的情况下运行程序？
if it's possible to run the program without the terminal window?

241
00:11:37,530 --> 00:11:38,030
你.
Are you--

242
00:11:38,030 --> 00:11:38,540
观众: 是的，先生。
AUDIENCE: Yes, sir.

243
00:11:38,540 --> 00:11:39,870
大卫 · 马兰: 好吧，你又为我愣住了。
DAVID MALAN: OK, you froze for me again.

244
00:11:39,870 --> 00:11:41,730
但让我来推断一下问题是什么。
But let me infer what the question is.

245
00:11:41,730 --> 00:11:44,660
所以在这个环境中，当我配置我的电脑时,
So in this environment, as I've configured my computer,

246
00:11:44,660 --> 00:11:48,320
我只能通过终端窗口运行这些 Python 程序。
I can only run these Python programs via the terminal window.

247
00:11:48,320 --> 00:11:51,140
这对我，程序员，或者那些
Now that's good for me, the programmer, or the person who's

248
00:11:51,140 --> 00:11:53,390
试图学习如何编程，但不是很好
trying to learn how to program, but it's not very good

249
00:11:53,390 --> 00:11:57,050
如果您想发布这个软件，并让其他人使用您的实际代码。
if you want to ship this software and have other people use your actual code.

250
00:11:57,050 --> 00:12:01,550
你完全可以编写程序，然后让其他人使用,
You can absolutely write programs and then allow other people to use,

251
00:12:01,550 --> 00:12:05,300
不是一个命令行界面，而是一个图形用户界面或图形用户界面——
not a command line interface, but a graphical user interface or GUI--

252
00:12:05,300 --> 00:12:08,390
G-U-I，这只是一个机制，也许，我认为,
G-U-I. This is just one mechanism and perhaps, I think,

253
00:12:08,390 --> 00:12:10,700
开始编写代码的最佳方法
the best one with which to start writing code

254
00:12:10,700 --> 00:12:14,045
因为最终它会给我们更多的控制权。
because eventually it's going to give us a lot more control.

255
00:12:14,045 --> 00:12:15,920
请允许我在这里继续前进，但请感受
Allow me to forge ahead here, but please feel

256
00:12:15,920 --> 00:12:19,820
只要通过聊天就可以继续提问。
free to continue asking questions along the way if only via the chat.

257
00:12:19,820 --> 00:12:23,690
现在让我们考虑如何改进这个程序。
Let's consider now how we might go about improving this program.

258
00:12:23,690 --> 00:12:27,530
让我们来改进一下这个程序，使它更具有交互性
Let's go about improving this program to make it a little more interactive

259
00:12:27,530 --> 00:12:30,740
而不是假设每个人都想被欢迎
and not just assume that everyone is going to want to be greeted

260
00:12:30,740 --> 00:12:32,120
更通俗地说就是“你好，世界”。
more generically as hello, world.

261
00:12:32,120 --> 00:12:35,120
看看我能不能让这个程序说出“你好，大卫”这样的话
Let's see if I can't get this program to say something like Hello, David

262
00:12:35,120 --> 00:12:40,280
或者 Hello Jeremiah 或者 Hello Horatio 或者其他用户的名字。
or Hello, Jeremiah or Hello, Horatio or whatever the actual user's name is.

263
00:12:40,280 --> 00:12:43,670
为了做到这一点，我要回到“你好，圆周率”
Well to do this I'm going to go back up to Hello to pi

264
00:12:43,670 --> 00:12:46,950
我要在最上面再加一行代码,
and I'm going to add another line of code at the very top that simply says,

265
00:12:46,950 --> 00:12:52,490
比如，你叫什么名字，引号后面多加一个空格。
for instance, what's your name, quote unquote with an extra space at the end.

266
00:12:52,490 --> 00:12:55,530
所以我打印给用户询问他们一些输入的问题,
So I'm printing to the user asking them a question for some input,

267
00:12:55,530 --> 00:12:58,940
但现在我需要另一个函数来实际获取用户的输入。
but now I need another function to actually get input from the user.

268
00:12:58,940 --> 00:13:02,550
而且，完美的是，足够多的 Python 附带了一个名为 input 的函数。
And, perfectly, enough Python comes with a function named input.

269
00:13:02,550 --> 00:13:06,470
这里我要调用一个函数输入打开括号,
So here I'm going to go ahead and call a function input, open paren,

270
00:13:06,470 --> 00:13:07,400
关闭括号。
close paren.

271
00:13:07,400 --> 00:13:11,000
这将提示用户只有一个闪烁的光标在等待
And that's going to prompt the user with just a blinking cursor waiting

272
00:13:11,000 --> 00:13:12,440
让他们输入一些东西。
for them to type something in.

273
00:13:12,440 --> 00:13:15,860
结果是，如果我读了输入函数的文档,
Now it turns out, if I read the documentation for the input function,

274
00:13:15,860 --> 00:13:18,210
它实际上需要一个论点本身。
it actually takes an argument itself.

275
00:13:18,210 --> 00:13:21,740
我不需要单独使用“ print”然后提示用户输入。
I don't need to use "print" separately and then prompt the user for input.

276
00:13:21,740 --> 00:13:25,100
所以我可以在使用代码之前就简化它。
So I can actually simplify this code before we even use it.

277
00:13:25,100 --> 00:13:28,430
我要继续从 print 中取出同样的字符串,
I'm going to go ahead here and take that same string from print,

278
00:13:28,430 --> 00:13:30,800
把它作为输入函数的参数,
put it as an argument to the input function,

279
00:13:30,800 --> 00:13:32,383
把“指纹”一起去掉。
and get rid of the "print" altogether.

280
00:13:32,383 --> 00:13:34,967
而且，事实上，“ print”本来也会添加一行新的内容。
And, in fact, that "print" would have added a new line anyway.

281
00:13:34,967 --> 00:13:37,340
现在我得到了用户光标所在的提示符
So now I've just got a prompt where the user's cursor is

282
00:13:37,340 --> 00:13:41,030
最后会眨眼问他们，你叫什么名字？
going to end up blinking at the end of the line asking them, what's your name?

283
00:13:41,030 --> 00:13:46,580
在终端窗口中，我将运行 Python of Hello.py，Enter。
In my terminal window I'm going to run Python of Hello.py, Enter.

284
00:13:46,580 --> 00:13:47,150
好的。
OK.

285
00:13:47,150 --> 00:13:48,150
我们有进展了。
We're making progress.

286
00:13:48,150 --> 00:13:51,280
似乎这个新的函数输入确实提示我，人类,
It seems that this new function input is indeed prompting me, the human,

287
00:13:51,280 --> 00:13:51,780
输入。
for input.

288
00:13:51,780 --> 00:13:53,155
我要输入我的名字
So I'm going to type in my name--

289
00:13:53,155 --> 00:13:54,290
大卫——然后按回车键。
David-- and hit Enter.

290
00:13:54,290 --> 00:13:57,440
不幸的是，这和我的名字没什么关系,
Unfortunately, it doesn't really do anything with my name,

291
00:13:57,440 --> 00:13:59,240
它只是立即输出它。
it just outputs it immediately.

292
00:13:59,240 --> 00:14:01,160
好吧，我能搞定的，对吧？
All right, well, I could fix this, right?

293
00:14:01,160 --> 00:14:05,480
我可以去2行把“ world”改成“ David”
I could go up to line 2 and I could change "world" to "David,"

294
00:14:05,480 --> 00:14:10,310
然后回到我的终端窗口，在这里我可以做 Python 的 Hello.py，Enter。
and then back in my terminal window here I can do Python of Hello.py, Enter.

295
00:14:10,310 --> 00:14:11,150
你叫什么名字？
What's your name?

296
00:14:11,150 --> 00:14:12,410
大卫，进来。
David, Enter.

297
00:14:12,410 --> 00:14:13,105
好了。
And there we go.

298
00:14:13,105 --> 00:14:14,480
好了，现在我可以开始工作了。
All right now I'm up and running.

299
00:14:14,480 --> 00:14:17,520
现在我的程序正在按预期运行。
Now my program is working as intended.

300
00:14:17,520 --> 00:14:21,410
当然，这不是真正的工作原理。
Of course, this isn't really working as intended here.

301
00:14:21,410 --> 00:14:25,070
让我继续假装是我的同事 Carter。
Let me go ahead and try pretending to be my colleague, Carter here.

302
00:14:25,070 --> 00:14:26,760
卡特的名字是这样的。
Well Carter's name is this.

303
00:14:26,760 --> 00:14:29,927
我现在要按回车，然后我会看到，当然，你好，卡特
I'm going to go ahead and hit Enter and I'll see, of course, Hello, Carter--

304
00:14:29,927 --> 00:14:32,520
显然不是，因为我已经硬编码了，可以这么说,
well, obviously not, because I've hardcoded, so to speak,

305
00:14:32,520 --> 00:14:35,010
我已经把我的名字写在字符串里了。
I've written literally my name inside of the string.

306
00:14:35,010 --> 00:14:40,040
所以我们现在需要一些方法来实际得到用户的输入是什么
So we need some way now of actually getting back what the user's input is

307
00:14:40,040 --> 00:14:41,780
并最终用它做些事情。
and doing something with it ultimately.

308
00:14:41,780 --> 00:14:44,930
为此我们将利用编程的另一个特性,
And for this we're going to leverage another feature of programming,

309
00:14:44,930 --> 00:14:47,510
特别是某些函数的一个特性，那就是它们
specifically a feature of some functions, which is that they

310
00:14:47,510 --> 00:14:49,850
也可以有返回值。
can have return values as well.

311
00:14:49,850 --> 00:14:52,700
如果你再次把输入看作是这个动作,
If you think of input as being, again, this action,

312
00:14:52,700 --> 00:14:55,880
这个动词，你可以把它拟人化为一个人,
this verb-- you can actually personify it as maybe a person,

313
00:14:55,880 --> 00:14:58,130
就像你的一个朋友，你问了一个问题
like a friend of yours that you've asked a question of

314
00:14:58,130 --> 00:15:00,797
你让你的朋友去找别人帮忙
and you've asked your friend to go get input from someone else--

315
00:15:00,797 --> 00:15:02,210
去问那个人他们的名字。
go ask that person their name.

316
00:15:02,210 --> 00:15:05,630
如果你的朋友回来时知道了那个人的名字,
And if your friend comes back knowing that person's name, well,

317
00:15:05,630 --> 00:15:08,357
如果他们把那个名字还给你不是很好吗？
wouldn't it be nice if they handed that name back to you?

318
00:15:08,357 --> 00:15:10,940
这就是我们需要的隐喻功能,
That's kind of what we need metaphorically the function to do,

319
00:15:10,940 --> 00:15:15,200
就是获取用户的输入，然后交还给我，这样我这个程序员,
is get the user's input and then hand it back to me so that I, the programmer,

320
00:15:15,200 --> 00:15:16,610
可以做点什么。
can do something with it.

321
00:15:16,610 --> 00:15:19,280
但如果要还给我,
But if it's going to be handed back to me,

322
00:15:19,280 --> 00:15:23,060
我想把它放在某个地方这样我就可以把它打印出来了
I kind of want to put it somewhere so that I can then print it back

323
00:15:23,060 --> 00:15:23,720
在屏幕上。
on the screen.

324
00:15:23,720 --> 00:15:26,970
我需要做相当于拿出一张纸或便利贴,
I need to do the equivalent of take out like a piece of paper or Post-It note,

325
00:15:26,970 --> 00:15:31,040
在这张纸上写下人类所说的话,
write down on this piece of paper what it is the human has said,

326
00:15:31,040 --> 00:15:34,650
这样我就可以把它输入到打印函数中。
so that I can then feed it into as input that print function.

327
00:15:34,650 --> 00:15:38,120
要做到这一点，我们还需要一个编程特性，即
And to do that, we're going to need one more feature of programming, namely

328
00:15:38,120 --> 00:15:38,960
变量。
variables.

329
00:15:38,960 --> 00:15:42,410
而且很有可能，大多数人都熟悉数学课上的变量
And odds are, most everyone's familiar with variables from math class

330
00:15:42,410 --> 00:15:45,380
很久以前，x，y，z 之类的。
way back when-- x and y and z and the like.

331
00:15:45,380 --> 00:15:48,110
编程也有同样的能力，这种能力
Well, programming has that same capability, this ability

332
00:15:48,110 --> 00:15:51,560
创建一个变量——在这个例子中，在计算机的内存中——
to create a variable-- in this case, in the computer's memory--

333
00:15:51,560 --> 00:15:53,100
而不是一张纸。
not just on a piece of paper.

334
00:15:53,100 --> 00:15:55,620
这个变量可以存储一个值
And that variable can store a value--

335
00:15:55,620 --> 00:15:58,910
一个数字，一些文字，甚至一个图像或视频或更多。
a number, some text, even an image or video or more.

336
00:15:58,910 --> 00:16:06,740
变量只是计算机内部某个值的容器
A variable is just a container for some value inside of a computer

337
00:16:06,740 --> 00:16:08,300
或者在你自己的程序里。
or inside of your own program.

338
00:16:08,300 --> 00:16:11,303
那么，我该如何用这种方式表达自己呢？
So how do I go about expressing myself in this way?

339
00:16:11,303 --> 00:16:13,220
我想我要做的就是介绍
Well I think what I'm going to do is introduce

340
00:16:13,220 --> 00:16:16,730
一个比 x 或 y 更有趣的变量。
a variable that's a little more interestingly named than x or y.

341
00:16:16,730 --> 00:16:19,970
我可以这样说—— x = input。
I could just say this-- x = input.

342
00:16:19,970 --> 00:16:23,780
但我要用一个比典型的数学变量更好的名字
But I'm going to use a better name than a typical mathematical variable here

343
00:16:23,780 --> 00:16:26,240
为什么我要称变量为“ name”呢？
and I'm going to literally call my variable "name," why?

344
00:16:26,240 --> 00:16:29,073
在编程方面，因为我面前有一整个键盘,
Well in programming, because I have a whole keyboard in front of me,

345
00:16:29,073 --> 00:16:32,150
我可以用更多的描述性术语来描述我正在写的东西。
I can use more descriptive terms to describe what it is I'm writing.

346
00:16:32,150 --> 00:16:36,590
但是现在，我们有机会考虑一个特定的语法。
And now, though, there's an opportunity to consider a specific piece of syntax.

347
00:16:36,590 --> 00:16:39,470
我们看过括号，我们看过引号，所有这些
We've seen parentheses, we've seen quotes, all of which

348
00:16:39,470 --> 00:16:42,020
在传递输入到函数时是必需的,
are necessary when passing inputs to a function,

349
00:16:42,020 --> 00:16:47,810
但这个等号在右边的输入和名字之间
but this equal sign here that's in between input on the right and name

350
00:16:47,810 --> 00:16:49,820
实际上是很重要的。
on the left is actually important.

351
00:16:49,820 --> 00:16:52,490
严格来说，这不是一个等号。
And it's technically not an equal sign per se.

352
00:16:52,490 --> 00:16:56,060
与其说它意味着相等，不如说它意味着赋值。
It doesn't mean equality as much as it means assignment.

353
00:16:56,060 --> 00:16:59,000
所以在 Python 和许多编程语言中,
So in Python and many programming languages,

354
00:16:59,000 --> 00:17:01,610
单个等号是赋值运算符
a single equal sign is the assignment operator

355
00:17:01,610 --> 00:17:03,860
具体的意思是，你
and what that means specifically is that, you

356
00:17:03,860 --> 00:17:08,839
无论用户的输入是什么，都要从右向左分配。
want to assign from right to left whatever the user's input is.

357
00:17:08,839 --> 00:17:14,540
所以无论返回值是多少，等号都是从右向左复制的
So the equal sign copies from the right to the left whatever the return

358
00:17:14,540 --> 00:17:17,420
右边函数的值是。
value of the function on the right is.

359
00:17:17,420 --> 00:17:20,670
因此，输入函数显然是从用户那里获得输入的。
So again, the input function clearly gets input from the user.

360
00:17:20,670 --> 00:17:24,140
这就是为什么我能输入我的名字或者卡特的，但是
That's why I was able to type my name or Carter's, but it also

361
00:17:24,140 --> 00:17:29,390
在幕后把值，返回值传递给我
sort of behind the scenes hands that value, that return value, back to me

362
00:17:29,390 --> 00:17:30,230
程序员。
the programmer.

363
00:17:30,230 --> 00:17:33,680
如果我用一个等号和一个变量不管我怎么称呼它,
And if I use an equal sign and a variable, no matter what I call it,

364
00:17:33,680 --> 00:17:38,460
我可以将输入存储在该变量中，以便以后重用它。
I can store that input in that variable so as to reuse it later.

365
00:17:38,460 --> 00:17:40,670
所以现在，坐在电脑内存的某个地方,
So now, sitting in the computer's memory somewhere,

366
00:17:40,670 --> 00:17:44,870
是一个包含“大卫”报价，引号或“卡特”报价的容器,
is a container containing "David" quote, unquote or "Carter" quote,

367
00:17:44,870 --> 00:17:47,490
或者其他人类输入的东西。
unquote, or whatever the human has typed in.

368
00:17:47,490 --> 00:17:49,280
但在这里很容易出错。
But here it's easy to make a mistake.

369
00:17:49,280 --> 00:17:53,850
假设我决定尝试打印这个名称等等
Suppose I decide to try to print that name and so

370
00:17:53,850 --> 00:17:57,800
我有种直觉，你好，名字。
I kind of on a hunch type in this, hello, name.

371
00:17:57,800 --> 00:18:00,440
只是插入了变量的名称。
Just kind of plugging in the name of the variable.

372
00:18:00,440 --> 00:18:05,300
让我继续运行 Python of Hello.py 并点击 Enter。
Well let me go ahead here and run Python of Hello.py and hit Enter.

373
00:18:05,300 --> 00:18:07,040
这会让我想起自己的名字。
That's going to prompt me for my name.

374
00:18:07,040 --> 00:18:08,207
让我输入我的名字
And let me type in my name--

375
00:18:08,207 --> 00:18:10,440
D-A-V-I-D 但我还没按回车键。
D-A-V-I-D. But I haven't hit Enter yet.

376
00:18:10,440 --> 00:18:15,350
也许通过聊天，当我现在点击回车时会发生什么？
And perhaps via the chat, what's going to happen here when I now hit Enter?

377
00:18:15,350 --> 00:18:17,840
我希望它说，你好，大卫。
I'm hoping it says, Hello, David.

378
00:18:17,840 --> 00:18:22,580
如果上面写的是“你好，世界”我没意见，但我不想让它写出实际情况
I'd be OK if it says Hello, world, but I don't want it to say what it's actually

379
00:18:22,580 --> 00:18:25,370
会说，是的，我们在聊天中看到的是,
going to say and, yep, what we're seeing in the chat is,

380
00:18:25,370 --> 00:18:28,640
可能是字面上的“你好，名字”。
well, it's probably going to say literally Hello, name.

381
00:18:28,640 --> 00:18:30,030
所以这并不完全正确。
So that's not quite right.

382
00:18:30,030 --> 00:18:34,250
所以我们需要另一种方法来打印出变量内部的值
So we need another way of printing out the value inside of that variable

383
00:18:34,250 --> 00:18:36,785
而不是“名字”这个词
rather than just this word "name."

384
00:18:36,785 --> 00:18:38,910
让我用几种不同的方法来试试。
Well let me try this in a couple of different ways.

385
00:18:38,910 --> 00:18:40,890
让我试试这样——
Let me try this as follows--

386
00:18:40,890 --> 00:18:44,390
让我继续，也许可以撤销这个，因为我已经做得很好了
let me go ahead and maybe undo this because I've gotten pretty good already

387
00:18:44,390 --> 00:18:45,550
打招呼。
at saying Hello.

388
00:18:45,550 --> 00:18:48,050
所以让我们划清界限，然后说，好吧,
So let's draw that line in the sand and just say, all right,

389
00:18:48,050 --> 00:18:50,360
我们至少把 Hello 逗号弄出去吧。
let's get at least get Hello comma out the door.

390
00:18:50,360 --> 00:18:53,790
现在打印姓名，凭直觉，我要试试这个。
Let's now print name and just on a hunch, I'm going to try this.

391
00:18:53,790 --> 00:18:55,115
我要再次使用指纹
I'm going to use print again--

392
00:18:55,115 --> 00:18:57,740
因为你可以根据需要使用这些函数
because you can use these functions as many times as you need--

393
00:18:57,740 --> 00:19:02,660
我要把名为 name 的变量传递给 print 函数。
and I'm going to pass to the print function the variable called name.

394
00:19:02,660 --> 00:19:04,730
但是注意我现在有点聪明了。
But notice I'm being a little clever now.

395
00:19:04,730 --> 00:19:07,970
我不会把它放在双引号里，因为我们已经看过那个双引号了
I'm not putting it in double quotes because we've seen already that double

396
00:19:07,970 --> 00:19:10,610
引号的意思是字面上打印出 N-A-M-E。
quotes means literally print out N-A-M-E.

397
00:19:10,610 --> 00:19:13,700
这次我要删掉引用，希望,
I'm getting rid of the quotes this time in hopes that,

398
00:19:13,700 --> 00:19:19,440
现在，通过将名为 name 的变量传递给名为 print 的函数,
now by passing the variable called name to the function called print it will,

399
00:19:19,440 --> 00:19:23,480
实际上，打印这个变量的内容,
in fact, go about printing the contents of that variable that is,

400
00:19:23,480 --> 00:19:24,808
所谓的价值。
its so-called value.

401
00:19:24,808 --> 00:19:26,600
好吧，我们就在这里开始吧。
All right, let's go ahead and do this here.

402
00:19:26,600 --> 00:19:29,030
Python of Hello.py，Enter.
Python of Hello.py, Enter.

403
00:19:29,030 --> 00:19:30,020
你叫什么名字？
What's your name?

404
00:19:30,020 --> 00:19:30,590
大卫。
David.

405
00:19:30,590 --> 00:19:35,520
现在，我仍然祈祷，我看到你好逗号大卫。
And now, crossing my fingers still, I see Hello comma David.

406
00:19:35,520 --> 00:19:36,020
好吧。
All right.

407
00:19:36,020 --> 00:19:38,090
所以这不是最好的项目。
So it's not the best program.

408
00:19:38,090 --> 00:19:40,670
可以这么说，我在走捷径。
I'm kind of cutting some corners here, so to speak.

409
00:19:40,670 --> 00:19:44,128
我说你好，大卫，在两条不同的线路上。
I'm saying Hello, David on two separate lines.

410
00:19:44,128 --> 00:19:45,920
所以它不够优雅，不够漂亮,
So it's not as elegant, it's not as pretty,

411
00:19:45,920 --> 00:19:48,950
它在英语中的语法不像说出来那么恰当
it's not as grammatically appropriate in English as just saying it

412
00:19:48,950 --> 00:19:52,820
都在同一条线上，但至少我解决了问题，只是没有
all in one breath on one line, but at least I've solved the problem, just not

413
00:19:52,820 --> 00:19:54,020
非常好。
very well yet.

414
00:19:54,020 --> 00:19:56,390
但是现在让我退一步，也许介绍一下
But let me take a step back now and perhaps introduce

415
00:19:56,390 --> 00:19:59,070
还有一些我们应该熟悉的概念,
a couple of other concepts with which we should be familiar,

416
00:19:59,070 --> 00:20:03,260
这是因为我们的程序越来越长，它们不再只是一行或两行
which is as our programs get longer and they're no longer just one line or two

417
00:20:03,260 --> 00:20:07,370
甚至三个，最终我们的程序会变成几十行,
or even three, eventually our programs are going to become dozens of lines,

418
00:20:07,370 --> 00:20:09,020
甚至可能有几百行。
maybe even hundreds of lines long.

419
00:20:09,020 --> 00:20:11,990
让我们为未来的成功做好准备。
Let's set the stage for success moving forward.

420
00:20:11,990 --> 00:20:14,840
事实证明，Python 和许多编程语言
It turns out that Python and a lot of programming languages

421
00:20:14,840 --> 00:20:17,120
也支持一种叫做评论的东西。
also support something called comments.

422
00:20:17,120 --> 00:20:21,200
注释是代码中对自己的注释
Comments are notes to yourself in your code

423
00:20:21,200 --> 00:20:24,260
并且通过一个特殊的符号(在 Python 中)包含注释
and you include comments by way of a special symbol-- in Python

424
00:20:24,260 --> 00:20:26,150
通常是散列符号
it's going to be the hash symbol, typically--

425
00:20:26,150 --> 00:20:27,980
这样你就可以写出等价的
and that allows you to write the equivalent

426
00:20:27,980 --> 00:20:30,950
给你自己的一个音符，但在某种程度上，不会打破你的代码。
of a note to yourself but in a way that's not going to break your code.

427
00:20:30,950 --> 00:20:33,380
计算机实际上忽略了你的评论。
The computer actually ignores your comment.

428
00:20:33,380 --> 00:20:36,030
它就在你身边，它就在你的老师身边,
It's just there for you, it's just there for your teacher,

429
00:20:36,030 --> 00:20:38,030
只是为你的同事准备的
it's just there for your colleague with whom

430
00:20:38,030 --> 00:20:40,020
你最终会分享那些代码。
you're sharing ultimately that code.

431
00:20:40,020 --> 00:20:42,320
所以如果我回到 VS 码这里
So if I go back to VS Code here and I just

432
00:20:42,320 --> 00:20:46,040
我想给这个节目添加一些评论，向我的老师解释,
want to add some comments to this program to explain to my teacher,

433
00:20:46,040 --> 00:20:49,325
告诉我自己，告诉我的同事这个项目在做什么,
to myself, to my colleagues what this program is doing,

434
00:20:49,325 --> 00:20:50,700
那我们就这么做吧。
well, let's go ahead and do that.

435
00:20:50,700 --> 00:20:54,020
我将从程序的最顶端开始，在第1行
I'm going to go at the very top of my program and on line 1

436
00:20:54,020 --> 00:20:56,990
现在我要把原始代码行往下移一点,
now I'm going to move that original line of code down a bit,

437
00:20:56,990 --> 00:21:00,530
我要加一个散列，然后这样说,
I'm going to add a hash, and I'm going to say something like this,

438
00:21:00,530 --> 00:21:03,210
向用户询问他们的名字。
ask user for their name.

439
00:21:03,210 --> 00:21:05,040
现在，我不需要用那种语言。
Now, I don't have to use that language.

440
00:21:05,040 --> 00:21:06,950
我没必要用那条短信。
I don't have to use that text.

441
00:21:06,950 --> 00:21:08,910
我可以使用任何人类的语言。
I could use any human language whatsoever.

442
00:21:08,910 --> 00:21:10,250
不一定非得是英语。
It doesn't have to be English.

443
00:21:10,250 --> 00:21:14,120
但我现在要说的是，在这下面，就像这样说
But I'm going to now, below that, just say something like this--

444
00:21:14,120 --> 00:21:16,012
向用户问好。
say Hello to user.

445
00:21:16,012 --> 00:21:17,720
你会注意到默认的 VS 代码
And you'll notice that VS Code by default

446
00:21:17,720 --> 00:21:19,302
让我的评论都变灰了。
is kind of graying out my comments.

447
00:21:19,302 --> 00:21:22,010
它们不再是蓝色的，没有红色，没有颜色。
They're no longer blue, there's no red, there's no color in them.

448
00:21:22,010 --> 00:21:24,240
那只是因为它们是我的笔记
And that's just because they're notes to myself

449
00:21:24,240 --> 00:21:26,730
计算机最终会忽略它们。
and the computer ultimately is going to ignore them.

450
00:21:26,730 --> 00:21:29,350
但是我们现在有两条评论——问用户
But what we have now is two comments-- ask user

451
00:21:29,350 --> 00:21:32,380
为他们的名字，然后第二个评论，说你好用户。
for their name and then a second comment, say Hello to user.

452
00:21:32,380 --> 00:21:35,590
我给每段代码都加了注释,
And I've just kind of commented each chunk of code,

453
00:21:35,590 --> 00:21:40,180
就像每一行或每一行代码的复数，它们都在做一些值得注意的事情。
like each line or lines plural of code, that are doing something noteworthy.

454
00:21:40,180 --> 00:21:40,750
为什么？
Why?

455
00:21:40,750 --> 00:21:43,120
明天早上我醒来的时候
Well, tomorrow morning when I wake up having

456
00:21:43,120 --> 00:21:47,740
睡了很长一段时间，忘记了我前一天做了什么,
slept for quite some time, forgotten what it is I did the previous day,

457
00:21:47,740 --> 00:21:49,840
看到评论很方便
it's convenient with comments to just see

458
00:21:49,840 --> 00:21:52,510
在英语或你自己的人类语言什么
in English or your own human language what

459
00:21:52,510 --> 00:21:55,810
这个程序这样做是为了让你不必去读代码本身
it is this program is doing so that you don't have to read the code itself

460
00:21:55,810 --> 00:21:59,200
更好的是，如果以后出了什么差错,
and, better yet, if there's maybe a mistake down the road,

461
00:21:59,200 --> 00:22:02,740
你可以读你的意图是什么，然后你可以看代码
you can read what your intention was and then you can look at the code

462
00:22:02,740 --> 00:22:06,050
并确定您的代码现在是否正在执行您想要的操作。
and figure out if your code is now doing what you intended.

463
00:22:06,050 --> 00:22:08,920
所以对于这么小的程序来说，这是不必要的。
So this isn't really necessary for a program this small.

464
00:22:08,920 --> 00:22:11,287
只要一两三句台词就很明显了
It's pretty obvious with just one or two or three lines

465
00:22:11,287 --> 00:22:12,370
程序在做什么。
what the program is doing.

466
00:22:12,370 --> 00:22:14,668
读代码和读注释一样快,
It's just as fast to read the code than the comments,

467
00:22:14,668 --> 00:22:16,960
但是养成这个习惯通常是件好事
but getting into this habit is generally a good thing--

468
00:22:16,960 --> 00:22:21,220
每隔一行或几行注释代码，以提醒自己
to comment your code every one or a few lines so as to remind yourself

469
00:22:21,220 --> 00:22:24,250
而其他人则知道您的意图和代码正在做什么。
and others what it is your intent and your code is doing.

470
00:22:24,250 --> 00:22:26,590
评论的好处也在于——
What's nice about comments too is this--

471
00:22:26,590 --> 00:22:30,940
评论也可以成为你的待办事项清单。
comments can also serve to be sort of a to-do list for yourself.

472
00:22:30,940 --> 00:22:33,850
在伪代码编程中有这样一个概念。
There's this notion in programming of pseudocode.

473
00:22:33,850 --> 00:22:35,350
伪代码不是一个正式的东西。
Pseudocode isn't a formal thing.

474
00:22:35,350 --> 00:22:37,300
这不是一种特定的语言。
It's not one specific language.

475
00:22:37,300 --> 00:22:40,090
只是用英语或者你自己的人类语言
It's just using English or your own human language

476
00:22:40,090 --> 00:22:44,590
简洁有条不紊地用算法表达你的想法,
to express your thoughts succinctly, methodically, algorithmically,

477
00:22:44,590 --> 00:22:45,460
可以这么说。
so to speak.

478
00:22:45,460 --> 00:22:48,070
但是伪代码，因此，因为它不是 Python
But pseudocode, therefore, because it's not Python

479
00:22:48,070 --> 00:22:51,130
不一定是英语，只是允许
and it's not necessarily English, it just kind of allows

480
00:22:51,130 --> 00:22:53,520
你甚至要提前概述你的计划。
you to outline your program even in advance.

481
00:22:53,520 --> 00:22:56,532
举个例子，如果我今天不确定
So for instance, if I wasn't sure today how

482
00:22:56,532 --> 00:22:58,240
我想写这个程序
I wanted to go about writing this program

483
00:22:58,240 --> 00:23:01,720
但我不知道我想做什么，我可以今天就开始
but I didn't know what I wanted to do, I could have started today

484
00:23:01,720 --> 00:23:04,570
用 Hello.py 写下来。
by just writing this in Hello.py.

485
00:23:04,570 --> 00:23:07,870
没有代码，我可以只给自己写几条注释——
No code, I could have written just a couple of comments to myself--

486
00:23:07,870 --> 00:23:09,460
步骤1，询问用户的名称。
Step 1, ask user for their name.

487
00:23:09,460 --> 00:23:11,440
步骤2，向用户说 Hello。
Step 2, say Hello to user.

488
00:23:11,440 --> 00:23:15,520
一旦我用伪代码概述了我的程序，我就可以进去了
Then once I've outlined my program in pseudocode, then I can go in there

489
00:23:15,520 --> 00:23:18,190
然后说，好吧，我怎么问用户他们的名字？
and say, all right, how do I ask the user for their name?

490
00:23:18,190 --> 00:23:21,910
我可以输入“你叫什么名字”的问题？
Well, I can do input "what's your name" question?

491
00:23:21,910 --> 00:23:26,080
然后在左边这里，我可以放一个变量并赋值给它。
And then on the left here, I can maybe put a variable and assign it to that.

492
00:23:26,080 --> 00:23:27,730
好的，我如何对用户说 Hello？
OK, how do I say Hello to the user?

493
00:23:27,730 --> 00:23:30,280
我知道我可以用印刷品在屏幕上说话。
Well, I know I can use print to say things on the screen.

494
00:23:30,280 --> 00:23:32,920
让我打个招呼，让我..
Let me say hello, and let me--

495
00:23:32,920 --> 00:23:35,210
好的，现在打印这个人的名字。
OK, let me now print the person's name.

496
00:23:35,210 --> 00:23:38,960
因此，伪代码是构造待办事项列表的一种很好的方法,
So again, pseudocode is a nice way of structuring your to-do list,

497
00:23:38,960 --> 00:23:41,680
特别是如果你不知道如何编写代码,
especially if you have no idea how to write the code,

498
00:23:41,680 --> 00:23:45,993
因为它把一个更大的程序分解成小的任务。
because it breaks a bigger program down into small bite-sized tasks.

499
00:23:45,993 --> 00:23:48,160
好吧，让我暂停一下，看看现在有没有
All right, let me pause here to see if there are now

500
00:23:48,160 --> 00:23:56,390
关于注释、伪代码、返回值或变量的任何问题。
any questions on comments, pseudocode, return values, or variables.

501
00:23:56,390 --> 00:23:59,170
有什么问题要问清楚吗？
Any questions we can clear up here?

502
00:23:59,170 --> 00:24:02,500
观众: 是的，我的问题是函数输入
AUDIENCE: Yeah, my question is does the function input

503
00:24:02,500 --> 00:24:06,843
为任何类型的信息工作，还是只为文字？
work for any type of information, or only for words?

504
00:24:06,843 --> 00:24:08,510
大卫. 马兰: 是的，真是个好问题。
DAVID MALAN: Yeah, really good question.

505
00:24:08,510 --> 00:24:12,070
因此，根据它的文档，我们将看到更多的正式文档
So according to its documentation, and we'll look more at formal documentation

506
00:24:12,070 --> 00:24:14,290
很快，输入将期待所谓的
soon, input is going to expect what's called

507
00:24:14,290 --> 00:24:16,900
一个字符串，即一个文本序列
a string, that is a sequence of text, be it

508
00:24:16,900 --> 00:24:19,030
用英语或任何其他人类语言。
in English or any other human language.

509
00:24:19,030 --> 00:24:23,660
但是它确实需要用文本来提示用户。
But it's indeed going to be expecting text with which to prompt the user.

510
00:24:23,660 --> 00:24:24,340
问得好。
A good question.

511
00:24:24,340 --> 00:24:26,632
如果可以的话，大家再问一个问题怎么样？
How about another question from the group, if we could?

512
00:24:26,632 --> 00:24:30,520
观众: 我想知道我该如何做几行评论？
AUDIENCE: I wanted to ask how would I make a several line comment?

513
00:24:30,520 --> 00:24:32,770
大卫. 马兰: 哦，你是怎么写很多评论的,
DAVID MALAN: Oh, how do you do many lines of comments,

514
00:24:32,770 --> 00:24:34,000
我没听错吧？
if I'm hearing you correctly?

515
00:24:34,000 --> 00:24:34,330
观众: 是的。
AUDIENCE: Yes.

516
00:24:34,330 --> 00:24:35,290
当然。
DAVID MALAN: Sure.

517
00:24:35,290 --> 00:24:38,380
你会一直这样下去。
You would just keep doing them like this.

518
00:24:38,380 --> 00:24:43,300
你只需要在每一行前面加上一个散列符号，就像我在这里做的一样。
You just prefix each of the lines with a hash symbol, like I'm doing here.

519
00:24:43,300 --> 00:24:46,990
在 Python 中还有另一种用于执行多行注释的技术
There is another technique for doing multi-line comments in Python that

520
00:24:46,990 --> 00:24:48,670
实际上往往有特殊的意义。
actually tend to have special meaning.

521
00:24:48,670 --> 00:24:53,650
你可以像这样做三个双引号，然后在这里之间的任何东西
You can do three double quotes like this and then anything in between here

522
00:24:53,650 --> 00:24:54,910
是一个评论。
is a comment.

523
00:24:54,910 --> 00:24:55,960
这是另一种技巧。
That's another technique.

524
00:24:55,960 --> 00:24:57,502
或者你也可以使用单引号。
Or you can use single quotes as well.

525
00:24:57,502 --> 00:25:00,257
下次再说吧。
But more on those, I think, another time.

526
00:25:00,257 --> 00:25:02,590
好吧，如果你不介意的话，我先走了
All right, well, you don't mind, let me forge ahead here

527
00:25:02,590 --> 00:25:05,290
看看我们如何进一步改进这个项目
and see how we might improve this program further

528
00:25:05,290 --> 00:25:07,570
同时也介绍了一些其他的特性
and also introduce a few other features that we might

529
00:25:07,570 --> 00:25:10,100
要考虑到随着时间的推移。
want to take into account over time.

530
00:25:10,100 --> 00:25:13,270
所以我们可以改进这个程序
So it turns out that we can certainly improve on this program

531
00:25:13,270 --> 00:25:17,020
因为我要抄近路有点失望
because it's a little disappointing that I'm cutting this corner

532
00:25:17,020 --> 00:25:20,680
然后说 Hello 逗号，然后在新行上打印出名称。
and saying Hello comma and then on a new line printing out name.

533
00:25:20,680 --> 00:25:21,700
好像我们能做得更好似的。
Like we can do better.

534
00:25:21,700 --> 00:25:24,760
当然，你在手机或笔记本电脑上使用的大多数程序也是如此
And most programs you use on your phone or your laptop certainly

535
00:25:24,760 --> 00:25:26,810
当人们需要的时候保持短信在一起。
keep text together when people want.

536
00:25:26,810 --> 00:25:28,243
那我们该怎么做呢？
So how can we go about doing that?

537
00:25:28,243 --> 00:25:29,660
有几种不同的方法。
Well there's a few different ways.

538
00:25:29,660 --> 00:25:32,890
事实上，我们的目标并不是解决这个问题,
And in fact, the goal here is not so much to solve this one problem,

539
00:25:32,890 --> 00:25:35,290
而是在编程中证明和强调这一点
but to demonstrate and emphasize that in programming--

540
00:25:35,290 --> 00:25:38,080
Python 和其他语言，有很多方法
Python and other languages-- there's so many ways

541
00:25:38,080 --> 00:25:40,690
有时是为了解决同一个问题。
sometimes to solve the same problem.

542
00:25:40,690 --> 00:25:42,830
这里有一个解决这个问题的方法。
And here's one way to solve this problem.

543
00:25:42,830 --> 00:25:48,100
让我进去打个招呼,
Let me go in here and let me go ahead now and say hello,

544
00:25:48,100 --> 00:25:52,450
让我把用户名添加到末尾。
and let me just add to the end of that the user's name.

545
00:25:52,450 --> 00:25:54,980
所以我以一种有趣的方式使用 + 。
So I'm using + in kind of an interesting way.

546
00:25:54,980 --> 00:25:56,560
这本身不是加法。
This is not addition, per se.

547
00:25:56,560 --> 00:25:59,290
我当然不会加数字，但我会
I'm not adding numbers, obviously, but I do

548
00:25:59,290 --> 00:26:04,840
想要将人名添加到文本 Hello 逗号的字符串中。
kind of want to add the person's name to the string of text Hello comma.

549
00:26:04,840 --> 00:26:08,830
现在让我下到我的终端窗口，运行 Python of Hello.py
Well let me go now down to my terminal window and run Python of Hello.py

550
00:26:08,830 --> 00:26:10,000
再一次，回车。
again, Enter.

551
00:26:10,000 --> 00:26:10,750
你叫什么名字？
What's your name?

552
00:26:10,750 --> 00:26:11,920
我要输入大卫。
I'm going to type in David.

553
00:26:11,920 --> 00:26:12,940
进来。
Enter.

554
00:26:12,940 --> 00:26:14,260
好了，好多了。
OK, it's better.

555
00:26:14,260 --> 00:26:18,160
好多了，但有个小问题，虽然很美观。
It's better, but there's a minor bug, albeit aesthetic here.

556
00:26:18,160 --> 00:26:20,830
这里缺少空间，但我们还是用直觉吧。
There's missing space, but let's just use some intuition here.

557
00:26:20,830 --> 00:26:22,900
如果我漏掉了逗号后面的空格,
Well, if I'm missing the space after the comma,

558
00:26:22,900 --> 00:26:25,780
我为什么不直接手动添加到这里呢。
why don't I go ahead and just add it manually here.

559
00:26:25,780 --> 00:26:30,670
现在让我重新运行 Hello.py、 Enter、 David、 Enter 的 Python 程序。
Let me now rerun the program Python of Hello.py, Enter, David, Enter.

560
00:26:30,670 --> 00:26:31,540
好了。
And there we go.

561
00:26:31,540 --> 00:26:33,400
现在我们有了更漂亮的东西
Now we have something that looks a little prettier

562
00:26:33,400 --> 00:26:34,570
在英语语法方面。
in terms of English grammar.

563
00:26:34,570 --> 00:26:36,640
你好，逗号，空格，大卫。
Hello, comma, space, David.

564
00:26:36,640 --> 00:26:40,060
现在如果我们倒回去，你可能已经注意到了
And now if we rewind, you might have noticed before

565
00:26:40,060 --> 00:26:45,100
或者想知道为什么在我的问号后面有这么多空间,
or wondered why I had this seemingly extra space after my question mark,

566
00:26:45,100 --> 00:26:45,940
也就是这里。
namely here.

567
00:26:45,940 --> 00:26:48,790
在问号之后，双引号之前有个空格
There's a space after the question mark but before the double quote

568
00:26:48,790 --> 00:26:50,332
这也只是为了美学。
and that was just for aesthetics too.

569
00:26:50,332 --> 00:26:53,315
我希望将用户的光标向右移动一个空格
I wanted to move the user's cursor one space to the right

570
00:26:53,315 --> 00:26:55,690
所以当我输入他们的名字或者他们输入他们的名字时,
so that when I typed their name or they typed their name,

571
00:26:55,690 --> 00:26:59,650
并不是紧挨着那个问号。
it's not immediately next to that same question mark there.

572
00:26:59,650 --> 00:27:01,790
但我们还有别的办法。
But there's other ways we can do this.

573
00:27:01,790 --> 00:27:05,080
有些函数，在它们之间打印,
It turns out that some functions, print among them,

574
00:27:05,080 --> 00:27:07,570
实际上采取多个论点。
actually take multiple arguments.

575
00:27:07,570 --> 00:27:11,200
结果表明，如果你把输入分开
And it turns out that if you separate the inputs

576
00:27:11,200 --> 00:27:14,620
函数的所谓参数用逗号表示,
to a function-- the so-called arguments to a function-- with a comma,

577
00:27:14,620 --> 00:27:19,250
你不仅可以进去一个，还可以进去两个，三个，四个，五个。
you can pass in not just one, but two, three, four, five, onward.

578
00:27:19,250 --> 00:27:24,970
所以让我继续传入，不仅仅是 hello，逗号，space，还有接下来的
So let me go ahead and pass in not just hello, comma, space, but that followed

579
00:27:24,970 --> 00:27:25,660
名字。
by name.

580
00:27:25,660 --> 00:27:27,880
乍一看，这有点让人困惑
And this is a little confusing potentially at first glance

581
00:27:27,880 --> 00:27:30,297
因为现在我有两个逗号，但是要注意
because now I've got two commas but it's important to note

582
00:27:30,297 --> 00:27:35,800
第一个逗号在我的引号里面，这很简单
that the first comma is inside of my quotation marks, which is simply

583
00:27:35,800 --> 00:27:37,490
英语语法的东西。
an English grammatical thing.

584
00:27:37,490 --> 00:27:40,270
这里的第二个逗号在引号之外,
The second comma here is outside of the quotes,

585
00:27:40,270 --> 00:27:44,170
而是在现在两个要打印的独立参数之间。
but between what are now two separate arguments to print.

586
00:27:44,170 --> 00:27:46,270
第一个参数是 hello，逗号，space。
The first argument is hello, comma, space.

587
00:27:46,270 --> 00:27:49,490
第二个参数是 name 变量本身。
The second argument is the name variable itself.

588
00:27:49,490 --> 00:27:51,640
我们来看看效果如何。
So let's see how this looks.

589
00:27:51,640 --> 00:27:53,620
Python of Hello.py，Enter.
Python of Hello.py, Enter.

590
00:27:53,620 --> 00:27:54,460
你叫什么名字？
What's your name?

591
00:27:54,460 --> 00:27:55,060
大卫。
David.

592
00:27:55,060 --> 00:27:56,050
进来。
Enter.

593
00:27:56,050 --> 00:27:57,910
好吧，我有点矫枉过正了。
OK, I've kind of over-corrected.

594
00:27:57,910 --> 00:28:00,040
出于某种原因，我现在有两个空格。
Now I've got two spaces for some reason.

595
00:28:00,040 --> 00:28:02,080
事实证明，这很微妙
Well, it turns out, and this is subtle, when

596
00:28:02,080 --> 00:28:07,960
传递多个要打印的参数时，它会自动为您插入一个空格。
you pass multiple arguments to print, it automatically inserts a space for you.

597
00:28:07,960 --> 00:28:10,270
之前没有关系，因为我有
This was not relevant earlier because I was

598
00:28:10,270 --> 00:28:16,510
传入一个大参数，通过使用 + 运算符一次打印所有参数。
passing in one big argument to print all at once by using that + operator.

599
00:28:16,510 --> 00:28:19,070
因为逗号的缘故，这次我用了两个。
This time I'm passing in two because of the comma.

600
00:28:19,070 --> 00:28:23,210
所以如果我不想要额外的空间，我也不需要自己通过,
So if I don't want that extra space, I don't need to pass in one myself,

601
00:28:23,210 --> 00:28:26,530
我可以这样做，现在注意，如果我再次运行这个程序——
I can just do this and now notice, if I run this program again--

602
00:28:26,530 --> 00:28:29,560
Python of Hello.py 输入我的名字 David,
Python of Hello.py, type in my name David,

603
00:28:29,560 --> 00:28:32,620
现在语法上看起来像是我想要的。
now it looks grammatically like I might want.

604
00:28:32,620 --> 00:28:34,330
那么，这些方法中哪一种更好呢？
Now which of these approaches is better?

605
00:28:34,330 --> 00:28:37,840
这种方法使用带有两个参数的函数 print ——
This approach uses a function print with two arguments--

606
00:28:37,840 --> 00:28:40,810
你好，逗号和 name 变量。
Hello, comma and the name variable.

607
00:28:40,810 --> 00:28:44,195
前一个版本，回忆，技术上使用了一个参数,
The previous version, recall, technically used one argument,

608
00:28:44,195 --> 00:28:45,820
虽然看起来有点奇怪。
even though it looked a little curious.

609
00:28:45,820 --> 00:28:49,270
从某种意义上说，计算机就像数学家一样,
It's one argument in the sense that the computer, just like mathematicians,

610
00:28:49,270 --> 00:28:51,950
首先要做括号里面的事。
are going to do what's inside of parentheses first.

611
00:28:51,950 --> 00:28:54,670
所以如果在括号内有一串文本
So if inside of parentheses you have this string of text--

612
00:28:54,670 --> 00:28:58,350
你好，逗号，还有一个空格，我要把它加回去。
hello, comma, and a space, which I need to add back.

613
00:28:58,350 --> 00:29:01,050
然后你有一个 + ，这意味着本质上不是加法,
Then you have a +, which means not addition, per se,

614
00:29:01,050 --> 00:29:05,400
而是连接——连接左边的东西和右边的东西。
but concatenation-- to join the thing on the left and the thing on the right.

615
00:29:05,400 --> 00:29:08,400
这最终变成了英语短语——
This ultimately becomes the English phrase--

616
00:29:08,400 --> 00:29:10,890
你好，逗号，空格，大卫。
Hello, comma, space, David.

617
00:29:10,890 --> 00:29:14,400
然后最终传递给函数的
And then what's being passed ultimately to the function

618
00:29:14,400 --> 00:29:18,870
技术上是这样的，但它是动态的。
is technically something like this, but it's doing it all dynamically.

619
00:29:18,870 --> 00:29:23,860
不是我像之前那样小心翼翼地输入 David。
It's not me typing in David as I discreetly did earlier.

620
00:29:23,860 --> 00:29:27,930
它将在连接 Hello 之后动态地计算出该值是什么
It's figuring out dynamically what that value is after concatenating Hello

621
00:29:27,930 --> 00:29:30,900
然后最终传递它
with the value of name and then passing that ultimately

622
00:29:30,900 --> 00:29:33,750
作为唯一参数打印。
to print as the sole argument.

623
00:29:33,750 --> 00:29:38,130
让我暂停一下，看看有没有关于参数数量的问题
Let me pause here to see if there's any questions on numbers of arguments

624
00:29:38,130 --> 00:29:41,250
现在开始工作。
now to functions.

625
00:29:41,250 --> 00:29:43,950
观众: 我们可以多次使用一个函数吗
AUDIENCE: Can we use a function many times

626
00:29:43,950 --> 00:29:48,765
解决一个我们在代码中可能会遇到很多次的问题？
to solve a certain problem which we can encounter many times in our code?

627
00:29:48,765 --> 00:29:49,640
你可以的。
DAVID MALAN: You can.

628
00:29:49,640 --> 00:29:52,700
你可以多次使用一个函数来解决一些问题。
You can use a function many different times to solve some problem.

629
00:29:52,700 --> 00:29:55,040
不过，我们很快就会看到，如果你发现自己
What we'll soon see, though, is if you find yourself

630
00:29:55,040 --> 00:29:58,620
作为程序员再次用同样的方法解决问题,
as the programmer solving a problem the same way again,

631
00:29:58,620 --> 00:30:00,560
一次又一次，事实证明
and again, and again, it turns out you'll

632
00:30:00,560 --> 00:30:02,450
能够使你自己的功能，使你
be able to make your own function so that you

633
00:30:02,450 --> 00:30:07,130
不必重复使用随语言而来的基本内容。
don't have to keep reusing the basic ones that come with the language.

634
00:30:07,130 --> 00:30:10,890
观众: 我对逗号和 + 号很好奇。
AUDIENCE: I was curious about the comma and the + sign.

635
00:30:10,890 --> 00:30:15,320
在 + 符号之后，我们可以给出一个变量，在逗号之后
So after + sign, can we give just one variable and after comma again we

636
00:30:15,320 --> 00:30:17,180
给多变量状态？
give multiple variable status?

637
00:30:17,180 --> 00:30:18,470
有什么区别吗？
What is the difference?

638
00:30:18,470 --> 00:30:19,678
问得好。
DAVID MALAN: A good question.

639
00:30:19,678 --> 00:30:21,320
所以在字符串的上下文中
So in the context of strings--

640
00:30:21,320 --> 00:30:22,640
我一直在用这个词。
and I keep using that term.

641
00:30:22,640 --> 00:30:25,130
“字符串”是编程语言中的一个技术术语
"String" is a technical term in a programming language

642
00:30:25,130 --> 00:30:29,570
同样，它意味着一个文本序列——一个字符，一个词，整个段落,
and again, it means a sequence of text-- a character, a word, a whole paragraph,

643
00:30:29,570 --> 00:30:30,080
甚至。
even.

644
00:30:30,080 --> 00:30:33,650
所以 + 运算符不仅仅是被使用，就像我们将要
So the + operator is not just used, as we'll

645
00:30:33,650 --> 00:30:37,790
看，在 Python 中加入数字，就像我们在纸笔上做的那样,
see, for addition of numbers in Python, like we do on paper pencil,

646
00:30:37,790 --> 00:30:41,760
但它也用于串联字符串的左侧和右侧。
but it also is used for concatenation of strings on the left and the right.

647
00:30:41,760 --> 00:30:44,180
如果您确实想要组合不仅仅是两个字符串——
If you did want to combine not just two strings--

648
00:30:44,180 --> 00:30:46,310
左边和右边，但是第三个和第四个,
left and right-- but a third and a fourth,

649
00:30:46,310 --> 00:30:51,380
你完全可以继续使用 + ，+ ，+ ，然后把它们链接在一起
you can absolutely keep using +, +, +, +, and chain them together

650
00:30:51,380 --> 00:30:52,460
就像数学一样。
just like in math.

651
00:30:52,460 --> 00:30:54,830
最终会变得有点丑陋,
Eventually that's going to start to look a little ugly,

652
00:30:54,830 --> 00:30:57,080
我敢说，特别是你的代码行太长的时候。
I dare say, especially if your line of code gets long.

653
00:30:57,080 --> 00:31:00,200
所以我们很快就会看到更好的方法。
So there's better ways that we'll actually soon see.

654
00:31:00,200 --> 00:31:01,670
也是个好问题。
And a good question as well.

655
00:31:01,670 --> 00:31:04,190
让我们回到这里讨论的代码
Well let me come back to the code here in question

656
00:31:04,190 --> 00:31:06,800
看看我们能不能给你展示一些其他的方法
and see if we can show you just a couple of other ways

657
00:31:06,800 --> 00:31:10,520
解决同样的问题，同时强调我们在技术上
to solve the same problem, along the way emphasizing that what we're technically

658
00:31:10,520 --> 00:31:12,980
在这里说，是的，有弦，但是有偶数
talking about here, yes, are strings, but there's even

659
00:31:12,980 --> 00:31:15,170
在 Python 中这些字符串的技术术语,
a technical term for these strings in Python,

660
00:31:15,170 --> 00:31:19,700
它只是 STR，可以这么说，简称为 S-T-R，字符串的缩写。
it's just STR, so to speak, S-T-R for short, for string.

661
00:31:19,700 --> 00:31:22,220
你可能知道如果你用其他语言编程,
As you may know if you programmed in other languages,

662
00:31:22,220 --> 00:31:26,270
发明编程语言的人喜欢简洁明了,
people who invent programming languages like to be very succinct, to the point,

663
00:31:26,270 --> 00:31:29,780
所以我们倾向于用相当短的词组来描述事物,
so we tend to use fairly short phrases to describe things,

664
00:31:29,780 --> 00:31:31,370
不一定是完整的词。
not necessarily full words.

665
00:31:31,370 --> 00:31:33,920
虽然你可能会说“字符串”，技术上来说
So while you might say "string," technically

666
00:31:33,920 --> 00:31:37,070
在 Python 中我们真正讨论的是这些文本序列,
in Python what we're really talking about, these sequences of text,

667
00:31:37,070 --> 00:31:38,300
严格来说是 STR。
are technically STRs.

668
00:31:38,300 --> 00:31:41,450
这是程序中实际的数据类型。
This is an actual type of data in a program.

669
00:31:41,450 --> 00:31:45,420
但是我们很快就会看到程序中还有其他类型的数据。
But we'll soon see that there's other types of data in programs as well.

670
00:31:45,420 --> 00:31:48,980
事实上，让我们看看我们是否可以用另一种方法来改进它。
In fact, let's see if we can't improve this in one other way.

671
00:31:48,980 --> 00:31:52,550
我喜欢我们在保持一致方面所取得的进展
I like the progress we've made by keeping everything on the same line--

672
00:31:52,550 --> 00:31:55,490
你好，大卫都在同一条线上。
Hello, David all on the same line.

673
00:31:55,490 --> 00:31:59,070
在解决这个问题方面，我们还能做些什么呢？
What more though could we do in terms of solving this problem?

674
00:31:59,070 --> 00:32:02,420
事实证明我们没必要完全放弃
Well, it turns out that we didn't have to give up entirely

675
00:32:02,420 --> 00:32:03,800
使用打印两次。
with using print twice.

676
00:32:03,800 --> 00:32:07,460
让我倒带一下，回到之前的版本
Let me rewind a little bit and go back to that earlier version

677
00:32:07,460 --> 00:32:11,660
我不确定如何解决这个问题所以我只用了一次 print
where I wasn't really sure how to solve this problem so I was using print once

678
00:32:11,660 --> 00:32:14,090
打印出 Hello，空格和逗号。
to print out just the Hello and the space and the comma.

679
00:32:14,090 --> 00:32:17,750
然后我又用 print 来打印名字。
And then I used print again to print name.

680
00:32:17,750 --> 00:32:22,220
严格来说，这还不错，但是有一个视觉副作用
That's, strictly speaking, wasn't bad, but there was this visual side effect

681
00:32:22,220 --> 00:32:23,270
我不喜欢的。
that I didn't like.

682
00:32:23,270 --> 00:32:26,540
把这两行文字分开看起来很难看
It just looked ugly to have these two lines of text separate

683
00:32:26,540 --> 00:32:27,600
彼此之间的联系。
from one another.

684
00:32:27,600 --> 00:32:29,480
但还有别的办法解决这个问题。
But there's another way to fix this.

685
00:32:29,480 --> 00:32:34,130
显然，打印函数似乎是自动的
Clearly it seems to be the case that the print function is automatically

686
00:32:34,130 --> 00:32:36,110
输出一行空白。
outputting a blank line.

687
00:32:36,110 --> 00:32:39,380
它会自动将光标移动到下一行
It's moving the cursor automatically for me to the next line

688
00:32:39,380 --> 00:32:42,620
因为这就是为什么我在一条线上看到 Hello 和 David
because that's why I'm seeing Hello on one line and David

689
00:32:42,620 --> 00:32:44,150
然后我的提示
on the next and then my prompt--

690
00:32:44,150 --> 00:32:46,530
美元符号，在那下面的线上。
the dollar sign-- on the line below that.

691
00:32:46,530 --> 00:32:48,800
所以印刷似乎是自动推测出来的
So print seems to be presuming automatically

692
00:32:48,800 --> 00:32:51,230
您希望它将光标移动到下一行
that you want it to move the cursor to the next line

693
00:32:51,230 --> 00:32:53,040
在你通过一些论点之后。
after you pass it some argument.

694
00:32:53,040 --> 00:32:54,890
但你可以改变这种行为。
But you can override that behavior.

695
00:32:54,890 --> 00:32:58,400
同样，函数采用影响其行为的参数,
Again, functions take arguments which influence their behavior,

696
00:32:58,400 --> 00:33:00,740
你只需要知道那些论点是什么。
you just have to know what those arguments are.

697
00:33:00,740 --> 00:33:06,560
结果是，如果我们查看 Python 打印的文档
And it turns out that if we look at the documentation for Python's print

698
00:33:06,560 --> 00:33:09,980
函数，我们可以在这里查看这个 URL
function, we can actually look up at this URL here--

699
00:33:09,980 --> 00:33:14,150
Python.org 是所有 Python 官方文档的所在地。
docs.python.org is where all of Python's official documentation lies.

700
00:33:14,150 --> 00:33:17,870
如果我四处查看，我可以找到我的方式，更具体地说，这个网址
If I poke around, I can find my way to more specifically this URL

701
00:33:17,870 --> 00:33:22,970
在这里我可以找到 Python 中所有可用的函数
here where I can find all of the available functions in Python

702
00:33:22,970 --> 00:33:24,630
以及那里的文件。
and the documentation there for.

703
00:33:24,630 --> 00:33:26,900
如果我再精确一点，我甚至可以
And if I go a little more precisely, I can even

704
00:33:26,900 --> 00:33:30,230
查找打印功能本身的具体文档。
find specific documentation for the print function itself.

705
00:33:30,230 --> 00:33:31,980
与其在浏览器里查看,
And rather than pull that up in a browser,

706
00:33:31,980 --> 00:33:36,050
接下来我要突出显示同一个 URL 中的一行
I'm going to go ahead and highlight just one line from that same URL, which

707
00:33:36,050 --> 00:33:39,890
这是我们见过的最神秘的东西,
is this, and this is easily the most cryptic thing we've seen yet,

708
00:33:39,890 --> 00:33:42,717
但这是打印功能的官方文件。
but this is the official documentation for the print function.

709
00:33:42,717 --> 00:33:45,800
这是学习编程语言时能做的最好的事情之一
And one of the best things you can do when learning a programming language

710
00:33:45,800 --> 00:33:48,110
老实说，学会阅读文档,
is, honestly, learn to read the documentation,

711
00:33:48,110 --> 00:33:51,920
因为事实上，你所有问题的答案都会以某种方式
because truly, all of the answers to your questions will in some way

712
00:33:51,920 --> 00:33:55,430
即使，不可否认，这并不总是显而易见的。
be there, even though, admittedly, it's not always obvious.

713
00:33:55,430 --> 00:33:57,290
我还要说，巨蟒的文档
And I will say too, Python's documentation

714
00:33:57,290 --> 00:34:01,460
不一定是最简单的事情，尤其是对于初学者或新手
isn't necessarily the easiest thing, especially for a first time or novice

715
00:34:01,460 --> 00:34:02,072
程序员。
programmer.

716
00:34:02,072 --> 00:34:05,030
这也只是需要练习，所以如果你不是，尽量不要感到不知所措
It too just takes practice, so try not to get overwhelmed if you're not

717
00:34:05,030 --> 00:34:06,292
确定你在看什么。
sure what you're looking at.

718
00:34:06,292 --> 00:34:08,000
让我来给你们讲一下这个例子。
But let me walk you through this example.

719
00:34:08,000 --> 00:34:11,360
这也是 Python 官方文档中的一行文本
This again is a line of text from Python's official documentation

720
00:34:11,360 --> 00:34:12,690
打印功能。
for the print function.

721
00:34:12,690 --> 00:34:14,659
这表示的是这样的——
What this indicates as follows is this--

722
00:34:14,659 --> 00:34:17,000
这个函数的名称当然是 print。
the name of this function is, of course print.

723
00:34:17,000 --> 00:34:20,570
这里有一个括号，另一个紧密的括号
Then there's a parenthesis over here and another close parenthesis way

724
00:34:20,570 --> 00:34:21,230
在那边。
over there.

725
00:34:21,230 --> 00:34:23,570
括号里的所有东西都是
Everything inside of those parentheses are

726
00:34:23,570 --> 00:34:27,270
函数的参数，潜在参数。
the arguments, the potential arguments, to the function.

727
00:34:27,270 --> 00:34:30,830
但是，当我们看到这些论点的时候
However, when we're looking at these arguments

728
00:34:30,830 --> 00:34:34,400
在这样的文档中，技术上有一个不同的术语
in the documentation like this, there's technically a different term

729
00:34:34,400 --> 00:34:35,150
我们会用到的。
that we would use.

730
00:34:35,150 --> 00:34:37,920
从技术上讲，这些是函数的参数。
These are technically the parameters to the function.

731
00:34:37,920 --> 00:34:41,900
所以当你讨论可以传递给函数的内容时
So when you're talking about what you can pass to a function

732
00:34:41,900 --> 00:34:45,679
这些输入被称为参数。
and what those inputs are called, those are parameters.

733
00:34:45,679 --> 00:34:48,080
当您实际使用函数并传递
When you actually use the function and pass

734
00:34:48,080 --> 00:34:51,650
在这些括号里的值，这些输入,
in values inside of those parentheses, those inputs,

735
00:34:51,650 --> 00:34:53,580
这些值都是参数。
those values are arguments.

736
00:34:53,580 --> 00:34:56,719
所以我们讨论的是完全一样的东西——参数和参数
So we're talking about the exact same thing-- parameters and arguments are

737
00:34:56,719 --> 00:34:58,850
实际上是一样的，但是你的条件
effectively the same thing, but the terms you

738
00:34:58,850 --> 00:35:01,520
从不同的角度看问题。
use from looking at the problem from different directions.

739
00:35:01,520 --> 00:35:04,220
当我们考虑函数能带走什么和什么的时候
When we're looking at what the function can take versus what

740
00:35:04,220 --> 00:35:06,210
你实际上是在传递函数。
you're actually passing into the function.

741
00:35:06,210 --> 00:35:07,500
那么这意味着什么呢？
So what does this imply?

742
00:35:07,500 --> 00:35:10,610
这个语法很神秘，但是现在,
Well this syntax is pretty cryptic, but at the moment,

743
00:35:10,610 --> 00:35:14,360
只要知道一个星号，一颗星星，然后“物体”这个词
just know that an asterisk, a star, and then the word "objects"

744
00:35:14,360 --> 00:35:17,330
意味着打印函数可以接受任意数量的对象。
means that the print function can take any number of objects.

745
00:35:17,330 --> 00:35:20,540
您可以传入0个字符串的文本，一个字符串
You can pass in 0 strings of text, one string

746
00:35:20,540 --> 00:35:23,900
像我一样，两根弦像我一样，或者，技术上来说，无限多
like I did, two strings like I did, or, technically, infinitely many

747
00:35:23,900 --> 00:35:27,170
如果你真的想，虽然这个代码看起来不会很好。
if you really want, though that code is not going to look very good.

748
00:35:27,170 --> 00:35:31,130
之后我们看到一个逗号，然后我们看到另一个参数在这里
After that we see a comma, then we see another parameter here

749
00:35:31,130 --> 00:35:34,400
称为「学校资讯科技教育自评系统」(SEP)。
called SEP, short for separator in English.

750
00:35:34,400 --> 00:35:38,640
注意等号和单引号，空格，单引号。
And notice the equal sign and the single quote, space, single quote.

751
00:35:38,640 --> 00:35:42,350
所以“太空”我还不知道那是什么,
So 'space' I don't know what that is yet,

752
00:35:42,350 --> 00:35:44,570
但我想我们已经看到了暗示。
but I think we've seen a hint about it.

753
00:35:44,570 --> 00:35:46,430
让我们把注意力集中在这上面
Let's focus though for a moment on this--

754
00:35:46,430 --> 00:35:50,720
Print 函数接受另一个参数 end 和 default
the print function takes another parameter called end and the default

755
00:35:50,720 --> 00:35:54,560
这个参数的值显然是基于这个等号和这些
value of that parameter is apparently, based on this equal sign and these

756
00:35:54,560 --> 00:35:57,020
引用,/n。
quotes, /n.

757
00:35:57,020 --> 00:36:00,260
什么是/n，如果你想在聊天中插话？
And what is /n, if you'd like to chime in in the chat?

758
00:36:00,260 --> 00:36:02,810
任何有经验的程序员都可能见过这个,
Anyone who's program before has probably seen this,

759
00:36:02,810 --> 00:36:07,070
不过如果你以前没有编过程序，这看起来可能很神秘。
though if you've never programmed before, this might look quite cryptic.

760
00:36:07,070 --> 00:36:12,530
反斜杠 n 表示新行，这是一种文本方式
Backslash n means new line, and it's a way textually

761
00:36:12,530 --> 00:36:15,710
指示是否以及何时需要有效地使用计算机
of indicating if and when you want the computer effectively

762
00:36:15,710 --> 00:36:19,490
若要将光标移动到下一行，请创建一行新的文本。
to move the cursor to the next line, create a new line of text.

763
00:36:19,490 --> 00:36:22,310
所以严格来说，如果我们仔细阅读文档,
And so technically, if we read into the documentation,

764
00:36:22,310 --> 00:36:23,960
我们会看到更多细节。
we'll see more detail on this.

765
00:36:23,960 --> 00:36:28,550
在打印文档中有一个名为 end 的参数
The fact that there's a parameter called end in the documentation for the print

766
00:36:28,550 --> 00:36:32,840
函数，这意味着默认情况下，这个打印函数将结束
function, just means that by default this print function is going to end

767
00:36:32,840 --> 00:36:35,240
以/n 开头的每一行。
every line with /n.

768
00:36:35,240 --> 00:36:37,670
你看到的不是字面意义上的/n，而是一条新线。
You don't literally see /n, you see a new line.

769
00:36:37,670 --> 00:36:40,320
可以看到光标移动到下一行。
You see the cursor moving to the next line.

770
00:36:40,320 --> 00:36:42,500
按照这个逻辑，我们倒退一下。
Now by that logic, let's move backwards.

771
00:36:42,500 --> 00:36:46,790
SEP 四个分隔符——分隔符的默认值
SEP four separator-- the default value of separator

772
00:36:46,790 --> 00:36:49,460
显然是一个单一的空白空间。
is apparently a single blank space.

773
00:36:49,460 --> 00:36:51,020
我们在哪儿见过？
Well where have we seen that?

774
00:36:51,020 --> 00:36:55,190
回想一下之前的例子，我传入的不是一个，而是两个
Well recall in an earlier example when I passed in not just one but two

775
00:36:55,190 --> 00:36:57,210
打印函数的参数。
arguments to the print function.

776
00:36:57,210 --> 00:37:00,300
回想一下，他们之间神奇地有一个空间。
Recall that they magically had a space between them.

777
00:37:00,300 --> 00:37:02,540
事实上，他们有那个空间 + 我自己的空间
In fact, they had that space + my own space

778
00:37:02,540 --> 00:37:05,720
这就是为什么我删除了我的空间，因为那时它是额外的。
and that's why I deleted my space because at that point it was extra.

779
00:37:05,720 --> 00:37:09,620
这意味着当你传递多个参数进行打印时，默认情况下
So this just means that when you pass multiple arguments to print, by default

780
00:37:09,620 --> 00:37:11,750
它们将被一个单独的空间隔开。
they're going to be separated by a single space.

781
00:37:11,750 --> 00:37:14,570
默认情况下，当传递要打印的参数时,
By default, when you pass arguments to print,

782
00:37:14,570 --> 00:37:17,880
而是整个事情将以一个新台词结束。
it's the whole thing is going to be ended with a new line.

783
00:37:17,880 --> 00:37:19,850
现在只要知道这一点，让我从字面上
Now just by knowing this, and let me literally

784
00:37:19,850 --> 00:37:22,890
我对剩下的文件挥挥手，改天再说,
wave my hand at the rest of the documentation for another day,

785
00:37:22,890 --> 00:37:24,890
还有更多的东西可以打印，但我们
there's more things that print can do, but we're

786
00:37:24,890 --> 00:37:29,360
只关注 SEP 和 END，让我们看看我们现在是否可以利用这一点
going to focus just on SEP and on END, let's see if we can't leverage this now

787
00:37:29,360 --> 00:37:31,010
来解决最初的问题。
to solve that original problem.

788
00:37:31,010 --> 00:37:34,250
最初的问题是这样的，我不喜欢如何你好，大卫
The original problem was this, I don't like how Hello, David

789
00:37:34,250 --> 00:37:35,750
在两条不同的线上。
is on two different lines.

790
00:37:35,750 --> 00:37:38,420
这种情况又发生了，因为打印是自动的
Well that's happening again because print is automatically

791
00:37:38,420 --> 00:37:41,810
打印出一条新线，所以我们告诉它不要这样做。
printing out a new line, so let's tell it not to do that.

792
00:37:41,810 --> 00:37:47,150
让我们通过将第二个参数传递给第一次使用 PRINT 来说明这一点
Let's tell it by passing a second argument to the first use of PRINT

793
00:37:47,150 --> 00:37:51,110
表示 END = quote，unquote ——
to say END = quote, unquote--

794
00:37:51,110 --> 00:37:54,840
Not/n，这是默认值。
not /n, which is the default automatically.

795
00:37:54,840 --> 00:37:58,250
让我们引用它，引用没有别的。
Let's make it quote, unquote nothing else.

796
00:37:58,250 --> 00:38:01,850
让我们覆盖默认值，这样就没有新行了。
Let's override the default value so there is no new line.

797
00:38:01,850 --> 00:38:03,560
那里什么都没有。
There's literally nothing there.

798
00:38:03,560 --> 00:38:05,250
看看会发生什么。
And let's see what happens.

799
00:38:05,250 --> 00:38:08,270
现在让我下到我的终端窗口，并清除它。
Let me now go down to my terminal window and clear it.

800
00:38:08,270 --> 00:38:10,672
我将运行 Python of Hello.py，Enter。
And I'm going to run Python of Hello.py, Enter.

801
00:38:10,672 --> 00:38:12,380
我要输入我的名字，大卫和我
I'm going to type in my name, David and I

802
00:38:12,380 --> 00:38:16,280
我想现在一切都会保持原样，因为..
think now everything is going to stay on the same line because--

803
00:38:16,280 --> 00:38:22,460
这一行，5，打印出 Hello，逗号，空格,
and it did-- this line here, 5, is going to print out Hello, comma, space,

804
00:38:22,460 --> 00:38:24,710
但最后什么都没发生，因为我
but then nothing at the end of it because I

805
00:38:24,710 --> 00:38:26,450
改成引号，引号。
changed it to be quote, unquote.

806
00:38:26,450 --> 00:38:29,210
第二行是打印名字，大卫,
The second line is going to print the name, David,

807
00:38:29,210 --> 00:38:32,780
或者不管人类的名字是什么，它会把光标移动到下一行
or whatever the human's name is, and it will move the cursor to the next line

808
00:38:32,780 --> 00:38:36,230
因为我没有覆盖 END 的值。
because I didn't override the value of END there.

809
00:38:36,230 --> 00:38:39,710
为了更清楚地看到这一点，如果你做一些神秘的事情，比如,
Just to see this more explicitly, if you do something cryptic like,

810
00:38:39,710 --> 00:38:41,420
我不知道发生了什么。
well I have no idea what's going on.

811
00:38:41,420 --> 00:38:44,120
让我暂时在这里打三个问号。
Let me just put in temporarily three question marks here.

812
00:38:44,120 --> 00:38:46,040
我们也会看到结果的。
We'll see the results of this too.

813
00:38:46,040 --> 00:38:49,202
让我回到我的终端窗口，运行 Python 的 hello. py,
Let me go back down to my terminal window, run Python of hello. py,

814
00:38:49,202 --> 00:38:49,910
你叫什么名字？
what's your name?

815
00:38:49,910 --> 00:38:50,420
大卫。
David.

816
00:38:50,420 --> 00:38:54,207
现在你可以看到非常难看的输出,
And now you see literally really ugly output,

817
00:38:54,207 --> 00:38:55,790
但你可以看到事情的真相。
but you see literally what's going on.

818
00:38:55,790 --> 00:39:01,010
您好，逗号，空格，然后三个问号，END，打印语句,
Hello, comma, space, then three question marks, END, that print statement,

819
00:39:01,010 --> 00:39:05,570
然后你会看到 D-A-V-I-D 所以这不是个好结果,
and then you see D-A-V-I-D. So not a good outcome,

820
00:39:05,570 --> 00:39:09,080
但它也证明了我们在这里有多大的控制力。
but it demonstrates just how much control we have here too.

821
00:39:09,080 --> 00:39:10,490
我再倒回去一点。
And let me rewind further.

822
00:39:10,490 --> 00:39:13,250
回想一下，在我们的另一个版本中,
Recall that in our other version of this,

823
00:39:13,250 --> 00:39:18,710
当我传入 Hello、逗号和 name 时，它们被一个空格隔开。
when I passed in Hello, comma and name, they were separated by a single space.

824
00:39:18,710 --> 00:39:22,340
Python of Hello.py，D-A-V-I-D，Enter.
So Python of Hello.py, D-A-V-I-D, Enter.

825
00:39:22,340 --> 00:39:23,690
成功了。
That just worked.

826
00:39:23,690 --> 00:39:27,950
那么，如果我们覆盖分隔符的 SEP 值呢？
Well what if we override the value of SEP for separator?

827
00:39:27,950 --> 00:39:31,730
我们可以说点什么，而不是一个空间
Instead of being one space, we could say something

828
00:39:31,730 --> 00:39:35,030
就像，问号，问号，问号只是为了包装
like, question mark, question mark, question mark just to wrap

829
00:39:35,030 --> 00:39:37,110
我们对那里发生了什么的想法。
our minds around what's going on there.

830
00:39:37,110 --> 00:39:41,300
现在让我来做 Python of Hello.py，D-A-V-I-D，Enter。
Let me now do Python of Hello.py, D-A-V-I-D, Enter.

831
00:39:41,300 --> 00:39:42,650
你看到两个。
And you see two.

832
00:39:42,650 --> 00:39:43,850
这两个输入
These two inputs--

833
00:39:43,850 --> 00:39:47,840
你好，逗号和名字现在以一种丑陋的方式分开了
Hello, comma and the name are now separated in an ugly way

834
00:39:47,840 --> 00:39:52,580
因为我已经改写了「学校资讯科技教育自评系统」的预设行为。
by three question marks because I've overridden the default behavior of SEP.

835
00:39:52,580 --> 00:39:54,803
即使文档使用单引号,
And even though the documentation uses single quotes,

836
00:39:54,803 --> 00:39:56,720
我有使用双引号的习惯。
I've been in the habit of using double quotes.

837
00:39:56,720 --> 00:39:58,580
在 Python 中，您可以使用。
In Python you can use either.

838
00:39:58,580 --> 00:40:01,620
严格来说，这无关紧要，但你应该坚持
Strictly speaking, it doesn't matter, but you should be consistent

839
00:40:01,620 --> 00:40:03,530
我通常使用双引号。
and I generally always use double quotes.

840
00:40:03,530 --> 00:40:08,240
然而，Python 的文档总是使用单引号。
Python's documentation, though, always uses single quotes.

841
00:40:08,240 --> 00:40:12,320
现在对这些类型的参数有什么问题吗？
Questions now on these types of parameters?

842
00:40:12,320 --> 00:40:15,290
请允许我提议给它们正式命名。
And allow me to propose that we give these an official name.

843
00:40:15,290 --> 00:40:19,220
到目前为止，我们一直在传递要打印的值,
Up until now, when we've been passing values to print,

844
00:40:19,220 --> 00:40:22,160
这些被称为位置参数-在这个意义上的位置
those are called positional parameters-- positional in the sense

845
00:40:22,160 --> 00:40:24,620
你传递给打印机的第一样东西会先打印出来。
that the first thing you pass to print gets printed first.

846
00:40:24,620 --> 00:40:27,830
在第二次打印逗号之后传递给打印的第二个内容。
The second thing you pass to print after a comma gets printed second.

847
00:40:27,830 --> 00:40:28,710
等等。
And so forth.

848
00:40:28,710 --> 00:40:32,210
但是我们现在也看到了一些叫做命名参数的东西。
But there's also these things we've now seen called named parameters.

849
00:40:32,210 --> 00:40:37,550
命名为 SEP，分隔符，或 END，E-N-D，表示行结束。
Named SEP, separator, or END, E-N-D for the line ending.

850
00:40:37,550 --> 00:40:40,910
这些都是命名参数，因为第一，它们是可选的
Those are named parameters because one, they're optional

851
00:40:40,910 --> 00:40:44,450
你可以在打印声明的末尾传递它们,
and you can pass them in at the end of your print statement,

852
00:40:44,450 --> 00:40:48,290
但是你也可以通过名字来使用它们。
but you can also use them by name.

853
00:40:48,290 --> 00:40:51,050
观众: 这可能是一个奇怪的问题，但我想知道,
AUDIENCE: This may be a weird question, but I was wondering,

854
00:40:51,050 --> 00:40:57,350
如果有人想在引号中加上引号怎么办
what if someone wants to add actually quotation marks within the quotation

855
00:40:57,350 --> 00:40:57,920
痕迹？
marks?

856
00:40:57,920 --> 00:40:59,600
大卫. 马兰: 是的，我喜欢你的想法。
DAVID MALAN: Yeah, I like how you think.

857
00:40:59,600 --> 00:41:01,880
这就是我们所说的绝佳案例，对吧？
This is what we would call a corner case, right?

858
00:41:01,880 --> 00:41:03,860
就在我们... 好了，就这些
Just when we've made-- right, this is all

859
00:41:03,860 --> 00:41:06,823
听起来不错，至少在程序设计上是这样但是，等一下,
sounding great, at least as programming goes, but, wait a minute,

860
00:41:06,823 --> 00:41:08,240
如果你想打印一个报价呢？
what if you want to print a quote?

861
00:41:08,240 --> 00:41:09,557
问得好。
That's a really good question.

862
00:41:09,557 --> 00:41:11,390
看看我们能不能解决这个问题。
Well, let's see if we can't figure this out.

863
00:41:11,390 --> 00:41:15,590
假设我想打印出的不仅仅是用户名。
Suppose that I want to print out not just the user's name.

864
00:41:15,590 --> 00:41:16,940
让我进一步简化一下。
Let me simplify this further.

865
00:41:16,940 --> 00:41:18,980
让我先把这些东西处理掉,
Let me go ahead and get rid of a lot of this,

866
00:41:18,980 --> 00:41:21,510
让我说几句，你好
and let me just say something like, Hello--

867
00:41:24,170 --> 00:41:26,240
也许我是在讽刺你。
maybe I'm being a little sarcastic here.

868
00:41:26,240 --> 00:41:28,310
你好，(讽刺地)“朋友”
Hello, (sarcastically) "friend."

869
00:41:28,310 --> 00:41:30,022
就是那种语气。
You know, in that kind of tone.

870
00:41:30,022 --> 00:41:31,730
事实上，这样是行不通的,
Well this is not going to work, actually,

871
00:41:31,730 --> 00:41:36,260
因为你想用引号表示“朋友”
because you are trying to use quotes to be like "friend" in finger quotes,

872
00:41:36,260 --> 00:41:38,070
但你也想结束这句话。
but you're also trying to end the sentence.

873
00:41:38,070 --> 00:41:39,778
如果我试图运行这个，让我们做到这一点。
And if I try running this, let's do this.

874
00:41:39,778 --> 00:41:43,160
Python，您将看到这只是无效的语法。
Python of Hello.py, you'll see that this is just invalid syntax.

875
00:41:43,160 --> 00:41:44,420
也许你忘了一个逗号。
Perhaps you forgot a comma.

876
00:41:44,420 --> 00:41:45,920
这其实有点烦人。
And this is actually a bit annoying.

877
00:41:45,920 --> 00:41:48,822
有时，您看到的错误消息具有误导性。
Sometimes the error messages you see are misleading.

878
00:41:48,822 --> 00:41:50,780
就像电脑，语言，并不是真的
Like the computer, the language, doesn't really

879
00:41:50,780 --> 00:41:52,488
知道发生了什么，所以它会尽力而为
know what's going on so it gives its best

880
00:41:52,488 --> 00:41:55,010
猜测，但不一定是正确的。
guess, but it's not necessarily correct.

881
00:41:55,010 --> 00:41:57,870
但是我可以用几种方法来解决这个问题。
But I can solve this problem in a couple of ways.

882
00:41:57,870 --> 00:41:59,160
我能做到
I can do this--

883
00:41:59,160 --> 00:42:01,912
我可以把最外面的引号改成单引号。
I can change my outermost quotes to single quotes.

884
00:42:01,912 --> 00:42:03,620
因为再回想一下，我说的是你
Because recall a moment again, I said you

885
00:42:03,620 --> 00:42:07,130
可以使用双引号或单引号，只要你是一致的。
could use double quotes or single quotes so long as you're consistent.

886
00:42:07,130 --> 00:42:08,000
所以没关系。
So that's fine.

887
00:42:08,000 --> 00:42:10,142
如果在外部使用单引号，则
If you use single quotes on the outside, you

888
00:42:10,142 --> 00:42:13,100
然后可以在内部使用双引号，你会看到他们的字面意思。
can then use double quotes on the inside and you'll see them literally.

889
00:42:13,100 --> 00:42:17,000
例如，如果我运行 Python of Hello.py，就可以了。
So for instance, if I run Python of Hello.py, there we go.

890
00:42:17,000 --> 00:42:18,590
你好，朋友
Hello, "friend."

891
00:42:18,590 --> 00:42:19,910
但还有别的办法。
But there's another way.

892
00:42:19,910 --> 00:42:23,450
如果你坚持使用双引号,
If you insist on using double quotes as you might want to,

893
00:42:23,450 --> 00:42:27,800
为了保持一致，您还可以再次使用反斜杠字符。
just to be consistent, you can also use that backslash character again.

894
00:42:27,800 --> 00:42:30,080
我们刚才看到了。
We saw the /n a moment ago.

895
00:42:30,080 --> 00:42:33,380
这意味着我们不希望字面 n 出现在输出中,
And that meant we don't want a literal n to be in the output,

896
00:42:33,380 --> 00:42:34,640
我们想要一条新的生产线。
we wanted a new line.

897
00:42:34,640 --> 00:42:38,420
所以反斜杠实际上代表了所谓的转义字符。
So the backslash actually represents what's called an escape character.

898
00:42:38,420 --> 00:42:40,430
逃脱角色是一个你不能
An escape character is one that you can't just

899
00:42:40,430 --> 00:42:43,130
在键盘上必须打一次字。
type necessarily once on your keyboard.

900
00:42:43,130 --> 00:42:45,270
您需要使用多个字符来表示它。
You need to express it with multiple characters.

901
00:42:45,270 --> 00:42:50,920
所以我可以在这些内双引号前面加上反斜杠
So I can actually put backslashes in front of these inner double quotes

902
00:42:50,920 --> 00:42:52,920
这样计算机就会意识到，哦，等一下,
so that the computer realizes, Oh wait a minute,

903
00:42:52,920 --> 00:42:57,560
那些不是完成或开始思考的引号，而是字面上的引号。
those aren't quotes that finish or start the thought, they're literal quotes.

904
00:42:57,560 --> 00:43:02,420
现在让我回到我的终端窗口，运行 Python of Hello.py，Enter。
So now let me go back to my terminal window, run Python of Hello.py, Enter.

905
00:43:02,420 --> 00:43:04,800
现在它也起作用了。
And now it's working as well.

906
00:43:04,800 --> 00:43:08,390
所以逃逸是一种普遍的技术，它也允许我们这样做。
So escaping is a general technique that allows us to do that too.

907
00:43:08,390 --> 00:43:12,230
如果可以的话，让我们回顾一下这些例子
And if I may, let me rewind now on these examples

908
00:43:12,230 --> 00:43:14,810
然后回到我们停止的地方，用我的代码,
and go back to where we left off with my code,

909
00:43:14,810 --> 00:43:18,200
我只是想撤销这一切，因为我想回到正题上来
I'm just undoing all of that, because I want to get back to the point

910
00:43:18,200 --> 00:43:23,820
最终确定了解决这个问题的最终方法。
ultimately of specifying now a final way of solving this problem.

911
00:43:23,820 --> 00:43:26,300
看来我们还有别的办法
Well, it turns out that we have yet another way

912
00:43:26,300 --> 00:43:30,680
我们可以解决这个问题，这可能是最常做的
we can solve this problem, which is perhaps the most frequently done

913
00:43:30,680 --> 00:43:35,030
现在，或者至少是我们相亲时最优雅的时候
now or at least the most elegant when it comes to setting us up

914
00:43:35,030 --> 00:43:38,840
字符串的使用时间越来越长。
for longer and longer uses of strings.

915
00:43:38,840 --> 00:43:43,620
您可以使用 Python 的一个相对较新的特性来实现这一点。
You can use a relatively new feature of Python that allows you to do this.

916
00:43:43,620 --> 00:43:47,397
你可以直接输入字符串中变量的名字,
You can literally put, not the name of the variable like that in your string,

917
00:43:47,397 --> 00:43:49,230
因为我们已经知道这是错的，对吧？
because we already saw this is wrong, right?

918
00:43:49,230 --> 00:43:52,340
如果您这样做，您将逐字地看到 Hello，逗号，名称。
If you do this, you will literally see Hello, comma, name.

919
00:43:52,340 --> 00:43:53,580
但如果我这么做呢？
But what if I do this?

920
00:43:53,580 --> 00:43:58,070
如果我在变量的名称周围放大括号或者大括号会怎么样？
What if I put curly braces or curly brackets around the variable's name?

921
00:43:58,070 --> 00:44:00,830
注意 VS 代码实际上正在非常微妙地改变它的颜色。
Notice VS Code is actually very subtly changing the color of it.

922
00:44:00,830 --> 00:44:03,590
所以 VS 代码知道这里发生了一些有趣的事。
So VS Code knows something interesting is going on here.

923
00:44:03,590 --> 00:44:08,060
让我运行这个程序，但我还没有完成 Python 的 Hello.py，Enter。
Let me run this program, but I'm not done yet Python of Hello.py, Enter.

924
00:44:08,060 --> 00:44:09,650
D-A-V-I-D，回车。
D-A-V-I-D, Enter.

925
00:44:09,650 --> 00:44:13,430
好吧，显然不是我想要的但我得告诉巨蟒
OK, obviously not what I want, but I need to tell Python

926
00:44:13,430 --> 00:44:15,140
这是一个特殊的字符串。
that this is a special string.

927
00:44:15,140 --> 00:44:18,470
我们称之为格式字符串或者 F 字符串,
This is what we're going to call a format string or an F string,

928
00:44:18,470 --> 00:44:21,660
在过去的几年里 Python 的一个相对较新的特性
a relatively new feature of Python in the past few years

929
00:44:21,660 --> 00:44:26,750
它告诉 Python 以一种特殊的方式格式化字符串中的内容。
that tells Python to actually format stuff in the string in a special way.

930
00:44:26,750 --> 00:44:29,480
这个符号有点奇怪,
And the symbol via what you do this is a little weird,

931
00:44:29,480 --> 00:44:31,220
但这是世界的选择。
but this is what the world chose.

932
00:44:31,220 --> 00:44:35,390
如果你在字符串的开头放一个 F,
If you put an F at the beginning of the string,

933
00:44:35,390 --> 00:44:40,160
就在第一个引号之前这是 Python 的线索,
right before the first quote mark, that's a clue to Python that, ooh,

934
00:44:40,160 --> 00:44:41,210
这是一根特殊的弦。
this is a special string.

935
00:44:41,210 --> 00:44:43,550
让我用一种特殊的方式为你格式化它。
Let me format this in a special way for you.

936
00:44:43,550 --> 00:44:45,380
现在让我重新运行程序。
Let me now rerun the program.

937
00:44:45,380 --> 00:44:47,120
Python Hello.py，Enter.
Python Hello.py, Enter.

938
00:44:47,120 --> 00:44:48,410
D-A-V-I-D，回车。
D-A-V-I-D, Enter.

939
00:44:48,410 --> 00:44:51,170
现在我们终于看到了目标
And now we see the goal this whole time--

940
00:44:51,170 --> 00:44:52,395
你好，大卫。
Hello, David.

941
00:44:52,395 --> 00:44:55,520
我们不用这种方式开始因为我觉得如果我们用第一种方式,
We don't start with this way, because I think if we did this the first way,

942
00:44:55,520 --> 00:44:57,330
你会想，我们为什么要这么做？
you'd be like, why are we doing this?

943
00:44:57,330 --> 00:44:58,850
这些魔法符号是什么？
What are all these magical symbols?

944
00:44:58,850 --> 00:45:02,370
但这只是解决同样问题的另一种方法。
But this is just yet another way to solve the same problem.

945
00:45:02,370 --> 00:45:04,940
但我建议我们现在就考虑
But let me propose that we consider now yet

946
00:45:04,940 --> 00:45:06,920
其他我们可以用弦来做的事情。
other things we can do with strings.

947
00:45:06,920 --> 00:45:11,190
事实证明，即使我们做了一些相对简单的操作
And it turns out that even as we've been doing some relatively simple operations

948
00:45:11,190 --> 00:45:14,665
在这里，我们一直相信用户会合作
here, we've generally been trusting that the user is going to cooperate

949
00:45:14,665 --> 00:45:17,790
也就是说他们会输入我们想要他们输入的内容
and that is to say that they're going to actually type in what we want them

950
00:45:17,790 --> 00:45:18,450
打字。
to type.

951
00:45:18,450 --> 00:45:20,850
虽然他们输入了字符串，但这并不意味着
Now just because they type a string, though, doesn't mean

952
00:45:20,850 --> 00:45:22,410
会是我们想要的样子。
it's going to look the way we want.

953
00:45:22,410 --> 00:45:24,510
你和我，说实话，就像人类一样
You and I, honestly, as humans are actually

954
00:45:24,510 --> 00:45:27,840
在网站和应用程序上，有意外撞击的习惯
in the habit-- on websites and apps-- of like accidentally hitting

955
00:45:27,840 --> 00:45:30,300
空格键很多，无论是在我们的输入的开始
the spacebar a lot, either at the beginning of our input

956
00:45:30,300 --> 00:45:33,460
或者在最后，也许是因为空格键太大了。
or at the end, maybe because the space bar tends to be so big.

957
00:45:33,460 --> 00:45:35,790
意外空格很常见
It's pretty common to get accidental spaces

958
00:45:35,790 --> 00:45:37,950
在一些用户输入之前或之后。
before or after some users' input.

959
00:45:37,950 --> 00:45:41,675
你和我绝对是习惯了不用大写字母
You and I are definitely in the habit of not necessarily capitalizing words

960
00:45:41,675 --> 00:45:42,300
就像我们应该做的那样。
like we should.

961
00:45:42,300 --> 00:45:45,122
如果我们发短信的话，可能有点太快了
If we're sending text messages, we're probably being a little quick

962
00:45:45,122 --> 00:45:46,830
把所有东西都用小写字母发送出去,
and just sending everything in lowercase,

963
00:45:46,830 --> 00:45:49,913
比如，如果这是你的风格，如果你的手机没有为你修好。
for instance, if that's your style, if your phone's not fixing it for you.

964
00:45:49,913 --> 00:45:52,530
也许在一封正式的信中，你可以恰当地使用大写字母。
Maybe in a formal letter you would capitalize things properly.

965
00:45:52,530 --> 00:45:56,400
但是你和我作为人类，我们不能被信任去用一种很好的方式打字
But you and I as humans, we can't really be trusted to type things in a nice way

966
00:45:56,400 --> 00:45:58,870
当使用某个软件的时候,
necessarily when using some piece of software,

967
00:45:58,870 --> 00:46:00,940
不管是应用程序还是网站还是别的什么。
be it an app or a website or something else.

968
00:46:00,940 --> 00:46:04,560
但事实证明，弦自己就会出现
But it turns out that strings themselves come

969
00:46:04,560 --> 00:46:06,450
有很多内置的功能。
with a lot of built-in functionality.

970
00:46:06,450 --> 00:46:09,300
您可以在 Python 自己的文档中看到所有这些内容。
You can see all of that in Python's own documentation here.

971
00:46:09,300 --> 00:46:12,600
我们一直在讨论的字符串数据类型
The string data type that we've been talking about

972
00:46:12,600 --> 00:46:14,970
内置了很多功能
comes with a lot of functionality built in that

973
00:46:14,970 --> 00:46:18,360
意味着我们可以操纵用户的输入来做更多的事情
means that we can manipulate the user's input to do more than just

974
00:46:18,360 --> 00:46:22,290
加入其他东西，比如 Hello，我们可以把它清理干净
join it with something else like Hello, we can actually clean it up

975
00:46:22,290 --> 00:46:26,380
或者重新格式化，希望看起来对我们更好一点。
or reformat it in a way that hopefully looks a little better for us.

976
00:46:26,380 --> 00:46:29,070
让我们回到我的代码
So let me go back to my code here and let me just

977
00:46:29,070 --> 00:46:32,100
演示如果用户不合作可能发生的情况。
demonstrate what might happen if a user doesn't cooperate.

978
00:46:32,100 --> 00:46:35,490
如果我继续运行 Python of Hello.py，回车。
If I go ahead here and run Python of Hello.py, Enter.

979
00:46:35,490 --> 00:46:38,890
让我多按几次空格键。
Let me just sloppily hit the spacebar a few too many times.

980
00:46:38,890 --> 00:46:39,390
为什么？
Why?

981
00:46:39,390 --> 00:46:40,890
我只是没注意。
I just wasn't paying attention.

982
00:46:40,890 --> 00:46:43,710
现在我要输入我的名字 D-A-V-I-D 我不知道,
And now I'm going to type in my name D-A-V-I-D and, I don't know,

983
00:46:43,710 --> 00:46:45,510
我又按了几次空格键。
I hit the spacebar a couple more times.

984
00:46:45,510 --> 00:46:46,620
好像一团糟。
Like it's kind of a mess.

985
00:46:46,620 --> 00:46:47,785
都是小写的。
It's all lowercase.

986
00:46:47,785 --> 00:46:50,160
这看起来不一定语法正确。
That's not going to necessarily look grammatically right.

987
00:46:50,160 --> 00:46:51,900
这里和这里都有空格。
It's got spaces here and here.

988
00:46:51,900 --> 00:46:54,030
程序会准确地打印出来
The program is going to print exactly that

989
00:46:54,030 --> 00:46:55,890
这看起来很糟糕，至少如果我们
and that looks really bad, at least if we're

990
00:46:55,890 --> 00:46:57,900
优先考虑美学和语法。
prioritizing aesthetics and grammar.

991
00:46:57,900 --> 00:47:00,330
为什么逗号后面有这么多空格？
Like, why are there so many spaces after the comma?

992
00:47:00,330 --> 00:47:03,420
这不是一种欢迎用户的非常好的方式。
This is not a very nice way to greet your users.

993
00:47:03,420 --> 00:47:05,130
但我们可以清理干净。
But we can clean this up.

994
00:47:05,130 --> 00:47:10,170
结果是内置到字符串中，同样是这个数据类型，所以
It turns out that built into strings, which, again, is this data type, so

995
00:47:10,170 --> 00:47:12,780
可以说，Python 中的这种类型的数据——
to speak, this type of data in Python--

996
00:47:12,780 --> 00:47:15,730
就是对字符串做实际操作的能力。
is the ability to actually do things to that string.

997
00:47:15,730 --> 00:47:20,280
让我这样做，我可以继续做这样的事情——
So let me do this, I can actually go ahead and do something like this--

998
00:47:20,280 --> 00:47:23,820
Name = name.Strip.
name = name.strip.

999
00:47:23,820 --> 00:47:25,240
这个有什么用？
And what does this do?

1000
00:47:25,240 --> 00:47:30,460
删除字符串中的空白。
Remove white space from string.

1001
00:47:30,460 --> 00:47:32,060
我这么说是什么意思？
And what do I mean by this?

1002
00:47:32,060 --> 00:47:33,910
好吧，在右手边，注意我已经
Well, on the right-hand side, notice I've

1003
00:47:33,910 --> 00:47:36,700
编写了名为 Name 的变量名。
written the variable name called Name.

1004
00:47:36,700 --> 00:47:40,120
然后我用一个句点或点，然后我
I've then used a period or a dot, and then I

1005
00:47:40,120 --> 00:47:42,520
看起来像是在做某种功能，对吧？
seem to be doing what's a function, right?

1006
00:47:42,520 --> 00:47:46,300
到目前为止，每当我们看到一个函数时，我们都会看到该函数的名称—— print
Any time we've seen a function thus far, we see the function's name-- print

1007
00:47:46,300 --> 00:47:49,030
或者输入，然后我们看到一个括号，然后另一个括号,
or input, then we see a parenthesis, then another parenthesis,

1008
00:47:49,030 --> 00:47:50,678
这就是我在这里看到的。
and that's exactly what I see here.

1009
00:47:50,678 --> 00:47:52,720
但是我使用这个函数的方式有点不同。
But I'm using this function a little differently.

1010
00:47:52,720 --> 00:47:55,990
从技术上讲，这个函数在上下文中称为方法。
Technically, this function is-- in this context-- called a method.

1011
00:47:55,990 --> 00:47:57,620
我这么说是什么意思？
And what do I mean by that?

1012
00:47:57,620 --> 00:48:00,250
如果 Name 是字符串，也就是。
Well, if Name is a string, a.k.a.

1013
00:48:00,250 --> 00:48:03,130
STR 事实证明，根据文件记载,
STR, well it turns out, according to the documentation,

1014
00:48:03,130 --> 00:48:07,630
在 Python 中有很多字符串附带的函数。
there's a lot of functions that come with strings in Python.

1015
00:48:07,630 --> 00:48:10,150
您可以通过使用
And you can access that functionality by using

1016
00:48:10,150 --> 00:48:14,860
一个字符串的名字，比如这里的字面名字，然后是句点，然后是名字
the name of a string like literally name here, then a period, then the name

1017
00:48:14,860 --> 00:48:18,220
函数的，然后是一个开括号和一个闭括号。
of the, function and then an open parenthesis and a closed parenthesis.

1018
00:48:18,220 --> 00:48:21,320
也许这些括号里有一些参数但在这个例子中,
Maybe some arguments inside of those parentheses, but in this case,

1019
00:48:21,320 --> 00:48:22,900
不需要任何争论。
it doesn't need any arguments.

1020
00:48:22,900 --> 00:48:26,320
我只想把左边的空间和左边的空间分开
I just want to strip the space from the left and the space

1021
00:48:26,320 --> 00:48:28,000
从用户输入的右边。
from the right of the user's input.

1022
00:48:28,000 --> 00:48:29,210
但这还不够。
But that's not enough.

1023
00:48:29,210 --> 00:48:31,120
我想记住我已经脱光了
I want to remember that I've stripped off

1024
00:48:31,120 --> 00:48:32,920
左边和右边的空白处,
that white space on the left and the right,

1025
00:48:32,920 --> 00:48:35,470
所以我要在这里再用一次等号。
so I'm going to use the equal sign again here.

1026
00:48:35,470 --> 00:48:38,590
请注意，和以前一样，这并不意味着平等,
And notice that just as before, this doesn't mean equality,

1027
00:48:38,590 --> 00:48:40,940
这意味着从右到左的作业。
this means assignment from right to left.

1028
00:48:40,940 --> 00:48:43,900
所以当这行代码—— name. Strip ——
So when this line of code here-- name.strip--

1029
00:48:43,900 --> 00:48:46,600
回到我身边，也就是。
returns to me, a.k.a.

1030
00:48:46,600 --> 00:48:49,123
返回值，它将返回相同的值
a return value, it will return the same thing

1031
00:48:49,123 --> 00:48:51,790
用户输入的，但左边没有更多的空白
that the user typed in, but with no more white space to the left

1032
00:48:51,790 --> 00:48:54,370
或白色[笑]到右边。
or to the white [CHUCKLES] to the right.

1033
00:48:54,370 --> 00:48:56,860
那么等号赋值就是
So then the equal sign assignment is going

1034
00:48:56,860 --> 00:49:00,190
从右向左复制该值,
to copy that value from the right to the left,

1035
00:49:00,190 --> 00:49:04,820
从而更新 name 变量内部的值。
thereby updating the value inside of my name variable.

1036
00:49:04,820 --> 00:49:07,240
所以你不仅可以给变量赋值,
So you can not only assign values to variables,

1037
00:49:07,240 --> 00:49:10,300
你完全可以改变变量的值
you can absolutely change the value of variables

1038
00:49:10,300 --> 00:49:12,817
通过使用赋值运算符等号,
by just using the assignment operator, the equal sign again,

1039
00:49:12,817 --> 00:49:15,400
一次又一次，它只是从右边复制
and again, and again, and it will just keep copying from right

1040
00:49:15,400 --> 00:49:17,810
留下新的值。
to left whatever the new value should be.

1041
00:49:17,810 --> 00:49:23,740
所以现在如果我重新运行这个程序，Python of Hello.py，Enter。
So now if I rerun this program, Python of Hello.py, Enter.

1042
00:49:23,740 --> 00:49:25,930
我有 D-A-V-I ——噢，我们再来一次。
I have D-A-V-I-- oop, let's do it again.

1043
00:49:25,930 --> 00:49:29,170
空间，空间，空间，空间 d-a-v-i-d 全小写，空间,
Space, space, space, space, space. d-a-v-i-d in all lowercase, space,

1044
00:49:29,170 --> 00:49:30,760
空间，回车。
space, Enter.

1045
00:49:30,760 --> 00:49:32,060
这样更好。
It's better.

1046
00:49:32,060 --> 00:49:34,300
它没有固定我的资本，所以我仍然
It hasn't fixed my capitalization, so I'm still

1047
00:49:34,300 --> 00:49:38,050
第一个 D 有点草率，但已经脱落了
being a little sloppy with the first D, But it has stripped off

1048
00:49:38,050 --> 00:49:39,430
所有那些额外的空间。
all of that extra space.

1049
00:49:39,430 --> 00:49:41,170
超级小细节，对吧？
Super minor detail, right?

1050
00:49:41,170 --> 00:49:44,050
好像这一切都不那么令人兴奋，但是
Like this isn't all that exciting, but it just

1051
00:49:44,050 --> 00:49:47,440
说明了只需要一行代码就可以完成的工作的力量。
speaks to the power of what you can do with just a single line of code.

1052
00:49:47,440 --> 00:49:49,160
我还能做什么？
Now what else can I do here?

1053
00:49:49,160 --> 00:49:51,610
我可以大写用户的输入。
Well I could capitalize the user's input.

1054
00:49:51,610 --> 00:49:53,390
让我试试这个。
Let me go ahead and try this.

1055
00:49:53,390 --> 00:49:59,810
事实证明，我也可以这么做，名字，大写。
It turns out that I could also do this-- name.capitalize.

1056
00:49:59,810 --> 00:50:03,420
所以让我继续，并大写用户的名称。
So let me go ahead and capitalize user's name.

1057
00:50:03,420 --> 00:50:05,170
再说一遍，我在发表评论
And again, I'm making comments and there's

1058
00:50:05,170 --> 00:50:06,820
没有一个正确的写评论的方法。
no one right way to write the comments.

1059
00:50:06,820 --> 00:50:08,770
我只是在这里使用一些简短的英语短语
I'm just using some short English phrases here

1060
00:50:08,770 --> 00:50:10,510
提醒自己在做什么。
to remind myself of what I'm doing.

1061
00:50:10,510 --> 00:50:12,190
这是怎么回事？
What's now going on here?

1062
00:50:12,190 --> 00:50:15,310
让我继续运行 Python of Hello.py，Enter。
Well let me go ahead and run Python of Hello.py, Enter.

1063
00:50:15,310 --> 00:50:19,240
空间，空间，空间，空间，空间 d-a-v-i-d，空间，空间，回车。
Space, space, space, space, space, d-a-v-i-d, space, space, Enter.

1064
00:50:19,240 --> 00:50:19,960
好的。
OK.

1065
00:50:19,960 --> 00:50:21,580
现在看起来更漂亮了，对吧？
Now it's looking prettier, right?

1066
00:50:21,580 --> 00:50:24,640
不管用户怎么输入他们的名字哪怕有一点马虎,
No matter how the user typed in their name, even a little sloppily,

1067
00:50:24,640 --> 00:50:25,720
我现在正在解决这个问题。
I'm now fixing that.

1068
00:50:25,720 --> 00:50:27,313
但我们试试别的办法。
But let's try something.

1069
00:50:27,313 --> 00:50:28,730
我有点好奇。
I'm getting a little curious here.

1070
00:50:28,730 --> 00:50:29,830
这个怎么样？
How about this?

1071
00:50:29,830 --> 00:50:33,910
空间，空间，空间，空间 d-a-v-i-d 空间 m-a-l-a-n
Space, space, space, space, space, d-a-v-i-d space m-a-l-a-n--

1072
00:50:33,910 --> 00:50:35,530
我现在用我的姓
I'll use my last name now--

1073
00:50:35,530 --> 00:50:36,640
进来。
Enter.

1074
00:50:36,640 --> 00:50:42,100
好吧，讽刺的是“大写”并不是我们想要的所有东西都大写。
OK, so ironically, "capitalize" is not really capitalizing everything we want.

1075
00:50:42,100 --> 00:50:43,870
这明显是在利用什么？
It's clearly capitalizing what?

1076
00:50:43,870 --> 00:50:45,580
只有第一个字母。
Just the very first letter.

1077
00:50:45,580 --> 00:50:48,940
事实证明，在 Python 中还有其他函数
So it turns out that, again, there's other functions in Python

1078
00:50:48,940 --> 00:50:49,960
都是有条件的。
that come with strings.

1079
00:50:49,960 --> 00:50:54,670
如果我们浏览这些文档滚动浏览这样的网址,
And if we poke around the documentation, scrolling through a URL like that,

1080
00:50:54,670 --> 00:50:58,540
我打赌我们会找到另一个解决方案，其中之一就是这个。
I bet we'll find another solution, one of which is actually this.

1081
00:50:58,540 --> 00:51:01,180
我们把这个改成标题吧。
Let's actually change this to title.

1082
00:51:01,180 --> 00:51:03,550
还有一个带字符串的函数
There's yet another function that comes with strings

1083
00:51:03,550 --> 00:51:07,120
称为“标题”，以标题为基础进行大写
called Title that do title-based capitalization, just

1084
00:51:07,120 --> 00:51:09,310
像一本书或一个人的名字，大写
like a book or a person's name, capitalizing

1085
00:51:09,310 --> 00:51:12,010
每个单词的首字母。
the first letter of each word.

1086
00:51:12,010 --> 00:51:14,450
这只是为我们做更多的工作。
And this is just going to do a little more work for us.

1087
00:51:14,450 --> 00:51:15,880
让我们继续运行这个程序。
So let's go ahead and run this.

1088
00:51:15,880 --> 00:51:18,700
顺便说一句，我现在有点累了
And as an aside, I'm kind of tired now at this point

1089
00:51:18,700 --> 00:51:22,130
一直在输入 Python，Python，Python。
of typing Python, Python, Python all the time.

1090
00:51:22,130 --> 00:51:25,570
事实证明，在使用这样的命令行界面时,
It turns out that when using a command line interface like this,

1091
00:51:25,570 --> 00:51:28,000
你实际上可以重新执行所有的旧命令。
you can actually go back through all of your old commands.

1092
00:51:28,000 --> 00:51:30,280
我刚才按了向上箭头。
What I just did a moment ago was I hit the up arrow.

1093
00:51:30,280 --> 00:51:33,820
这会立即回顾我所有命令的历史
That immediately goes back through my history of all of the commands

1094
00:51:33,820 --> 00:51:34,720
最好的打字机。
I've ever typed.

1095
00:51:34,720 --> 00:51:37,960
所以这只是我重复自己的一种更快的方式
So this is just a faster way now for me to repeat myself

1096
00:51:37,960 --> 00:51:39,700
而不是手动打字。
than typing everything manually.

1097
00:51:39,700 --> 00:51:42,850
让我继续按回车，空格，空格，空格，空格，空格,
Let me go ahead and hit Enter, space, space, space, space, space,

1098
00:51:42,850 --> 00:51:47,110
d-a-v-i-d m-a-l-a-n 空格，小写，回车。
d-a-v-i-d m-a-l-a-n space, space, all lowercase, Enter.

1099
00:51:47,110 --> 00:51:49,690
现在看起来好多了。
Now it's looking better.

1100
00:51:49,690 --> 00:51:52,030
现在我已经把事情都搞定了。
Now I've capitalized things and cleaned things up.

1101
00:51:52,030 --> 00:51:53,200
那我的原则呢？
But what about my code?

1102
00:51:53,200 --> 00:51:55,930
我现在有八行代码，其中四行
I've got like eight lines of code now, four of which

1103
00:51:55,930 --> 00:51:58,030
是注释，其中四个是实际的代码。
are comments, four of which are actual code.

1104
00:51:58,030 --> 00:51:59,710
我真的需要这么多吗？
Do I really need this much?

1105
00:51:59,710 --> 00:52:00,910
不一定。
Well, not necessarily.

1106
00:52:00,910 --> 00:52:03,520
看看我在 Python 中还能做些什么。
Watch what I can also do in Python.

1107
00:52:03,520 --> 00:52:07,100
让我不必分别将用户的名称大写。
Let me not bother capitalizing the user's name separately.

1108
00:52:07,100 --> 00:52:08,170
我这么说吧
Let me say this--

1109
00:52:08,170 --> 00:52:12,970
大写用户名。
and capitalize user's name.

1110
00:52:12,970 --> 00:52:15,370
我可以把这些功能连接起来。
I can chain these functions together.

1111
00:52:15,370 --> 00:52:18,130
我可以把 Title 添加到这个结尾。
I can add Title to the end of this.

1112
00:52:18,130 --> 00:52:19,600
现在是什么情况？
And now what's happening?

1113
00:52:19,600 --> 00:52:21,440
再说一遍，像这样的一行代码,
Well again, with a line of code like this,

1114
00:52:21,440 --> 00:52:24,490
你首先关注等号右边是什么,
you first focus on what's to the right of the equal sign,

1115
00:52:24,490 --> 00:52:26,470
然后我们到等号的左边。
then we'll get to the left of the equal sign.

1116
00:52:26,470 --> 00:52:28,095
等号右边是什么？
What's on the right of the equals sign?

1117
00:52:28,095 --> 00:52:29,240
这条线。
This line here.

1118
00:52:29,240 --> 00:52:30,390
这是什么意思？
Well what does this mean?

1119
00:52:30,390 --> 00:52:35,610
获取 name 变量的值，如 D-A-V-I-D 空间、 M-A-L-A-N。
Get the value of the name variable, like D-A-V-I-D space, M-A-L-A-N.

1120
00:52:35,610 --> 00:52:38,700
然后去掉左边和右边的空白。
Then strip off the white space on the left and the right.

1121
00:52:38,700 --> 00:52:40,920
将返回一个值。
That is going to return a value.

1122
00:52:40,920 --> 00:52:44,790
它将返回没有任何空白的 D-A-V-I-D 空间 M-A-L-A-N
It's going to return D-A-V-I-D space M-A-L-A-N without any white space

1123
00:52:44,790 --> 00:52:45,720
向左或向右。
to the left or right.

1124
00:52:45,720 --> 00:52:47,940
您希望如何处理这个返回值？
What do you want to do with that return value?

1125
00:52:47,940 --> 00:52:50,850
你想让 Python 把它命名为 case
You want Python to title case it, that is

1126
00:52:50,850 --> 00:52:54,330
仔细检查所生成字符串中的每个单词
go through every word in that resulting string

1127
00:52:54,330 --> 00:52:57,000
把第一个单词的第一个字母，第一个字母
and fix the first letter of the first word, the first letter

1128
00:52:57,000 --> 00:52:58,390
第二个单词，等等。
of the second word, and so forth.

1129
00:52:58,390 --> 00:53:00,330
然后，现在我们可以完成我们的想法了
And then-- now we can finish our thought--

1130
00:53:00,330 --> 00:53:05,580
把整个东西从右到左复制到同一个 name 变量中。
copy the whole thing from right to left into that same name variable.

1131
00:53:05,580 --> 00:53:06,330
你知道吗？
And you know what?

1132
00:53:06,330 --> 00:53:08,340
我可以更进一步。
I can take this even one step further.

1133
00:53:08,340 --> 00:53:11,400
如果我们想的话，为什么不直接开始呢。
Why don't we go ahead and do this if we want.

1134
00:53:11,400 --> 00:53:16,890
让我摆脱这一切，让我只做脱衣舞和标题
Let me get rid of all of that, and let me just do strip and title

1135
00:53:16,890 --> 00:53:18,270
都在第一行。
all on that first line.

1136
00:53:18,270 --> 00:53:21,380
现在我们已经从8行代码变成了4行。
And now we've gone from like eight lines of code to four.

1137
00:53:21,380 --> 00:53:22,740
更紧了。
It's a lot tighter.

1138
00:53:22,740 --> 00:53:23,880
干净多了。
It's a lot neater.

1139
00:53:23,880 --> 00:53:26,250
尽管理智的人可能不这么认为,
And even though reasonable people might disagree,

1140
00:53:26,250 --> 00:53:30,090
可以说它更好，因为它更容易阅读。
it's arguably better because it's just easier to read.

1141
00:53:30,090 --> 00:53:32,670
代码越少，出错的机会越少,
Fewer lines of code, fewer opportunities for mistakes,

1142
00:53:32,670 --> 00:53:37,350
这样我就可以继续解决下一个问题了。
it just allows me to move on with my next problem to solve.

1143
00:53:37,350 --> 00:53:41,730
好吧，我暂停一下看看这些方法有没有问题。
All right, let me pause here and see if there's any questions on these methods.

1144
00:53:41,730 --> 00:53:45,540
方法是一个内置于值类型中的函数,
A method is a function that's built in to a type of value,

1145
00:53:45,540 --> 00:53:47,820
就像这些功能一样。
like these functions are.

1146
00:53:47,820 --> 00:53:50,640
或者在 F 弦上，我们刚才看到了。
Or on F strings which we saw a moment ago.

1147
00:53:50,640 --> 00:53:51,390
观众: 是的，你好。
AUDIENCE: Yes, hi.

1148
00:53:51,390 --> 00:53:52,410
谢谢，大卫。
Thanks, David.

1149
00:53:52,410 --> 00:53:56,190
那么有没有办法去除空格之间的空格
So is there a way to remove the spaces between the spaces

1150
00:53:56,190 --> 00:53:57,430
我可能加进去的东西吗？
that I might have added?

1151
00:53:57,430 --> 00:53:58,680
大卫. 马兰: 简短的回答，不。
DAVID MALAN: Short answer, no.

1152
00:53:58,680 --> 00:54:01,060
如果您在同一个 URL 上阅读文档,
If you read the documentation at that same URL earlier,

1153
00:54:01,060 --> 00:54:05,090
你会看到条带从左右两边移开，但不会在两边之间。
you'll see that strip removes from the left and the right, but not in between.

1154
00:54:05,090 --> 00:54:07,590
事实上，还有另外两个字符串函数。
In fact, there's two other functions that come with strings.

1155
00:54:07,590 --> 00:54:10,560
一个叫 L 带，一个叫 R 带,
One is called L strip, the other is called R strip,

1156
00:54:10,560 --> 00:54:12,378
你可以选择其中一个。
that allow you to do one or the other.

1157
00:54:12,378 --> 00:54:14,670
如果我们想要去掉中间的空间,
If we want to start getting rid of space in the middle,

1158
00:54:14,670 --> 00:54:17,760
我们要做一个完全不同的魔术。
we're going to have to do a different trick altogether.

1159
00:54:17,760 --> 00:54:22,380
观众: 有多少函数可以像这个点条，点标题,
AUDIENCE: How many functions can be combine like this dot strip, dot title,

1160
00:54:22,380 --> 00:54:23,160
全部加起来。
all combined.

1161
00:54:23,160 --> 00:54:24,930
那么我们可以合并多少？
So how many we can combine?

1162
00:54:24,930 --> 00:54:26,970
大卫. 马兰: 是的，一个非常好的问题。
DAVID MALAN: Yeah, a really good question.

1163
00:54:26,970 --> 00:54:30,177
技术上来说，你想要多少就有多少，但总有一天
Technically, as many as you want, but at some point

1164
00:54:30,177 --> 00:54:32,760
你的代码会看起来非常非常糟糕，对吧？
your code is going to start to look really, really bad, right?

1165
00:54:32,760 --> 00:54:35,302
因为代码行会变得非常非常长。
Because the line of code is going to get really, really long.

1166
00:54:35,302 --> 00:54:38,130
它最终可能会一次又一次地缠绕。
It's eventually going to maybe wrap around again and again.

1167
00:54:38,130 --> 00:54:41,220
所以在某种程度上，你会说，呃，呃，太多了。
So at some point, you just kind of say like, uh-uh, that's too many.

1168
00:54:41,220 --> 00:54:44,340
然后你开始像我一样把它分成几行。
And you start breaking it up into multiple lines like I did.

1169
00:54:44,340 --> 00:54:47,518
也许根据需要将值重新分配给变量。
Maybe reassigning the value to the variable as needed.

1170
00:54:47,518 --> 00:54:49,060
这其实是个好问题。
And this is actually a good question.

1171
00:54:49,060 --> 00:54:52,830
如果我能绕开你的问题，我是说，人们会怎么想？
If I can pivot, [INAUDIBLE] off your question, I mean, what do people think?

1172
00:54:52,830 --> 00:54:55,770
请大家先把手放下。
If we could go ahead and put everyone's hands down for a moment.

1173
00:54:55,770 --> 00:54:57,690
让我问问
Let me ask this--

1174
00:54:57,690 --> 00:55:03,450
就是我现在做这件事的方式，使用带、标题和输入
is the way I've done this now, with strip and title and input

1175
00:55:03,450 --> 00:55:04,800
都在同一条线上
all in the same line--

1176
00:55:04,800 --> 00:55:07,290
比我之前的方法更好吗？
better than my previous approach?

1177
00:55:07,290 --> 00:55:10,830
在缩放中，你可以使用“是”图标或“否”图标。
In Zoom you can use the Yes icon or the No icon.

1178
00:55:10,830 --> 00:55:14,370
如果你认为这个版本更好，说是。
If you think this version is better, say Yes.

1179
00:55:14,370 --> 00:55:19,060
例如，如果你认为以前的版本更好,
If you think this previous version was better, for instance,

1180
00:55:19,060 --> 00:55:23,310
这里我们所有的东西都爆炸了，说不。
this one here where we had everything broken out, say No.

1181
00:55:23,310 --> 00:55:26,610
然后我们马上就知道为什么了。
And then we'll see why in just a moment.

1182
00:55:26,610 --> 00:55:30,000
我之前提出，理性的人可以有不同意见
I proposed earlier that reasonable people can disagree

1183
00:55:30,000 --> 00:55:32,730
绝对是这样。
and that's absolutely the case.

1184
00:55:32,730 --> 00:55:35,520
不管怎样都不一定是最好的,
Doing it one way or the other isn't necessarily best,

1185
00:55:35,520 --> 00:55:37,800
至少如果你能证明的话。
at least if you can justify it.

1186
00:55:37,800 --> 00:55:41,280
让我们回到最近的版本。
Let me go back to the most recent version here.

1187
00:55:41,280 --> 00:55:45,360
好吧，我们看到很多人同意，很多人反对。
All right so we're seeing a lot of Yeses and a lot of Nos.

1188
00:55:45,360 --> 00:55:48,900
如果可以的话，我们为什么不去拜访一个赞成者呢。
Why don't we go ahead and call on one of the Yeses, if we could.

1189
00:55:48,900 --> 00:55:52,710
是的，为什么你认为这个代码的当前版本
Someone who's voting Yes, why do you think the current version of this code

1190
00:55:52,710 --> 00:55:57,330
是否真的比以前的较长版本的代码更好？
is indeed better than the previous longer version of the code?

1191
00:55:57,330 --> 00:55:59,110
观众: 我认为它更易读。
AUDIENCE: I think it's more readable.

1192
00:55:59,110 --> 00:56:03,030
我可以说，这是 name 变量。
So I can say, this is the name variable.

1193
00:56:03,030 --> 00:56:07,360
它获得一些输入，然后删除空格并给它一个标题。
It gets some input and then remove the space and give it a title.

1194
00:56:07,360 --> 00:56:08,320
就是这样。
And there you go.

1195
00:56:08,320 --> 00:56:09,600
你好，名字。
You have a hello, name.

1196
00:56:09,600 --> 00:56:10,860
大卫. 马兰: 是的，我认为这很合理。
DAVID MALAN: Yeah, I think that's pretty reasonable.

1197
00:56:10,860 --> 00:56:12,660
它非常易读，至少如果你有这个习惯的话,
It's very readable, at least if you're in the habit,

1198
00:56:12,660 --> 00:56:14,660
就像你用英语一样，从左往右读。
as you are in English, of reading left to right.

1199
00:56:14,660 --> 00:56:16,990
结果就变得非常自然了。
It just kind of flows very naturally as a result.

1200
00:56:16,990 --> 00:56:18,943
队伍其实没那么长。
The lines is not really that long.

1201
00:56:18,943 --> 00:56:20,860
放在屏幕上很合适。
It's certainly fitting nicely onto the screen.

1202
00:56:20,860 --> 00:56:21,870
所以我认为这是一个很好的论点。
So I think that's a good argument.

1203
00:56:21,870 --> 00:56:23,310
不过，来个对位怎么样？
How about a counterpoint, though?

1204
00:56:23,310 --> 00:56:27,810
一个投反对票的人，如果我们能找到一个认为情况更糟的人。
Someone who voted No, if we could call on someone who thinks this is worse.

1205
00:56:27,810 --> 00:56:31,410
观众: 因为它根本不可读。
AUDIENCE: Because it's not readable at all.

1206
00:56:31,410 --> 00:56:37,300
好像排了很长的队。
It seems like it's a very long line.

1207
00:56:37,300 --> 00:56:39,170
所以我觉得还是分开比较好。
So I think it's better to separate.

1208
00:56:39,170 --> 00:56:39,920
是的。
DAVID MALAN: Yeah.

1209
00:56:39,920 --> 00:56:41,580
我觉得这也很有说服力，对吧？
I think that's persuasive too, right?

1210
00:56:41,580 --> 00:56:43,050
时间有点长了。
It's getting a little longer.

1211
00:56:43,050 --> 00:56:46,890
尽管我这里的句子——你叫什么名字——相对较短,
And even though my sentence here-- what's your name-- is relatively short,

1212
00:56:46,890 --> 00:56:49,530
你可以想象这会很快变得更糟
you could imagine that this could get even uglier quickly

1213
00:56:49,530 --> 00:56:52,350
如果我问用户一个更长的问题，那就是
if I were asking a longer question of the user, that's

1214
00:56:52,350 --> 00:56:56,070
会使这行代码更长，因此可读性更差。
going to make this line of code even longer and therefore less readable.

1215
00:56:56,070 --> 00:56:59,970
对我或我的同事来说，我称之为脱衣舞可能不那么明显
It might be less obvious to me or my colleagues that I am calling strip

1216
00:56:59,970 --> 00:57:01,530
或者我称之为头衔。
or that I am calling title.

1217
00:57:01,530 --> 00:57:03,870
这可能是个意想不到的惊喜。
It might be kind of an unexpected surprise.

1218
00:57:03,870 --> 00:57:05,460
所以我认为这也是合理的。
So I think that's reasonable too.

1219
00:57:05,460 --> 00:57:07,570
简而言之，这里没有正确的答案。
In short, there is no right answer here.

1220
00:57:07,570 --> 00:57:10,680
事实上，这也是提高编程能力的过程之一
And in fact, part of the process of getting better at programming

1221
00:57:10,680 --> 00:57:14,168
就是找到自己的风格，或者为一家公司工作
is getting your own sense of style or working for a company

1222
00:57:14,168 --> 00:57:16,710
在那里他们可能会规定哪种方式比另一种更好
where they might prescribe which way is better than the other

1223
00:57:16,710 --> 00:57:18,930
因为他们希望每个人都做同样的事情,
because they just want everyone doing the same thing,

1224
00:57:18,930 --> 00:57:22,080
即使理智的人可能不同意。
even though reasonable people might disagree.

1225
00:57:22,080 --> 00:57:24,750
但最终，只要你拥有
Ultimately though, so long as you have what's

1226
00:57:24,750 --> 00:57:28,710
一个很好的支持这个或那个的论点，就像最终,
a pretty good argument in favor of one way or the other, like ultimately,

1227
00:57:28,710 --> 00:57:29,820
这才是最重要的。
that's what's important.

1228
00:57:29,820 --> 00:57:32,160
如果你做这些事只是因为你不知道哪个更好,
If you're just doing things because you don't really know which one is better,

1229
00:57:32,160 --> 00:57:33,180
这可不妙。
that's not great.

1230
00:57:33,180 --> 00:57:35,460
但是当你开始获得意见的时候
But if and when you start to acquire opinions

1231
00:57:35,460 --> 00:57:38,610
如果你的老板，你的老师，你的同事，你的朋友,
and if your boss, if your teacher, if your colleague, your friend,

1232
00:57:38,610 --> 00:57:41,312
可以挑战你，说，等等，你为什么这样做呢？
can challenge you and say, wait, why did you do it like this?

1233
00:57:41,312 --> 00:57:43,770
他们可能不同意你的观点，但至少有个答案,
They might not agree with you, but at least have an answer,

1234
00:57:43,770 --> 00:57:47,010
一般来说，这应该足够有说服力。
and that should be sufficiently persuasive in general.

1235
00:57:47,010 --> 00:57:49,230
现在，字符串附带了一大堆其他方法
Now, strings come with a whole bunch of other methods

1236
00:57:49,230 --> 00:57:53,310
其中有一种叫做分裂，顾名思义,
as well, among which is one called split, which can, as the name suggests,

1237
00:57:53,310 --> 00:57:57,030
可以说，把一个字符串分成多个较小的子字符串。
split a string into multiple smaller substrings, so to speak.

1238
00:57:57,030 --> 00:57:59,040
例如，如果这里的人类有这样的习惯
For instance, if the human here is in the habit

1239
00:57:59,040 --> 00:58:02,130
输入他们的名字，然后是空格，然后是他们的姓,
of typing in their first name, then a space, and then their last name,

1240
00:58:02,130 --> 00:58:05,070
你只想用名字迎接他们,
and you want to go ahead and greet them only by first name,

1241
00:58:05,070 --> 00:58:07,140
我们可以利用这个空间
well we could actually leverage that single space

1242
00:58:07,140 --> 00:58:09,930
在名字和姓之间切分字符串
between the first name and last name and split that string

1243
00:58:09,930 --> 00:58:11,760
分成两个更小的子弦。
into two smaller substrings.

1244
00:58:11,760 --> 00:58:12,820
我们要怎么做？
How can we do this?

1245
00:58:12,820 --> 00:58:14,820
好吧，让我继续在这些线之间
Well, let me go ahead and in between these lines

1246
00:58:14,820 --> 00:58:18,210
主动评论说我们要拆分用户的
proactively comment that we're about to split user's

1247
00:58:18,210 --> 00:58:22,230
名字变成姓和名。
name into first name and last name.

1248
00:58:22,230 --> 00:58:25,920
然后我们继续，获取名称变量，它当前包含
And then let's go ahead and take that name variable, which currently contains

1249
00:58:25,920 --> 00:58:28,590
比如大卫，太空，马兰,
something like, presumably, David, space, Malan,

1250
00:58:28,590 --> 00:58:32,130
让我继续调用 Split 并将其作为参数传入
and let me go ahead and call split and pass in as the argument

1251
00:58:32,130 --> 00:58:35,820
分割出一个单独的空白，从而表明我确实
to split a single white space, thereby indicating that I indeed

1252
00:58:35,820 --> 00:58:37,750
想要在这个角色上分裂
want to split on that character

1253
00:58:37,750 --> 00:58:41,363
现在，在理想情况下，Split 将返回一个值序列
Now it turns out split is going to return a sequence of values, ideally

1254
00:58:41,363 --> 00:58:42,780
先是名，然后是姓。
a first name and then a last name.

1255
00:58:42,780 --> 00:58:45,330
实际上，在 Python 中，我们可以同时赋这两个值
And we can actually, in Python, assign both of those values

1256
00:58:45,330 --> 00:58:47,940
从这个序列到某些变量。
from that sequence at once to some variables.

1257
00:58:47,940 --> 00:58:51,360
例如，第一个逗号最后一个等于
For instance, first comma last equals, and that's

1258
00:58:51,360 --> 00:58:53,220
将会产生从右到左的影响
going to have the effect from right to left

1259
00:58:53,220 --> 00:58:56,760
将第一个这样的值放入第一个变量，第二个这样的值
of putting the first such value in the first variable, the second such value

1260
00:58:56,760 --> 00:58:57,880
在第二个变量中。
in the second variable.

1261
00:58:57,880 --> 00:59:01,350
所以现在在我的最后一行代码中，我可以进去打个招呼
So now on my last line of code, I can go in and say hello

1262
00:59:01,350 --> 00:59:03,900
不是全名，比如大卫 · 马兰,
not to the full name, something like David Malan,

1263
00:59:03,900 --> 00:59:06,540
我可以先打个招呼。
I can just say Hello, first.

1264
00:59:06,540 --> 00:59:10,200
好了，清空我的终端窗口运行 Python 的 Hello.py
All right, let's go ahead and clear my terminal window, run Python of Hello.py

1265
00:59:10,200 --> 00:59:10,807
然后按回车键。
and hit Enter.

1266
00:59:10,807 --> 00:59:13,890
这次我不会再为任何前导空白而烦恼了，但是让我继续
I won't bother with any leading white space this time, but let me go ahead

1267
00:59:13,890 --> 00:59:19,290
然后输入 David Space Malan 像往常一样祈祷，你好,
and type in David space Malan, and crossing my fingers as usual, Hello,

1268
00:59:19,290 --> 00:59:21,720
大卫就是我们现在看到的。
David is what we now see.

1269
00:59:21,720 --> 00:59:25,530
好了，我们已经看到了太多，太多的例子
All right, so we've seen so much, so many examples thus far involving

1270
00:59:25,530 --> 00:59:29,430
字符串，但是程序和编程语言当然可以
strings, but certainly programs and programming languages can

1271
00:59:29,430 --> 00:59:32,080
也可以处理其他类型的数据。
manipulate other types of data as well.

1272
00:59:32,080 --> 00:59:36,000
让我们继续，然后转换到另一种非常常见的数据类型
Let's go ahead and transition then to another very common type of data

1273
00:59:36,000 --> 00:59:38,610
在 Python 中，更一般地说，在编程中，即
in Python, in programming more generally, namely

1274
00:59:38,610 --> 00:59:41,160
整数，在 Python 中又称为 INT ——
integers, otherwise known in Python as INT--

1275
00:59:41,160 --> 00:59:46,080
正如 STR，S-T-R 是字符串的缩写，Python 中的 INT 也是如此
I-N-T. So just as STR, S-T-R is short for string, so is INT in Python

1276
00:59:46,080 --> 00:59:47,210
整数的缩写。
short for integer.

1277
00:59:47,210 --> 00:59:48,210
整数是什么？
Well, what's an integer?

1278
00:59:48,210 --> 00:59:51,390
就像数学中的负2一样,
Well just like in math it's a number like negative 2,

1279
00:59:51,390 --> 00:59:55,605
负1,0,1,2，一直到负无穷大
negative 1, 0, 1, 2, and all the way toward negative infinity, all

1280
00:59:55,605 --> 00:59:56,980
走向正无穷大的道路。
the way toward positive infinity.

1281
00:59:56,980 --> 00:59:59,040
但是整数中没有小数点。
But there's no decimal point in an integer.

1282
00:59:59,040 --> 01:00:04,260
它只是一个负2，负1,0,1，和2的数字。
It's just a number like negative 2, negative 1, 0, 1, and 2 onward.

1283
01:00:04,260 --> 01:00:05,160
那是智力。
That's an INT.

1284
01:00:05,160 --> 01:00:09,360
当然，在数学的世界里，我们使用了很多符号。
Of course, in the world of mathematics, there's lots of symbols that we use.

1285
01:00:09,360 --> 01:00:12,300
我们以前也见过 + ，尽管我们用它来做不同的用途。
And we've seen + before, although we used it for a different purpose.

1286
01:00:12,300 --> 01:00:15,030
但是 Python 支持这些符号以及更多的东西。
But Python supports these symbols and more.

1287
01:00:15,030 --> 01:00:18,090
Python 允许你把数字相加 + ,
And Python allows you to add numbers together +,

1288
01:00:18,090 --> 01:00:21,580
减数，乘数，除数。
subtract numbers, multiply numbers, divide numbers.

1289
01:00:21,580 --> 01:00:25,380
这里唯一一个看起来有点陌生或者不熟悉的人
And the only one here that might look a little strange to people or unfamiliar

1290
01:00:25,380 --> 01:00:29,310
是这个百分比符号，但在这个上下文中它并不意味着百分比。
is this percent sign, but it doesn't mean percent in this context.

1291
01:00:29,310 --> 01:00:32,400
如果在 Python 程序中使用单个百分号,
If you use a single percent sign in a Python program,

1292
01:00:32,400 --> 01:00:34,680
这就是所谓的模运算符,
that's actually the so-called modulo operator,

1293
01:00:34,680 --> 01:00:38,400
允许你在除数后求余数的运算符
the operator that allows you to take the remainder after dividing

1294
01:00:38,400 --> 01:00:40,210
一个号码接着一个号码。
one number by another.

1295
01:00:40,210 --> 01:00:43,230
我们很快就会看到这样的例子，但是前四个
So we'll see examples of that before long, but the first four of these

1296
01:00:43,230 --> 01:00:45,570
可能非常非常熟悉。
are perhaps quite, quite familiar.

1297
01:00:45,570 --> 01:00:49,240
事实证明，在 Python 中，你不一定——
Well it turns out that in Python you cannot necessarily--

1298
01:00:49,240 --> 01:00:54,480
您不必一直在 Hello.py 这样的文件中编写代码
you don't necessarily have to keep writing code in a file like Hello.py

1299
01:00:54,480 --> 01:00:56,700
然后在终端窗口中运行它。
and then running it in a terminal window.

1300
01:00:56,700 --> 01:00:59,610
很多人喜欢 Python 的一个特性
One of the features that many people like about Python

1301
01:00:59,610 --> 01:01:02,250
它支持这种所谓的交互模式。
is that it supports this so-called interactive mode.

1302
01:01:02,250 --> 01:01:06,240
就像您可以开始编写 Python 代码并立即执行
Like you can start writing Python code and immediately execute

1303
01:01:06,240 --> 01:01:08,965
每一行都是互动的，尤其是
each of those lines interactively, especially

1304
01:01:08,965 --> 01:01:11,340
如果您不在乎保存所有的代码行。
if you don't care about saving all of your lines of code.

1305
01:01:11,340 --> 01:01:14,590
您只需要执行代码并返回一些答案。
You just want to execute code and get back some answers.

1306
01:01:14,590 --> 01:01:18,400
例如，让我回到这里的 VS Code 并关闭 Hello.py
So for instance, let me go back to VS Code here and let me close Hello.py

1307
01:01:18,400 --> 01:01:22,050
让我点击终端窗口中的这个小三角形
and let me click on the little triangle over here in my terminal window just

1308
01:01:22,050 --> 01:01:24,880
让它变得更大只是暂时的。
to make it much bigger just temporarily for a moment.

1309
01:01:24,880 --> 01:01:30,450
所以我现在不创建任何.py 文件，我只是要自己运行 Python
So I'm not creating any .py file now, I'm just going to run Python by itself

1310
01:01:30,450 --> 01:01:31,410
在我的提示下。
at my prompt.

1311
01:01:31,410 --> 01:01:35,100
当我这样做的时候，你会看到一些神秘的输出
And you'll see when I do this, I get some cryptic looking output

1312
01:01:35,100 --> 01:01:38,890
以及程序上次更新的日期和时间等等。
and the date and time at which the program was last updated, and so forth.

1313
01:01:38,890 --> 01:01:43,710
但我最终得到了三个这样的三重括号。
But I ultimately get three triple brackets like this.

1314
01:01:43,710 --> 01:01:46,740
是 Python 的交互模式。
Is the interactive mode for Python.

1315
01:01:46,740 --> 01:01:52,050
所以我在运行 Python 解释器，每当我键入一行代码时
So I'm running the Python interpreter and any time I type a line of code

1316
01:01:52,050 --> 01:01:54,570
在解释器中，它会立即执行。
in the interpreter, it's going to execute it immediately.

1317
01:01:54,570 --> 01:01:56,942
我不需要一次又一次地运行 Python。
I don't have to keep running Python again and again.

1318
01:01:56,942 --> 01:01:58,650
就好像在人类世界里，如果你
It's as though in the human world, if you

1319
01:01:58,650 --> 01:02:01,635
站在一个会说其他语言的人类旁边,
were standing next to a human who speaks some other language,

1320
01:02:01,635 --> 01:02:04,260
你只是和他们来回交谈,
and you're just having a conversation with them back and forth,

1321
01:02:04,260 --> 01:02:07,030
一切都在发生，翻译，马上。
it's all happening-- the translation-- immediately.

1322
01:02:07,030 --> 01:02:08,940
那么在交互模式下我可以做什么呢？
So what might I do in interactive mode?

1323
01:02:08,940 --> 01:02:11,760
我可以做1 + 1，回车。
Well I could do something like 1 + 1, Enter.

1324
01:02:11,760 --> 01:02:13,380
那其实是暗号，好吗？
That's actually code, all right?

1325
01:02:13,380 --> 01:02:16,590
你可能不认为它是代码，但如果一点算术和你
You might not think of it as code, but if a bit of arithmetic and you

1326
01:02:16,590 --> 01:02:21,060
知道数字，你知道 + ，这是有效的 Python 代码。
know numbers, and you know +, that's valid Python code.

1327
01:02:21,060 --> 01:02:23,537
你可以把 Python 当作一个很棒的计算器。
And you can use Python really as a fancy calculator.

1328
01:02:23,537 --> 01:02:24,870
但是我也可以做其他的事情。
But I could do other things too.

1329
01:02:24,870 --> 01:02:28,020
如果我想打印给自己，你好，世界,
If I want to print to myself Hello, world,

1330
01:02:28,020 --> 01:02:30,750
我也可以把那行代码打印出来
I can also print out that line of code there too--

1331
01:02:30,750 --> 01:02:31,530
你好，世界。
Hello, world.

1332
01:02:31,530 --> 01:02:33,600
所以它是互动的，在某种意义上
So it's interactive in the sense that the moment

1333
01:02:33,600 --> 01:02:36,960
你只要执行一行代码，砰，你就能看到结果。
you execute a line of code, boom, you see the result.

1334
01:02:36,960 --> 01:02:39,450
我们通常不会这么做，因为至少当
We're generally not going to do that because at least when

1335
01:02:39,450 --> 01:02:42,810
教语言时，我们倾向于渐进地做事情
teaching the language, we tend to want to do things incrementally

1336
01:02:42,810 --> 01:02:45,513
我们希望你能看到我们从哪里来。
and we want you to be able to see where it is we came from.

1337
01:02:45,513 --> 01:02:48,180
我们希望能够一次又一次地尝试，特别是
And we want to be able to try things again and again, especially

1338
01:02:48,180 --> 01:02:49,140
如果我们犯了错。
if we make mistakes.

1339
01:02:49,140 --> 01:02:51,690
但要知道这确实是 Python 的一个特性,
But know that this is indeed a feature of Python,

1340
01:02:51,690 --> 01:02:54,250
这个所谓的交互模式。
this so-called interactive mode.

1341
01:02:54,250 --> 01:02:57,015
但现在让我们关注一下，不仅仅是互动,
But let's focus for a moment now, not just on that interactivity,

1342
01:02:57,015 --> 01:02:58,890
但实际上巨蟒
but really on the fact that Python apparently

1343
01:02:58,890 --> 01:03:03,310
支持整数和数学以及一些基本运算。
supports integers and mathematics and some of those basic operations.

1344
01:03:03,310 --> 01:03:06,430
看看我们能不能做出我们自己的小计算器。
And let's see if we can't make maybe our own little calculator.

1345
01:03:06,430 --> 01:03:08,820
让我再打开 VS 代码,
So let me go ahead and open up VS Code again,

1346
01:03:08,820 --> 01:03:11,440
我要缩小我的终端窗口,
and I'm going to shrink down my terminal window,

1347
01:03:11,440 --> 01:03:14,610
我将创建一个名为 Calculator.py 的新文件。
and I'm going to create a new file called Calculator.py.

1348
01:03:14,610 --> 01:03:17,950
为了进行回忆，我可以在这里输入代码,
So to do that recall, I can type Code down here,

1349
01:03:17,950 --> 01:03:21,540
以及要创建的文件的名称: . py，Enter。
and the name of the file I want to create, .py, Enter.

1350
01:03:21,540 --> 01:03:23,550
这给了我一个新的账单。
That gives me a new tab up top.

1351
01:03:23,550 --> 01:03:25,620
我已经关闭了 Hello.py。
So I have already closed Hello.py.

1352
01:03:25,620 --> 01:03:27,150
我现在在 Calculator.py。
I'm now in Calculator.py.

1353
01:03:27,150 --> 01:03:30,900
让我们做一个简单的计算器，为我做一些加法。
And let's just make a simple calculator that does some addition for me.

1354
01:03:30,900 --> 01:03:33,690
但是我要在一个文件中进行，这样我们就可以对这个进行迭代
But I'm going to do it in a file so that we can iterate on this

1355
01:03:33,690 --> 01:03:36,607
随着时间的推移，不管是好是坏，都要做出改变。
and make changes for better or for worse over time.

1356
01:03:36,607 --> 01:03:38,940
让我先声明几个变量。
Let me go ahead and first declare a couple of variables.

1357
01:03:38,940 --> 01:03:42,840
我要用数学方法调用我的第一个变量 x,
I'm going to do the mathematical thing of calling my first variable x,

1358
01:03:42,840 --> 01:03:45,840
第二个变量 y，然后我给自己
my second variable y, and then I'm going to give myself

1359
01:03:45,840 --> 01:03:48,720
第三个变量 z = x + y。
a third variable z = x + y.

1360
01:03:48,720 --> 01:03:50,970
然后打印出 z。
And then I'm going to go ahead and print out z.

1361
01:03:50,970 --> 01:03:54,858
现在这个节目，诚然不是很精彩或有趣,
Now this program, admittedly not very exciting or interesting,

1362
01:03:54,858 --> 01:03:57,900
事实上，比起在屏幕上打印东西来说，这有点没意思
in fact, it's a little less interesting than printing stuff on the screen

1363
01:03:57,900 --> 01:04:01,110
就像以前用弦乐器一样，但我们会在此基础上再进一步
like before with strings, but we'll build on this

1364
01:04:01,110 --> 01:04:04,030
看看 Python 中还有哪些其他特性是我们可以利用的。
and see what other features exist in Python that we can leverage.

1365
01:04:04,030 --> 01:04:07,410
所以希望，如果 Python 和我一样懂数学,
So hopefully, if Python knows it's math as well as I do,

1366
01:04:07,410 --> 01:04:13,140
当我运行 Python of Calculator.py 时，我希望看到1 + 2
when I run Python of Calculator.py, I should see hopefully that 1 + 2

1367
01:04:13,140 --> 01:04:15,600
= 确实3。
= indeed 3.

1368
01:04:15,600 --> 01:04:18,510
好吧，没那么惊讶，也没那么有趣。
All right, so not that surprising and not that interesting.

1369
01:04:18,510 --> 01:04:20,730
老实说，这不是最有用的程序
And honestly this isn't the most useful program

1370
01:04:20,730 --> 01:04:24,840
因为它总是要计算1 + 2 = 3。
because it's always going to calculate 1 + 2 = 3.

1371
01:04:24,840 --> 01:04:28,170
让我们至少让这个节目，比如说，更加互动一点，好吗？
Let's at least make this program, say, a little more interactive, right?

1372
01:04:28,170 --> 01:04:31,590
从前面的例子中，我们已经知道如何从用户那里获得输入。
We already know from previous examples how we can get input from the user.

1373
01:04:31,590 --> 01:04:33,540
让我们回到输入函数。
Let's bring back that input function.

1374
01:04:33,540 --> 01:04:37,380
让我们这样做，让我现在继续，在我的代码的顶部,
And let's do this, let me go ahead now and at the top of my code,

1375
01:04:37,380 --> 01:04:40,650
我们把 x 改成不是数字1,
let's change x to not be the number 1 always,

1376
01:04:40,650 --> 01:04:42,510
让我们把它改成无论什么回报
let's change it to be whatever the return

1377
01:04:42,510 --> 01:04:45,690
值是要求用户输入 x。
value is of asking the user for x.

1378
01:04:45,690 --> 01:04:48,730
在这里，我可以使用任何我想要的英语或人类语言。
And I can use any English or human language I want here.

1379
01:04:48,730 --> 01:04:49,890
我会说，x 是什么？
I'm going to say, what's x?

1380
01:04:49,890 --> 01:04:52,410
就像我之前问的，你叫什么名字？
Just like I asked before, what's your name?

1381
01:04:52,410 --> 01:04:54,180
我也会为你做同样的事。
And I'm going to do the same thing for y.

1382
01:04:54,180 --> 01:04:57,330
我将再次使用 Input，但是这次将问题改为,
I'm going to use Input again, but this time change the question to be,

1383
01:04:57,330 --> 01:04:58,728
y 是什么？
what's y?

1384
01:04:58,728 --> 01:05:01,770
好了，现在，我想把剩下的代码留下
All right, at this point, I think I'm going to leave the rest of the code

1385
01:05:01,770 --> 01:05:02,730
一样。
the same.

1386
01:05:02,730 --> 01:05:06,450
Z = x + y，然后打印 z，不过好的方面是
Z = x + y And then print z but what's nice

1387
01:05:06,450 --> 01:05:10,140
现在我觉得我有一个很好的交互式计算器。
now is that I think I have a nice interactive calculator.

1388
01:05:10,140 --> 01:05:12,510
现在它不会一直做1 + 2了。
Right, now it's not going to do 1 + 2 all the time.

1389
01:05:12,510 --> 01:05:16,330
它将执行用户输入的任何操作 + 用户输入的任何操作。
It's going to do whatever the user types + whatever the user types.

1390
01:05:16,330 --> 01:05:17,530
我们试试这个。
So let's try this.

1391
01:05:17,530 --> 01:05:19,080
让我继续运行这个程序。
Let me go ahead and run that program.

1392
01:05:19,080 --> 01:05:20,110
好了，开始吧。
All right, let's do it.

1393
01:05:20,110 --> 01:05:26,670
1等于 x，2等于 y，当然，大家都同意，1
1 is going to be x, 2 is going to be y, and of course, everyone in agreement, 1

1394
01:05:26,670 --> 01:05:30,762
+ 2 = thr ——
+ 2 = thr--

1395
01:05:30,762 --> 01:05:31,980
嗯。
huh.

1396
01:05:31,980 --> 01:05:36,040
发生什么事了？
What's going on there?

1397
01:05:36,040 --> 01:05:40,720
要么是你的数学课误导了你，要么是我误导了你。
Either your math class misled you or I have misled you.

1398
01:05:40,720 --> 01:05:43,000
我们为什么不叫人来看看你呢
Why don't we call on someone here to see if you

1399
01:05:43,000 --> 01:05:46,900
不能帮助我们推理出漏洞是什么，错误是什么？
can't help us reason through what the bug is, what's the mistake?

1400
01:05:46,900 --> 01:05:48,970
Anjali 如果我没说错的话。
Anjali, if I'm saying it right.

1401
01:05:48,970 --> 01:05:52,960
听众: 我认为问题在于它连接字符串是因为
AUDIENCE: I think the issue is that it's concatenating strings because you

1402
01:05:52,960 --> 01:05:54,935
使用 + 运算符而不是添加。
use the + operator instead of adding.

1403
01:05:54,935 --> 01:05:55,810
完美。
DAVID MALAN: Perfect.

1404
01:05:55,810 --> 01:05:57,040
完美的直觉。
So perfect intuition.

1405
01:05:57,040 --> 01:06:01,060
我们已经看到 + 在字符串上下文中的用法有些不同
We've seen that + is used a little differently in the context of strings

1406
01:06:01,060 --> 01:06:03,940
因为它连接就是连接两个字符串,
because it concatenates, that is, it joins the two strings,

1407
01:06:03,940 --> 01:06:06,100
看起来确实是这样,
and that seems to Indeed be what's happening here,

1408
01:06:06,100 --> 01:06:07,990
即使用户输入了一个数字。
even though the user typed a number.

1409
01:06:07,990 --> 01:06:09,910
但有趣的是
But the interesting thing here is that, when

1410
01:06:09,910 --> 01:06:13,660
你得到用户输入，因为他们在他们的 Mac 上使用键盘
you get user input, because they're using a keyboard on their Mac

1411
01:06:13,660 --> 01:06:16,900
或者电脑，或者他们的手机，它永远都是短信。
or PC or their phone, it is always going to be text.

1412
01:06:16,900 --> 01:06:19,030
看起来像个数字，但默认情况下,
It might look like a number, but by default,

1413
01:06:19,030 --> 01:06:21,850
从键盘发出的声音就像字符串
it's coming from the keyboard as a string--

1414
01:06:21,850 --> 01:06:23,560
也就是说，作为文本。
that is, as text.

1415
01:06:23,560 --> 01:06:27,760
所以，如果我们最终
And so, how do we go about resolving this if ultimately we

1416
01:06:27,760 --> 01:06:30,190
不想把这些输入当作字符串,
don't want to treat those inputs as strings,

1417
01:06:30,190 --> 01:06:32,110
我们要把它们当作实际的数字？
we want to treat them as actual numbers?

1418
01:06:32,110 --> 01:06:35,050
我们需要另一个函数，它是用 Python 写的
Well we need another function and it turns out in Python

1419
01:06:35,050 --> 01:06:39,610
有时候你可以把一种数据转换成另一种数据,
that you can convert sometimes from one type of data to another type of data,

1420
01:06:39,610 --> 01:06:43,880
例如，通过这样做，从字符串到 INT。
for instance, from string to INT by doing something like this.

1421
01:06:43,880 --> 01:06:46,690
让我回到我的代码，让我改变
Let me go back into my code and let me change

1422
01:06:46,690 --> 01:06:51,730
然后把它加到 y 中，变成 x 的整数形式
x before adding it to y to be whatever the integer version of x

1423
01:06:51,730 --> 01:06:56,030
是，+ 不管 y 的整数形式是什么。
is, + whatever the integer version of y is.

1424
01:06:56,030 --> 01:06:59,950
INT 不仅是 Python 中的一种数据类型,
So it turns out that INT is not only a type of data in Python,

1425
01:06:59,950 --> 01:07:02,590
它也是一个函数，一个函数
it's also a function, and it's a function

1426
01:07:02,590 --> 01:07:05,410
如果你传入一个输入，比如字符串,
that if you pass in an input, like a string,

1427
01:07:05,410 --> 01:07:09,790
只要字符串看起来像1或者2,
so long as that string looks like a number like 1 or like 2,

1428
01:07:09,790 --> 01:07:13,450
它会把它转换成一个实际的数，这样你就可以进行数学计算了
it will convert it to an actual number that you can perform mathematics

1429
01:07:13,450 --> 01:07:14,510
穿上。
on instead.

1430
01:07:14,510 --> 01:07:18,340
所以如果我现在回到我的终端窗口并运行 Python ——
So if I now go back to my terminal window and run Python--

1431
01:07:18,340 --> 01:07:19,870
我再教你一招。
and let me show you another trick.

1432
01:07:19,870 --> 01:07:21,580
“计算器”这个词有点长。
"Calculator" is kind of a long word.

1433
01:07:21,580 --> 01:07:22,930
打字有点乏味。
It's a little tedious to type.

1434
01:07:22,930 --> 01:07:26,470
请注意我可以在终端窗口的命令行中做什么
Notice what I can do in my terminal window, in a command line

1435
01:07:26,470 --> 01:07:27,460
一般界面。
interface in general.

1436
01:07:27,460 --> 01:07:31,300
如果我开始为计算器输入 C-A-L，我实际上可以
If I start typing C-A-L for calculator, I can actually

1437
01:07:31,300 --> 01:07:33,700
点击 Tab 来完成我的想法。
hit Tab to finish my thought.

1438
01:07:33,700 --> 01:07:36,550
所以在这样的终端窗口中自动完成是可能的。
So auto-complete is possible in a terminal window like this.

1439
01:07:36,550 --> 01:07:39,663
输入第一个字母或者几个字母然后，砰，用 Tab 键,
Type the first letter or few letters and then, boom, with Tab,

1440
01:07:39,663 --> 01:07:41,080
它会帮你完成你的思考。
it'll finish your thought for you.

1441
01:07:41,080 --> 01:07:44,770
或者你可以回到你的过去就像我对上下箭头乐队那样。
Or you can go back in your history like I did with the Up and Down Arrows.

1442
01:07:44,770 --> 01:07:46,570
让我来执行吧。
Let me go ahead and execute this.

1443
01:07:46,570 --> 01:07:47,270
X 是什么？
What's x?

1444
01:07:47,270 --> 01:07:47,770
1.
1.

1445
01:07:47,770 --> 01:07:48,290
X 是什么？
What's x?

1446
01:07:48,290 --> 01:07:48,790
2.
2.

1447
01:07:48,790 --> 01:07:49,880
好了。
And there we go.

1448
01:07:49,880 --> 01:07:53,050
现在我们有了一个通用计算器
Now we have a general purpose calculator that's going to support

1449
01:07:53,050 --> 01:07:57,280
不仅仅是1和2的加法，而是现在任意2的加法
not just the addition of 1 and 2, but now any two

1450
01:07:57,280 --> 01:07:58,882
用户键入的整数。
integers that the user types.

1451
01:07:58,882 --> 01:08:00,340
现在让我来改进一下，好吗？
And let me now improve this, right?

1452
01:08:00,340 --> 01:08:03,190
我们已经看到了如何改进代码
We've seen how we can make improvements to code

1453
01:08:03,190 --> 01:08:05,650
我不知道是否会变得更好,
and I don't know if it's going to necessarily be better,

1454
01:08:05,650 --> 01:08:07,000
但我们试试这个。
but let's try this.

1455
01:08:07,000 --> 01:08:09,730
我真的需要 z 变量吗？
Do I really need the z variable?

1456
01:08:09,730 --> 01:08:13,630
值得注意的是，我正在创建一个名为 z 的变量,
It's worth noting that I'm creating a variable called z,

1457
01:08:13,630 --> 01:08:16,720
然后立即在下一行代码中使用它。
and then I'm immediately using it on the next line of code.

1458
01:08:16,720 --> 01:08:20,770
现在这不是那么引人注目，因为如果你创建一个变量
Now that's not that compelling, because if you're creating a variable

1459
01:08:20,770 --> 01:08:23,470
然后立即使用它，但再也不会使用它,
and then immediately using it, but never again using it,

1460
01:08:23,470 --> 01:08:26,890
你真的需要花时间来介绍另一个符号吗
did you really need to take the time to introduce another symbol

1461
01:08:26,890 --> 01:08:30,279
和另一个变量，只是为了使用它一次和只有一次？
and another variable just to use it once and only once?

1462
01:08:30,279 --> 01:08:31,090
也许不是。
Well, maybe not.

1463
01:08:31,090 --> 01:08:33,729
也许我们真的不需要这样的 z。
Maybe we don't really need z in this way.

1464
01:08:33,729 --> 01:08:38,319
也许我应该去做这样的事情。
Maybe I should go and do something like this.

1465
01:08:38,319 --> 01:08:41,140
也许我应该把 Z 处理掉。
Maybe I should get rid of z here.

1466
01:08:41,140 --> 01:08:45,729
也许我应该把这个改成 INT，改
Maybe I should change this to be INT up here, change

1467
01:08:45,729 --> 01:08:50,260
这是 INT 在这里，做一些非常有趣的事情。
this to be INT up here, doing something that's pretty interesting now.

1468
01:08:50,260 --> 01:08:53,680
尽管这是一种新的语法，但请注意
Even though it's a bit of new syntax, notice that you

1469
01:08:53,680 --> 01:08:56,380
可以说，可以嵌套功能。
can nest functions, so to speak.

1470
01:08:56,380 --> 01:09:01,330
您可以放置一个函数调用，它是一个函数的使用
You can put one function call that is the use of a function

1471
01:09:01,330 --> 01:09:04,540
内部使用另一个函数，以便返回
inside of the use of another function so that the return

1472
01:09:04,540 --> 01:09:09,040
内部函数的值成为
value of the inner function becomes the argument to

1473
01:09:09,040 --> 01:09:11,410
或外部函数的输入。
or the input to the outer function.

1474
01:09:11,410 --> 01:09:14,510
就像数学一样，如果你有括号，括号，括号,
Just like in math, if you have parentheses, parentheses, parentheses,

1475
01:09:14,510 --> 01:09:16,218
你的老师可能教过你要集中注意力
your teacher probably taught you to focus

1476
01:09:16,218 --> 01:09:18,430
最里面的括号里面是什么
on what's inside the innermost parentheses first

1477
01:09:18,430 --> 01:09:19,603
然后自己想办法出去。
and then work your way out.

1478
01:09:19,603 --> 01:09:20,770
编程也是一样。
Same thing with programming.

1479
01:09:20,770 --> 01:09:22,040
这就是巨蟒要做的。
That's what's Python is going to do.

1480
01:09:22,040 --> 01:09:24,729
首先要看括号里面是什么,
It's going to look at what's inside of the parentheses first,

1481
01:09:24,729 --> 01:09:26,920
它会得到答案，然后
it's going to get the answer, and then it's

1482
01:09:26,920 --> 01:09:30,710
将返回值传递给最外面的函数。
going to pass the return value to the outermost function.

1483
01:09:30,710 --> 01:09:34,600
所以现在在第1行发生的是首先调用 input 函数,
So what happens on line 1 now is that the input function gets called first,

1484
01:09:34,600 --> 01:09:37,990
那么结果就是，引号1
then the result of that, quote unquote one

1485
01:09:37,990 --> 01:09:42,670
成为 INT 函数的输入，第2行也是如此。
becomes the input to the INT function, and same on line 2.

1486
01:09:42,670 --> 01:09:47,300
Y 的输出成为这个 INT 函数的输入。
The output of what's y becomes the input to this INT function.

1487
01:09:47,300 --> 01:09:49,479
现在没有僵尸了。
And now there is no z.

1488
01:09:49,479 --> 01:09:52,210
我可以打印 x + y。
I could just do print x + y.

1489
01:09:52,210 --> 01:09:56,410
因为我花时间转换了每一个字符串
And because I've taken the time to convert each of those strings

1490
01:09:56,410 --> 01:09:58,720
变成一个整数，我想我们可以了。
to an integer, I think we're OK.

1491
01:09:58,720 --> 01:10:01,570
让我试试这个，Python 的 Calculator.py，Enter。
So let me try this, Python of Calculator.py, Enter.

1492
01:10:01,570 --> 01:10:05,170
1和2我们还是得到了3。
1 and 2, and we're still getting 3.

1493
01:10:05,170 --> 01:10:09,130
不是12，也不是12,1,2，我们确实得到了3。
Not 12, or not 12, 1,2, we're indeed getting 3.

1494
01:10:09,130 --> 01:10:11,350
我们还去掉了变量
And we've additionally gotten rid of the variable

1495
01:10:11,350 --> 01:10:13,900
因为我们似乎不一定需要它,
because we didn't necessarily need it, it seems,

1496
01:10:13,900 --> 01:10:15,490
尤其是只用一次。
especially if only using it once.

1497
01:10:15,490 --> 01:10:18,280
这里也是，让我把大家的手放下来一会儿
Well here too, let me put everyone's hands down for just a moment

1498
01:10:18,280 --> 01:10:19,930
让我像以前一样问你
and let me ask as before--

1499
01:10:19,930 --> 01:10:26,530
这个版本现在使用 INT 来调用输入,
this version now which uses INT around the invocations of input,

1500
01:10:26,530 --> 01:10:30,640
并且没有使用 z，这是否比以前的版本更好？
and does not use z, is this better than the previous version?

1501
01:10:30,640 --> 01:10:32,560
如果你想投赞成票，请便。
If you want to vote Yes, go ahead.

1502
01:10:32,560 --> 01:10:35,270
或者如果你喜欢老办法，投反对票。
Or if you prefer the old way, vote No.

1503
01:10:35,270 --> 01:10:40,455
用老办法，我们投票的时候，我会撤销这一切，而不是像这样。
The old way, I'll undo all of this as we vote, instead looked like this.

1504
01:10:43,510 --> 01:10:45,850
好了，让我们回到最新的版本。
All right, and let me go back to now the newest version.

1505
01:10:45,850 --> 01:10:48,040
让我们来掌声鼓励
Let's take a hand of the Yeses, someone who

1506
01:10:48,040 --> 01:10:51,430
认为这个最新版本更好。
thinks this latest version is better.

1507
01:10:51,430 --> 01:10:57,130
观众: 我认为这种方式更好，因为它可以让我们立即看到
AUDIENCE: I think this way is better because it allows us to immediately see

1508
01:10:57,130 --> 01:11:01,840
整数的 x 和 y 变量是什么
what the x and y variables are with integers

1509
01:11:01,840 --> 01:11:04,660
所以我们知道从他们身上能得到什么。
and so we know what to expect from them.

1510
01:11:04,660 --> 01:11:09,250
而且打印参数更直观。
And also the print argument is more intuitive.

1511
01:11:09,250 --> 01:11:12,330
我们在代码中避免了太多的混乱。
We avoid too much clutter in the code.

1512
01:11:12,330 --> 01:11:14,330
大卫. 马兰: 我认为这些都是很好的理由。
DAVID MALAN: I think those are all good reasons.

1513
01:11:14,330 --> 01:11:15,370
简洁明了。
It's nice and succinct.

1514
01:11:15,370 --> 01:11:17,650
代码行不是很长。
The lines of code are not very long.

1515
01:11:17,650 --> 01:11:20,530
我不需要知道 z 是什么，因为它不存在。
I don't need to know what z is because it doesn't exist.

1516
01:11:20,530 --> 01:11:21,820
只能看到 x + y。
It just sees print x + y.

1517
01:11:21,820 --> 01:11:22,390
我喜欢。
I like that.

1518
01:11:22,390 --> 01:11:25,990
但是有人更喜欢我们曾经拥有 Z 的老方式
But someone who prefers the older way where we did have z

1519
01:11:25,990 --> 01:11:30,970
我们更明确地将单个变量传递给 INT 函数。
and we more explicitly passed individual variables to the INT function.

1520
01:11:30,970 --> 01:11:32,050
观众: 是的，嗨。
AUDIENCE: Yeah, hi.

1521
01:11:32,050 --> 01:11:36,100
我觉得早期的版本更好，因为..
I think that the earlier version is better because when--

1522
01:11:36,100 --> 01:11:39,370
如果用户输入的不是,
I mean, if user input something else other than,

1523
01:11:39,370 --> 01:11:43,570
比如说，我的意思是，比如说，他们输入1和2，比如,
let's say, I mean, let's say, they type 1 and 2, like,

1524
01:11:43,570 --> 01:11:46,780
所以调试起来更容易。
so it will be easier to debug.

1525
01:11:46,780 --> 01:11:49,807
大卫. 马兰: 这个版本还是——这个版本还是旧版本？
DAVID MALAN: This version or-- this version here or the old version?

1526
01:11:49,807 --> 01:11:50,890
观众: 老版本。
AUDIENCE: The old version.

1527
01:11:50,890 --> 01:11:52,098
大卫. 马兰: 好吧，这很公平。
DAVID MALAN: OK, that's fair.

1528
01:11:52,098 --> 01:11:57,190
事实上，我今天非常小心，尽我所能，不要搞砸了。
And in fact, I'm being very careful today, as best I can, not to mess up.

1529
01:11:57,190 --> 01:12:01,050
到目前为止，我只在期待整数时输入了整数。
I have thus far only inputted integers when I'm expecting integers.

1530
01:12:01,050 --> 01:12:02,800
而且拉乌尔实际上是在指着什么东西
And Raoul's actually pointing to something

1531
01:12:02,800 --> 01:12:05,980
我们将在接下来的几周内讨论，我们实际上如何处理错误？
we'll come back to in the coming weeks, how do we actually handle errors?

1532
01:12:05,980 --> 01:12:09,770
如果用户没有输入数字1或者数字2或者数字
What if the user doesn't type in the number 1 or the number 2, or a number

1533
01:12:09,770 --> 01:12:10,270
完全没有？
at all?

1534
01:12:10,270 --> 01:12:13,390
如果他们输入一个单词，比如 cat，C-A-T？
What if they type in a word like cat, C-A-T?

1535
01:12:13,390 --> 01:12:16,150
那不是一个数字，我打赌我不能把它转换成一个整数。
That's not a number, and I bet I can't convert it to an integer.

1536
01:12:16,150 --> 01:12:18,110
但是今天，我不会关注这个。
But for today, I'm not going to focus on that.

1537
01:12:18,110 --> 01:12:20,110
我只希望用户能合作。
I'm just going to hope that the user cooperates.

1538
01:12:20,110 --> 01:12:21,740
但事实并非如此。
But that's not going to be the case.

1539
01:12:21,740 --> 01:12:24,280
因此，也许有一种方法可以让我们取得更大的成功
And so perhaps one way would set us up for more success

1540
01:12:24,280 --> 01:12:26,020
当涉及到处理这些错误时。
when it comes to handling those errors.

1541
01:12:26,020 --> 01:12:28,495
就今天来说，哪个更好？
Now for today's purposes, which is better?

1542
01:12:28,495 --> 01:12:29,650
我两个都喜欢。
Eh, I mean, I like both.

1543
01:12:29,650 --> 01:12:32,440
我认为你们两个在那里也提出了非常有效的论点,
And I think both of you made very valid arguments in there too,

1544
01:12:32,440 --> 01:12:36,250
只要你有一个合理的理由。
so long as you have a justification that feels pretty reasonable.

1545
01:12:36,250 --> 01:12:37,930
这才是最重要的。
I mean, that's what ultimately matters.

1546
01:12:37,930 --> 01:12:41,500
但是，再一次获得了一种权衡的感觉。
But acquiring, again, a sense of the trade-offs here.

1547
01:12:41,500 --> 01:12:43,180
这样好点吗？
Well, is this way better?

1548
01:12:43,180 --> 01:12:44,885
如果是这样，为什么或为什么不呢？
If so, why or why not?

1549
01:12:44,885 --> 01:12:46,760
我只是想知道这些取舍是什么。
Just understanding what those trade-offs are.

1550
01:12:46,760 --> 01:12:51,460
但是一般来说，优先考虑可读性是一件非常好的事情。
But generally speaking, prioritizing readability is a very good thing.

1551
01:12:51,460 --> 01:12:54,740
使您的代码对其他人可读是一件非常好的事情
Making your code readable for someone else is a very good thing

1552
01:12:54,740 --> 01:12:57,608
对你也有好处这样你第二天早上醒来时,
and very good for you too so that when you wake up the next morning,

1553
01:12:57,608 --> 01:12:59,650
或者你下周再来，或者明年再来,
or you come back the next week, or the next year,

1554
01:12:59,650 --> 01:13:02,290
你也可以阅读自己的代码而不必浪费
you too can read your own code without having to waste

1555
01:13:02,290 --> 01:13:04,270
花时间回忆你的所作所为。
time trying to remember what you did.

1556
01:13:04,270 --> 01:13:08,500
简单性也是一件好事——保持代码简单。
And simplicity tends to be a good thing too-- keeping your code simple.

1557
01:13:08,500 --> 01:13:10,960
随着你对编程越来越熟悉,
So as you get more comfortable with programming,

1558
01:13:10,960 --> 01:13:15,250
您可能会试图将整个程序组合成一个长行。
you might be tempted to try to combine an entire program into one long line.

1559
01:13:15,250 --> 01:13:17,740
例如，让我这样做。
For instance, let me do just that.

1560
01:13:17,740 --> 01:13:20,680
从技术上讲，我们并不需要变量中的 x。
Technically speaking, we don't really need x in a variable.

1561
01:13:20,680 --> 01:13:22,480
在变量中我们不需要 y。
We don't really need y in a variable.

1562
01:13:22,480 --> 01:13:24,460
我们也可以这样
We could also do this--

1563
01:13:24,460 --> 01:13:27,820
我可以把 x 和 y 一起去掉。
I could just get rid of x and y altogether.

1564
01:13:27,820 --> 01:13:32,080
我现在可以消除它，使它只是一行代码。
I could then now eliminate that and make it just one line of code.

1565
01:13:32,080 --> 01:13:34,510
好吧，从某种意义上说，你可能倾向于认为，哇,
OK, so on some sense, you might be inclined to think, wow,

1566
01:13:34,510 --> 01:13:35,740
真不错。
that's really nice.

1567
01:13:35,740 --> 01:13:38,410
你只用了一行简单的代码。
You made it one simple line of code.

1568
01:13:38,410 --> 01:13:40,520
我觉得事情没那么简单。
I would argue this actually isn't that simple.

1569
01:13:40,520 --> 01:13:43,180
现在我觉得我已经开始筑巢了。
Now I think I'm starting to nest too many things.

1570
01:13:43,180 --> 01:13:46,330
我必须考虑打印、 INT 和输入。
I have to think about print and INT and input.

1571
01:13:46,330 --> 01:13:49,150
然后我要注意，我打开了两个括号,
I then have to notice that, OK, I've opened two parentheses,

1572
01:13:49,150 --> 01:13:50,300
我已经关了两家了。
I've closed two of them.

1573
01:13:50,300 --> 01:13:51,040
有个 + 。
There's a +.

1574
01:13:51,040 --> 01:13:53,680
你让我想太多了，每次你让我想,
You're making me think too much and any time you make me think,

1575
01:13:53,680 --> 01:13:54,730
你在浪费时间。
you're wasting time.

1576
01:13:54,730 --> 01:13:58,360
任何时候像这样复杂化代码的外观,
And any time you complicate the look of the code like this,

1577
01:13:58,360 --> 01:14:01,300
你只会增加出错的可能性
you're just going to increase the probability of mistakes

1578
01:14:01,300 --> 01:14:04,270
以及代码中的战术错误或逻辑错误。
and tactical mistakes or logical errors in your code.

1579
01:14:04,270 --> 01:14:07,810
所以如果我们做了那么多事这是唯一一件我会争辩的事,
So if all the things we've done, this is the only one that I would argue,

1580
01:14:07,810 --> 01:14:10,870
是的，这是一条线，它很好，紧凑。
yes, it's one line and it's nice and compact.

1581
01:14:10,870 --> 01:14:12,340
只是读起来不够清楚。
It's just not readable enough.

1582
01:14:12,340 --> 01:14:15,850
我会避免这样做，特别是因为其中两个函数
I would shy away from doing this, especially since two of those function

1583
01:14:15,850 --> 01:14:18,040
调用从用户那里获得输入。
calls are getting input from the user.

1584
01:14:18,040 --> 01:14:20,410
但在那里，理智的人可能不同意,
But there too, reasonable people might disagree,

1585
01:14:20,410 --> 01:14:23,830
但有时候你应该有这种发自内心的反应
but that's the kind of visceral reaction you should have sometimes when

1586
01:14:23,830 --> 01:14:28,300
代码开始变得有点太复杂，有点太聪明,
code starts getting a little too complicated, a little too clever,

1587
01:14:28,300 --> 01:14:31,450
也许是为了它自己好。
perhaps, for its own good.

1588
01:14:31,450 --> 01:14:34,270
好吧，我们可以访问的不仅仅是整数。
All right, well it's not just integers we have access to.

1589
01:14:34,270 --> 01:14:38,920
让我提议我们在这里从整数转换到另一种数据类型,
Let me propose that we transition from integers to one more data type here,

1590
01:14:38,920 --> 01:14:40,360
也就是花车。
namely a float.

1591
01:14:40,360 --> 01:14:43,390
同样，字符串是一个文本序列。
So again, a string is a sequence of text.

1592
01:14:43,390 --> 01:14:46,570
INT 是一个类似负1、0和1的整数。
An INT is an integer like negative 1, 0 and 1.

1593
01:14:46,570 --> 01:14:50,860
浮点数是一个带有小数点的数字，正确地称为浮点数
A float is a number with a decimal point, properly called a floating point

1594
01:14:50,860 --> 01:14:51,470
价值。
value.

1595
01:14:51,470 --> 01:14:53,470
你可以认为浮点是
And you can think of the floating point as being

1596
01:14:53,470 --> 01:14:56,740
小数可能在这里，也可能在这里有一些数字
the decimal that might be over here or over here with some number of digits

1597
01:14:56,740 --> 01:14:57,820
向左或向右。
to the left or the right.

1598
01:14:57,820 --> 01:15:02,000
从数学上讲，它是一个实数，一个有小数点的数。
Mathematically, it's a real number, a number that has a decimal point in it.

1599
01:15:02,000 --> 01:15:04,750
这是 Python 支持的第三种类型的数据。
So that's a third type of data that Python supports.

1600
01:15:04,750 --> 01:15:07,270
现在我们的计算器有点天真
Right now our calculator is somewhat naively

1601
01:15:07,270 --> 01:15:09,820
假设用户只输入整数,
assuming that the user is only going to type in integers,

1602
01:15:09,820 --> 01:15:12,970
但是如果我也想支持浮点值,
but if I want to support floating point values too,

1603
01:15:12,970 --> 01:15:15,070
我想我可以稍微调整一下。
I think I can just make a couple of tweaks.

1604
01:15:15,070 --> 01:15:17,270
所以我要回到 VS 代码这里。
So I'm going to go back to VS Code here.

1605
01:15:17,270 --> 01:15:20,890
而不是仅仅将用户的输入 x 和 y 转换为
And instead of just converting the user's input x and y to

1606
01:15:20,890 --> 01:15:23,950
第一行和第二行的整数，让我们做一个简单的更改。
integers on line 1 and 2, let's just make a simple change.

1607
01:15:23,950 --> 01:15:27,400
让我们把它转换成第一行的浮点数
Let's actually convert it to a float on the first line

1608
01:15:27,400 --> 01:15:30,640
第二行有一个浮子。
and a float on the second line here.

1609
01:15:30,640 --> 01:15:35,410
现在我想，如果我到终端窗口运行 Python 的 Calculator.py,
Now I think, if I go down to my terminal window and run Python of Calculator.py,

1610
01:15:35,410 --> 01:15:39,040
让我们输入一个带小数点的数字，比如1.2
let's type in a number like 1.2 with a decimal point

1611
01:15:39,040 --> 01:15:42,100
3.4加上小数点，就是这样。
and 3.4 with a decimal point, and there we go.

1612
01:15:42,100 --> 01:15:44,510
最终答案是4.6。
We have 4.6 as the final answer.

1613
01:15:44,510 --> 01:15:48,250
所以如果我之前只期待整数，那么这个方法就不会成功
So that wouldn't have worked before if I was only expecting integers

1614
01:15:48,250 --> 01:15:51,550
但是现在我期望的是浮点值
from the user, but now that I'm expecting floating point values

1615
01:15:51,550 --> 01:15:56,180
并适应它，我现在实际上也可以做浮点运算了。
and accommodating it, I can actually now do floating point arithmetic as well.

1616
01:15:56,180 --> 01:15:59,020
但假设我真的不想要最终的答案
But suppose that I don't really want the final answer

1617
01:15:59,020 --> 01:16:03,160
像4.6这样的浮点值。
to be a floating point value like 4.6.

1618
01:16:03,160 --> 01:16:05,930
如果我们四舍五入到最接近的整数，我会很高兴。
I would be happy if we just round to the nearest integer.

1619
01:16:05,930 --> 01:16:08,800
所以我想支持用户输入浮点数
So I want to support the user typing in floating point

1620
01:16:08,800 --> 01:16:11,120
都是小数点，但到最后,
values with decimal points, but at the end of the day,

1621
01:16:11,120 --> 01:16:15,760
例如，我只想将结果四舍五入到最接近的整数。
I just want to round the result to the nearest possible integer, for instance.

1622
01:16:15,760 --> 01:16:20,830
事实证明 Python 也内置了一些功能。
Well it turns out that here too Python comes with some functionality built in.

1623
01:16:20,830 --> 01:16:23,620
事实上，如果我们回到之前的 URL
And in fact, if we return to this URL from earlier

1624
01:16:23,620 --> 01:16:26,560
其中列出了所有 Python 内置函数,
wherein all of the Python built-in functions are listed,

1625
01:16:26,560 --> 01:16:29,200
有一种叫做“圆形”
there's one called "round" which does exactly

1626
01:16:29,200 --> 01:16:31,510
正如我们所期望的，它接受一个数字作为输入
as we would expect, it takes as input a number

1627
01:16:31,510 --> 01:16:36,860
然后四舍五入，例如，最接近的整数。
and then rounds it for us, for instance, to the nearest integer.

1628
01:16:36,860 --> 01:16:40,390
但如果我们仔细看看这些文件
But if we look a little closer at that documentation as we can here--

1629
01:16:40,390 --> 01:16:41,710
我会提供一个摘录
I'll provide an excerpt--

1630
01:16:41,710 --> 01:16:45,400
这是函数在文档中的样子。
this is what the function looks like in the documentation.

1631
01:16:45,400 --> 01:16:48,550
回想一下之前我们看过的打印文档
And recall that earlier we looked at the documentation for print

1632
01:16:48,550 --> 01:16:51,550
这是相似的精神，这表明我们不只是
and this is similar in spirit that this shows us not just

1633
01:16:51,550 --> 01:16:54,880
函数的名称，但它的可用参数，即,
the name of the function but its available parameters, that is,

1634
01:16:54,880 --> 01:16:57,850
我们在使用这个函数时可以提供的输入。
inputs that we can provide when using this function.

1635
01:16:57,850 --> 01:17:00,280
但这也有点神秘，就像“印刷”一样,
But this is a little cryptic too, just like Print was,

1636
01:17:00,280 --> 01:17:01,640
它添加了一些语法。
and it adds some syntax.

1637
01:17:01,640 --> 01:17:02,290
让我想想。
So let's see.

1638
01:17:02,290 --> 01:17:04,630
这个函数的名称当然是 Round
The name of this function here is of course Round

1639
01:17:04,630 --> 01:17:07,450
它的第一个参数是一个数字。
and its first argument is a number.

1640
01:17:07,450 --> 01:17:10,548
注意这次没有恒星，没有恒星物体
Notice this time there's no star, there's no star objects

1641
01:17:10,548 --> 01:17:11,590
就像印刷品一样。
like there was for print.

1642
01:17:11,590 --> 01:17:16,000
Round 函数的第一个参数是一个数，句号。
The Round function takes just one number as its first argument, period.

1643
01:17:16,000 --> 01:17:18,820
这是它的位置参数。
That's its positional parameter.

1644
01:17:18,820 --> 01:17:20,420
但请注意这个语法。
But notice this syntax.

1645
01:17:20,420 --> 01:17:22,720
这是编程或技术的惯例
And this is a convention in programming or technology

1646
01:17:22,720 --> 01:17:26,260
更一般地说，一般来说，当你看到方括号
more generally, generally speaking, when you see square brackets

1647
01:17:26,260 --> 01:17:28,630
这样的文件，这意味着你是
and documentation like this, this means that you're

1648
01:17:28,630 --> 01:17:30,370
即将看到一些可有可无的东西。
about to see something optional.

1649
01:17:30,370 --> 01:17:32,350
这意味着如果你想
And so what this means is that if you want

1650
01:17:32,350 --> 01:17:37,480
以更精确地指定要使用整数函数的位数
to specify more precisely the number of digits that you want the round function

1651
01:17:37,480 --> 01:17:43,760
为了四舍五入，您可以在这里通过添加逗号和那个数字来指定它。
to round to, you can specify it here by adding a comma and then that number.

1652
01:17:43,760 --> 01:17:48,190
所以如果我们读了文档如果你没有指定一些数字,
So if we read the documentation, if you don't specify a number of digits,

1653
01:17:48,190 --> 01:17:52,000
只要指定要舍入的数字，它就舍入到最接近的整数。
you just specify the number to round, it rounds to the nearest integer.

1654
01:17:52,000 --> 01:17:55,990
但是假设你想去十分之一的地方，或者百分之一的地方
But suppose you want around to the tenths place, or the hundredths place

1655
01:17:55,990 --> 01:17:58,330
就是小数点后面的一两个数字,
that is one or two digits after the decimal point,

1656
01:17:58,330 --> 01:18:04,167
为了更精确，你可以另外传入逗号1或者2。
you could additionally pass in comma 1 or comma 2 to be more precise.

1657
01:18:04,167 --> 01:18:06,250
文件上是这么说的。
So that's what the documentation, there is saying.

1658
01:18:06,250 --> 01:18:10,460
看看我们能不能把它转换成实际的代码。
Let's see if we can't then translate this to some actual code for us.

1659
01:18:10,460 --> 01:18:13,630
所以如果我现在回到 VS 代码，我考虑
So if I go back now to VS Code and I consider

1660
01:18:13,630 --> 01:18:18,350
我想继续，我可以用几种方法来做。
that I want to go ahead and round x and y, I can do this in a couple of ways.

1661
01:18:18,350 --> 01:18:22,630
我可以做圆周 x + y，但是你知道，我
I could do round x + y, but you know, I'd

1662
01:18:22,630 --> 01:18:25,210
实际上我更喜欢把它分成两行。
actually kind of prefer to break this now out into two lines.

1663
01:18:25,210 --> 01:18:28,300
我不需要，这里有理智的人可能不同意,
I don't have to, and reasonable people here might disagree,

1664
01:18:28,300 --> 01:18:31,330
但是我想回到我打印 z 的场景,
but I'd like to revert to a scenario where I'm printing z,

1665
01:18:31,330 --> 01:18:34,270
这样我就可以对自己，对别人更清楚一点,
so that I can just a little more clearly to myself, to others,

1666
01:18:34,270 --> 01:18:38,890
假设 z = x + y 的四舍五入结果。
say z = the rounded result of x + y.

1667
01:18:38,890 --> 01:18:41,060
这不一定是更好的方法,
It's not necessarily the better way to do it,

1668
01:18:41,060 --> 01:18:44,690
但我更喜欢一个一个说出我的想法,
but I'm a little more comfortable with breaking out my thoughts one at a time,

1669
01:18:44,690 --> 01:18:47,882
特别是如果我想开始注释这些代码块。
especially if I want to start commenting each of these chunks of code.

1670
01:18:47,882 --> 01:18:49,840
好吧，让我下到我的终端窗口
All right, let me go down to my terminal window

1671
01:18:49,840 --> 01:18:52,120
现在运行 Python of Calculator.py。
now and run Python of Calculator.py.

1672
01:18:52,120 --> 01:18:52,840
X 是什么？
What's x?

1673
01:18:52,840 --> 01:18:54,490
我们再做一次1.2。
Let's do 1.2 again.

1674
01:18:54,490 --> 01:18:56,260
那就3.4吧。
Then let's do 3.4.

1675
01:18:56,260 --> 01:18:59,980
之前是4.6，但现在是
And now it was previously 4.6, but now it's

1676
01:18:59,980 --> 01:19:04,540
被四舍五入到最接近的整数，当然是5。
been rounded up to the nearest integer, which of course is going to be 5.

1677
01:19:04,540 --> 01:19:09,050
好吧，如果我想再改变一下呢？
All right, what if I wanted to change this a little further?

1678
01:19:09,050 --> 01:19:11,830
如果我想支持一个大数字呢,
What if I wanted to support maybe really big numbers,

1679
01:19:11,830 --> 01:19:15,872
大数字，不考虑四舍五入，让我们这样做。
big numbers, irrespective of rounding, let's just do something like this.

1680
01:19:15,872 --> 01:19:17,830
让我继续运行 Python 的 Calculator.py
Let me go ahead and run Python of Calculator.py

1681
01:19:17,830 --> 01:19:22,270
再加上999 + 1。
again and let me just add 999 + 1.

1682
01:19:22,270 --> 01:19:25,030
注意，我不需要输入小数点,
And notice, I don't have to type decimal points,

1683
01:19:25,030 --> 01:19:27,340
即使我转换成 float 我的程序
even though I'm converting to float, my program

1684
01:19:27,340 --> 01:19:30,840
只允许我输入小数点，但我不需要强制执行。
will just allow me to type decimal points, but I don't need to oblige.

1685
01:19:30,840 --> 01:19:34,110
答案当然应该是，实际上是1000,
The answer of course here should be, and is in fact, 1,000,

1686
01:19:34,110 --> 01:19:35,670
不管我们是否回头。
whether or not we round.

1687
01:19:35,670 --> 01:19:38,470
这只是整数的算术运算。
So that's just arithmetic with integers here.

1688
01:19:38,470 --> 01:19:44,640
但在美国，我们往往用逗号来格式化长数
But in the US, we tend to format long numbers by putting commas

1689
01:19:44,640 --> 01:19:47,580
每三位数之后或之前。
after or before every triple of digits.

1690
01:19:47,580 --> 01:19:50,660
其他国家则用句号和逗号代替。
Other countries flip it and they use periods and commas instead.

1691
01:19:50,660 --> 01:19:51,660
这是系统设置。
That's a system setting.

1692
01:19:51,660 --> 01:19:53,700
你可以在你自己的 Mac 或 PC 上改变它
You can change that on your own Mac or PC

1693
01:19:53,700 --> 01:19:57,000
或者 Python 或者其他任何语言的设备，但是对我来说，我
or device for Python or any language, but for me, I'm

1694
01:19:57,000 --> 01:20:01,200
这里使用的是美国方法，即小数点的周期
using the US approach here, which is periods for decimal points

1695
01:20:01,200 --> 01:20:02,940
分隔符的逗号。
and commas for separators.

1696
01:20:02,940 --> 01:20:07,890
如果我想输出成1000呢？
What if I wanted this to be outputted as 1,000?

1697
01:20:07,890 --> 01:20:12,180
只是为了更清楚地表明这是1000而不是100。
Just to make it a little more clear that it's 1,000 and not something like 100.

1698
01:20:12,180 --> 01:20:14,580
如果是100万，那就更有用了
That's even more useful when it's like one million--

1699
01:20:14,580 --> 01:20:18,060
一百万。
1,000,000.

1700
01:20:18,060 --> 01:20:19,950
如果我们能自动
Wouldn't it be nice if we could automatically

1701
01:20:19,950 --> 01:20:21,540
也输出这些数字吗？
output those numbers as well?

1702
01:20:21,540 --> 01:20:23,700
事实证明我们可以。
Well, it turns out that we can.

1703
01:20:23,700 --> 01:20:28,410
有一种方法可以使用 Python 来实际指定我们
There is a way using Python to actually specify that we

1704
01:20:28,410 --> 01:20:30,540
希望包含像这样的逗号。
want to include commas like this.

1705
01:20:30,540 --> 01:20:34,800
现在我们有机会把我们的老朋友 F 弦带回来。
And here we have an opportunity to bring back our old friend, the F string.

1706
01:20:34,800 --> 01:20:37,440
首先，让我做一些不那么有成效的事情。
First, let me do something that's not that productive.

1707
01:20:37,440 --> 01:20:38,760
先让我来。
First let me do this.

1708
01:20:38,760 --> 01:20:41,610
让我打印出 z 的值，但是等一下。
Let me print out the value of z, but wait a minute.

1709
01:20:41,610 --> 01:20:44,850
我不能直接说“ z”因为字面意思就是打印 z
I can't just say "z" because that's literally going to print z

1710
01:20:44,850 --> 01:20:45,820
在屏幕上。
on the screen.

1711
01:20:45,820 --> 01:20:49,050
让我像以前一样用那些卷曲的支架把它包起来,
So let me wrap it with those curly braces like I did before,

1712
01:20:49,050 --> 01:20:50,550
但这还不够。
but that too was not enough.

1713
01:20:50,550 --> 01:20:54,060
我需要在字符串的开头加一个 F
I literally needed to add an F at the beginning of my string

1714
01:20:54,060 --> 01:20:56,940
告诉 Python 这是一个 F 字符串，一个格式化的字符串。
to tell Python that this is an F string, a format string.

1715
01:20:56,940 --> 01:21:01,650
现在要打印出来，不是很有趣，只是 z 的值
That now is going to print out, not very interestingly, just the value of z

1716
01:21:01,650 --> 01:21:02,320
本身。
itself.

1717
01:21:02,320 --> 01:21:06,270
所以我会不遗余力地打印 z 实际上我可以
So I'm going to great lengths just to print z when really I could have just

1718
01:21:06,270 --> 01:21:07,890
传递 z 作为唯一的参数。
passed z as the sole argument.

1719
01:21:07,890 --> 01:21:11,820
但为了确保我没有弄坏它，我们再来一次。
But just to ensure that I haven't broken it, let's do this again.

1720
01:21:11,820 --> 01:21:14,190
999 + 1，回车。
999 + 1, Enter.

1721
01:21:14,190 --> 01:21:15,300
好吧，还是1000。
OK, it's still 1,000.

1722
01:21:15,300 --> 01:21:16,950
所以我没有让事情变得更糟。
So I didn't make anything worse.

1723
01:21:16,950 --> 01:21:20,460
但是请注意——不幸的是，这个语法有点神秘——
But notice-- and this syntax is unfortunately a bit cryptic--

1724
01:21:20,460 --> 01:21:22,380
注意到我真的可以做到这一点。
notice that I can actually do this.

1725
01:21:22,380 --> 01:21:27,450
我可以在 z 后面加个冒号，之后加个逗号。
I can put a colon after the z and I can put a comma thereafter.

1726
01:21:27,450 --> 01:21:29,763
这看起来很神秘，不可否认，甚至我
This looks very cryptic, admittedly, and even I

1727
01:21:29,763 --> 01:21:32,430
必须不断地在文档中查找这样的内容
have to constantly look things like this up in the documentation

1728
01:21:32,430 --> 01:21:33,750
记住句法。
to remember the syntax.

1729
01:21:33,750 --> 01:21:35,460
但在这里，让我再运行一次。
But here, let me run it again.

1730
01:21:35,460 --> 01:21:41,250
Python 的 Calculator.py，9991，现在注意
Python of Calculator.py, 999 1 and now notice

1731
01:21:41,250 --> 01:21:43,928
这个号码已经自动为我格式化了。
that the number has been automatically formatted for me.

1732
01:21:43,928 --> 01:21:45,720
如果我在另一个国家或地区,
If I were in a different country or locale,

1733
01:21:45,720 --> 01:21:49,620
我完全可以覆盖这一点，使用句点而不是逗号或老虎钳
I could absolutely override this to use periods instead of commas or vise

1734
01:21:49,620 --> 01:21:50,290
反之亦然。
versa.

1735
01:21:50,290 --> 01:21:52,990
但在这种情况下，它只是自动发生在我身上。
But in this case here, it's just happening for me automatically.

1736
01:21:52,990 --> 01:21:56,310
因此，我们也看到了一个真正格式化字符串意味着什么的提示。
So there too we see a hint of what it means to really format a string.

1737
01:21:56,310 --> 01:21:57,720
还有更大的能量
There's even more power--

1738
01:21:57,720 --> 01:22:00,633
内置更强大的能力。
more powerful capabilities built into that.

1739
01:22:00,633 --> 01:22:02,550
好吧，我暂停一下看看有没有
All right, let me pause here to see if there's

1740
01:22:02,550 --> 01:22:10,200
关于浮点数、四舍五入或 F 字符串的使用的任何问题。
any questions now on floats, on rounding, or on this use of F strings.

1741
01:22:10,200 --> 01:22:11,700
观众: 是的，我有一个问题。
AUDIENCE: Yes, so I have a question.

1742
01:22:11,700 --> 01:22:14,760
所以当使用花车时，是否有一个帽子
So when using floats, is there like a cap

1743
01:22:14,760 --> 01:22:16,860
它能有多少个小数点？
to how many decimal points it can have?

1744
01:22:16,860 --> 01:22:18,360
大卫 · 马兰: 一个非常好的问题。
DAVID MALAN: A really good question.

1745
01:22:18,360 --> 01:22:21,150
所以，浮动，是的，这是一个问题，我们不久将重新讨论。
So floats, yes, and this is a problem we'll revisit before long.

1746
01:22:21,150 --> 01:22:25,590
Floats 不能无限精确地表示数字。
Floats cannot represent numbers infinitely precisely.

1747
01:22:25,590 --> 01:22:28,112
简而言之，因为计算机只有这么多内存。
In a nutshell, because computers only have so much memory.

1748
01:22:28,112 --> 01:22:29,820
他们只有有限的内存。
They only have a finite amount of memory.

1749
01:22:29,820 --> 01:22:34,200
你和我在电脑里的硬件数量是有限的,
You and I only have a finite amount of hardware inside of the computer,

1750
01:22:34,200 --> 01:22:36,540
所以在某个时候，他们必须要转过来。
so at some point, they're going to have to round.

1751
01:22:36,540 --> 01:22:38,190
现在我在自动巡视。
Right now I'm rounding automatically.

1752
01:22:38,190 --> 01:22:40,732
实际上，计算机最终将不得不为我们做到这一点,
Effectively computers will eventually have to do that for us,

1753
01:22:40,732 --> 01:22:44,010
但我们很快就会发现这是一个根本性的问题。
but we'll see that as a fundamental problem before long.

1754
01:22:44,010 --> 01:22:47,385
请允许我回过头来看浮动的最后几个例子
Allow me to turn back just for a few final examples on float

1755
01:22:47,385 --> 01:22:50,010
在我们介绍一些最后的例子之前
before we introduce a few final examples that allow us not just

1756
01:22:50,010 --> 01:22:52,290
使用函数，但使我们自己。
to use functions, but to make our own.

1757
01:22:52,290 --> 01:22:56,940
让我提议，我们也尝试在这里的一点分裂我们的手。
Let me propose that we also try our hands at a bit of division here.

1758
01:22:56,940 --> 01:22:59,250
让我提议我们现在修改这个计算器
Let me propose that we modify this calculator now

1759
01:22:59,250 --> 01:23:01,740
还有几辆花车，不过我们现在就开始吧
to still take a couple of floats, but let's now just do

1760
01:23:01,740 --> 01:23:04,050
简单一点的东西
something a little simpler than--

1761
01:23:04,050 --> 01:23:07,085
和这个有点不同，只是做 x 除以 y。
a little different from this, just doing x divided by y.

1762
01:23:07,085 --> 01:23:09,210
让我继续，去掉我的格式字符串
And let me go ahead and get rid of my format string

1763
01:23:09,210 --> 01:23:12,383
暂时保持简单，打印出 z。
and just keep it simple for now, printing out z instead.

1764
01:23:12,383 --> 01:23:13,800
我们在这里会看到什么？
And what are we going to see here?

1765
01:23:13,800 --> 01:23:15,092
只是一些简单的划分。
Well just some simple division.

1766
01:23:15,092 --> 01:23:19,920
那么 Python 的 Calculator.py，让我们做一个类似2除以3的运算,
So Python of Calculator.py, let's do something like 2 divided by 3,

1767
01:23:19,920 --> 01:23:21,960
当然我得到0.66666。
and of course I get 0.66666.

1768
01:23:21,960 --> 01:23:25,600
对于刚才伊森的问题，它似乎是有限的。
And to Ethan's question a moment ago, it does seem to be finite.

1769
01:23:25,600 --> 01:23:30,180
这里的舍入方式并不奇怪，但我似乎只看到这么多数字。
It's not rounding in a weird way here, but I only seem to see so many digits.

1770
01:23:30,180 --> 01:23:34,170
这就是以这种方式使用浮点数的必然性。
That's an inevitability of using a float in this way.

1771
01:23:34,170 --> 01:23:37,620
相比之下，正如您所知，现在 Python 中的整数
By contrast, just so you know, integers nowadays in Python

1772
01:23:37,620 --> 01:23:39,690
你想要多大就有多大。
can be as big as you want them to be.

1773
01:23:39,690 --> 01:23:41,910
与其他语言不同，它没有上限
Unlike other languages, there is no upper bound

1774
01:23:41,910 --> 01:23:44,550
现在在 Python 中 INT 可以有多大，但是
on how big an INT can be now in Python, but there

1775
01:23:44,550 --> 01:23:48,225
是浮点值的精确度的界限。
is a bound on just how precise a floating point value can be.

1776
01:23:48,225 --> 01:23:50,850
好了，现在我有了一个简单的部门,
All right, now that I've got some simple division working here,

1777
01:23:50,850 --> 01:23:52,380
我们绕过去吧。
let's go ahead and round this.

1778
01:23:52,380 --> 01:23:57,060
把这个非常长的数字0.6666666舍去会很好，以此类推
It would be nice to round this really long number 0.6666666 and so forth

1779
01:23:57,060 --> 01:23:59,190
也许只有小数点后两位。
to maybe just two decimal places.

1780
01:23:59,190 --> 01:24:02,460
不过，我们已经看到了如何使用 round 来实现这一点，至少在其文档中已经看到了。
We've seen how to do this with round, though, at least in its documentation.

1781
01:24:02,460 --> 01:24:04,980
我们不要把这个问题归结为最接近的智力问题,
Let's just round this not to the nearest INT,

1782
01:24:04,980 --> 01:24:09,810
通过传入 x 除以 y 这是一个参数，一旦数学
by passing in just x divided by y, which is one argument, once the math is

1783
01:24:09,810 --> 01:24:13,350
在括号内完成，我不想只传递一个参数。
done inside of the parentheses, I don't want to pass in just one argument.

1784
01:24:13,350 --> 01:24:17,100
我想传入2这样我就可以指定 n 个数字,
I want to pass in two so that I can specify n digits,

1785
01:24:17,100 --> 01:24:21,030
数字的个数，这是 round 的第二个参数。
number of digits, which you'll recall was the second parameter for round.

1786
01:24:21,030 --> 01:24:23,240
让我继续运行 Python 的 Calculator.py。
Let me go ahead and run Python of Calculator.py.

1787
01:24:23,240 --> 01:24:24,240
我也会这么做
I'll do the same thing--

1788
01:24:24,240 --> 01:24:27,300
2然后是30.67。
2 and then 3, 0.67.

1789
01:24:27,300 --> 01:24:31,130
这里我们也看到了一种舍入的方法不仅仅是舍入最近的整数,
So here too we see a way of rounding now, not just to a nearest integer,

1790
01:24:31,130 --> 01:24:34,160
而是一个最接近的数字。
but to a nearest number of digits.

1791
01:24:34,160 --> 01:24:36,300
但还有另一种方法。
But there's another way to do this here.

1792
01:24:36,300 --> 01:24:40,920
事实上，这又让我们想起了 F 字符串的例子。
And in fact, this evokes our F string example again.

1793
01:24:40,920 --> 01:24:42,270
让我先把这个换了。
Let me go ahead and change this.

1794
01:24:42,270 --> 01:24:45,740
假设您不记得 round 函数，或者由于某种原因,
Suppose that you didn't remember the round function or, for some reason,

1795
01:24:45,740 --> 01:24:46,940
你不想用它。
you didn't want to use it.

1796
01:24:46,940 --> 01:24:49,340
相反，您只需要使用一个格式化字符串。
You instead want to just use a format string.

1797
01:24:49,340 --> 01:24:50,510
好吧，我们去那里。
Well, let's go there.

1798
01:24:50,510 --> 01:24:55,280
让我做“ z”但是让我用那些卷曲的支架把它包起来。
Let me do "z" but let me surround it with those curly braces.

1799
01:24:55,280 --> 01:24:58,850
让我在开头加上 F，再说一遍，这还不是很有趣。
Let me add the F at the beginning, and again, this is not interesting yet.

1800
01:24:58,850 --> 01:25:02,300
这只是打印出 z，但我增加了更多的复杂性
This is just going to print out z, but I'm adding a lot more complexity

1801
01:25:02,300 --> 01:25:03,920
把它变成 F 字符串。
to turn it into an F string.

1802
01:25:03,920 --> 01:25:08,940
但是请注意，我可以在变量名后面，冒号后面做其他事情。
But notice I can do something else after my variable name, after the colon.

1803
01:25:08,940 --> 01:25:11,300
如果这是一个大整数,
If this were going to be a big integer, I

1804
01:25:11,300 --> 01:25:15,200
可能需要像前面那样用逗号来分隔每个三重数
might want to use a comma like before to separate each triple of numbers

1805
01:25:15,200 --> 01:25:15,950
用逗号。
with commas.

1806
01:25:15,950 --> 01:25:16,580
但我没有。
But I don't.

1807
01:25:16,580 --> 01:25:20,120
我将使用不同的字符序列。
I'm going to use a different sequence of characters.

1808
01:25:20,120 --> 01:25:25,190
我会说0.2 F，这也是我得到的非常神秘的东西之一
I'm going to say 0.2F and this too is one of these very cryptic things I have

1809
01:25:25,190 --> 01:25:28,040
经常抬头看，因为我忘了如果我不经常使用它。
to constantly look up because I forget if I don't use it that often.

1810
01:25:28,040 --> 01:25:32,030
所以如果这看起来特别奇怪，不要害怕，但这是,
So don't be intimidated if this looks especially weird, but this is,

1811
01:25:32,030 --> 01:25:33,950
根据文件记录
according to the documentation, the way you

1812
01:25:33,950 --> 01:25:37,830
使用 F 字符串指定要打印的数字数量。
specify using an F string how many digits you want to print.

1813
01:25:37,830 --> 01:25:39,980
让我运行这个版本的计算器。
So let me run this version of the calculator.

1814
01:25:39,980 --> 01:25:43,170
输入2和3得到的结果一模一样。
Type in 2 and then 3, we get the exact same thing.

1815
01:25:43,170 --> 01:25:45,350
但是，这和我的说法是一致的
But again, this is just consistent with my claim

1816
01:25:45,350 --> 01:25:49,580
在编程中，我们经常可以解决同样的问题
that in programming we can so very often solve the same problem

1817
01:25:49,580 --> 01:25:51,030
在很多方面。
in multiple ways.

1818
01:25:51,030 --> 01:25:56,240
这就是 F 字符串方法来解决同样的问题。
This is just now the F string approach to that very same problem.

1819
01:25:56,240 --> 01:25:57,630
好吧，哪个更好？
All right, which one is better?

1820
01:25:57,630 --> 01:25:58,310
看情况。
It depends.

1821
01:25:58,310 --> 01:26:00,200
在这种情况下，它们是非常相似的。
In this case, they're pretty equivalent.

1822
01:26:00,200 --> 01:26:03,260
不过，您可以想象，有时候使用一个函数是有用的
You can imagine, though, it being useful to use a function sometimes

1823
01:26:03,260 --> 01:26:07,340
这样你就可以传入一个像 n 位数这样的参数作为第二个参数,
so that you can pass in an argument like n digits as that second argument,

1824
01:26:07,340 --> 01:26:10,700
或者你可以想象提前决定你想要0.2
or you can imagine just deciding in advance that you want 0.2

1825
01:26:10,700 --> 01:26:13,370
然后像这样写。
and then writing it like this.

1826
01:26:13,370 --> 01:26:17,300
现在让我们从关注字符串和整数过渡到
Let's transition now from focusing on strings and on integers and on

1827
01:26:17,300 --> 01:26:19,880
现在将重点放在函数本身上。
floats to focusing now on functions themselves.

1828
01:26:19,880 --> 01:26:21,860
我们从今天开始关注如何
We began today by focusing on how you can

1829
01:26:21,860 --> 01:26:24,230
使用 Python 附带的函数。
use functions that come with Python.

1830
01:26:24,230 --> 01:26:26,990
但如果你能发明自己的函数,
But wouldn't it be nice if you could invent your own functions,

1831
01:26:26,990 --> 01:26:29,330
特别是如果，就我们之前的观点，你发现
especially if, to our point earlier, you find

1832
01:26:29,330 --> 01:26:32,210
一次又一次地解决同样的问题？
yourself solving the same kind of problem again and again?

1833
01:26:32,210 --> 01:26:34,700
Python 附带了 print 函数，这很好
It's nice that Python comes with the print function

1834
01:26:34,700 --> 01:26:37,130
因为能够在屏幕上打印东西真的很有用,
because it's really useful to be able to print things on the screen,

1835
01:26:37,130 --> 01:26:40,130
但是如果你能在屏幕上打印出特定的东西，那该多好啊
but wouldn't it be nice if you could print specific things on the screen

1836
01:26:40,130 --> 01:26:42,170
调用你自己的函数？
by just calling your own function?

1837
01:26:42,170 --> 01:26:44,100
我提议我们这么做。
Well let me propose that we do this.

1838
01:26:44,100 --> 01:26:49,760
让我回到 VS 代码这里，让我提议我们回到 Hello.py。
Let me go back to VS Code here and let me propose that we go back to Hello.py.

1839
01:26:49,760 --> 01:26:52,820
我要重新打开我们之前放在那里的 Hello. py
I'm going to reopen Hello.py where we left it before

1840
01:26:52,820 --> 01:26:54,620
我现在要向你求婚了
and I'm going to go ahead now and propose

1841
01:26:54,620 --> 01:26:58,460
我们考虑如何开始进一步改善这个问题
that we consider how we can start improving this further by making

1842
01:26:58,460 --> 01:26:59,330
我们自己的功能。
our own function.

1843
01:26:59,330 --> 01:27:03,380
我今天写了很多程序，只是说你好
I have written so many programs today that just say Hello

1844
01:27:03,380 --> 01:27:05,360
每次我使用打印。
and each time I'm using print.

1845
01:27:05,360 --> 01:27:08,090
但如果从今天开始,
But wouldn't it have been nice if, from the beginning of today,

1846
01:27:08,090 --> 01:27:12,620
我们可以只调用一个名为 Hello 的函数，它只为我们表示 Hello？
we could just call a function called Hello that just says Hello for us?

1847
01:27:12,620 --> 01:27:15,080
而几年前 Python 的作者却没有
Now the authors of Python years ago didn't

1848
01:27:15,080 --> 01:27:18,020
认为我们需要一个特殊的函数来说 Hello,
think that we need a special function just to say Hello,

1849
01:27:18,020 --> 01:27:19,820
但我希望那样的生活存在。
but I would like that to exist.

1850
01:27:19,820 --> 01:27:21,980
我说了这么多次你好，我只是想
I'm saying Hello so many times, I just want

1851
01:27:21,980 --> 01:27:23,600
能够调用函数 Hello。
to be able to call a function Hello.

1852
01:27:23,600 --> 01:27:25,550
所以我要从头开始。
So I'm going to start from scratch here.

1853
01:27:25,550 --> 01:27:27,680
我要删除之前的所有代码
I'm going to delete all of my code from earlier

1854
01:27:27,680 --> 01:27:32,510
假设有一个名为 Hello 的函数存在。
and I'm going to pretend for the moment that a function called Hello exists.

1855
01:27:32,510 --> 01:27:34,250
我要像以前一样。
And I'm going to do just as I did before.

1856
01:27:34,250 --> 01:27:36,740
我将通过输入函数得到用户名,
I'm going to get the user's name with the input function,

1857
01:27:36,740 --> 01:27:39,110
问你叫什么，问号。
asking what's your name, question mark.

1858
01:27:39,110 --> 01:27:42,230
现在我要调用一个函数 Hello
And now I'm going to call a function Hello

1859
01:27:42,230 --> 01:27:45,260
然后打印出用户名。
and then I'm going to print out the user's name.

1860
01:27:45,260 --> 01:27:50,190
现在我承认，你好不存在，所以坏事就要发生了,
Now I will admit, Hello doesn't exist, so bad things are about to happen,

1861
01:27:50,190 --> 01:27:51,440
但是让我们看看。
but let's see what.

1862
01:27:51,440 --> 01:27:53,210
让我下到我的终端窗口。
Let me go down to my terminal window.

1863
01:27:53,210 --> 01:27:55,700
让我运行 Python of Hello.py。
Let me run Python of Hello.py.

1864
01:27:55,700 --> 01:27:59,030
我觉得第一句台词应该没问题，因为之前这招很管用。
I think the first line is going to be OK because that worked before.

1865
01:27:59,030 --> 01:28:01,280
事实上，它提醒了我的名字。
And indeed, it's prompting me for my name.

1866
01:28:01,280 --> 01:28:02,780
让我输入大卫。
So let me type in David.

1867
01:28:02,780 --> 01:28:05,090
第二行代码显然在调用
The second line of code is apparently calling

1868
01:28:05,090 --> 01:28:08,840
一个看起来像 Hello 的函数，因为它为什么是一个函数？
a function that looks like it's called Hello, because why is it a function?

1869
01:28:08,840 --> 01:28:11,820
它有一个括号和紧随其后的一个闭括号。
It has a parenthesis and a closed parenthesis immediately after it.

1870
01:28:11,820 --> 01:28:14,300
我们使用的每个函数都是这样的。
And that's what every function we've used has looked like.

1871
01:28:14,300 --> 01:28:16,340
但 Python 不会认出这个的。
But Python is not going to recognize this one.

1872
01:28:16,340 --> 01:28:18,890
当我现在按下 Enter 键时，我得到一个名称错误。
When I hit Enter now, I get a name error.

1873
01:28:18,890 --> 01:28:21,950
名字“你好”没有定义，你的意思是帮助吗？
Name "Hello" is not defined, did you mean Help?

1874
01:28:21,950 --> 01:28:26,120
我没有，虽然我现在需要的是一些帮助,
I didn't, although it's opportune that's what I need at this point is some help,

1875
01:28:26,120 --> 01:28:29,540
但是我遇到这个错误是因为什么呢？
but I am encountering this error because why?

1876
01:28:29,540 --> 01:28:31,440
这个函数根本不存在。
The function just doesn't exist.

1877
01:28:31,440 --> 01:28:33,350
那么如何使这个函数存在呢？
So how do I make this function exist?

1878
01:28:33,350 --> 01:28:39,440
我需要创建它自己使用这个关键字，DEF，DEF 的定义。
Well I need to create it myself using this key word, DEF, DEF for define.

1879
01:28:39,440 --> 01:28:43,610
正如 STR 是字符串的简称 INT 是整数的简称一样,
So here too, just as STR is short for string and INT is short for integer,

1880
01:28:43,610 --> 01:28:45,830
dEF 是定义的简称。
DEF is short for define.

1881
01:28:45,830 --> 01:28:50,330
如果你想定义，创建，发明你自己的函数,
If and when you want to define, create, invent your own functions,

1882
01:28:50,330 --> 01:28:53,870
您现在可以使用 Python 中的这个关键字来完成此操作。
you can do so using now this keyword in Python.

1883
01:28:53,870 --> 01:28:58,310
那么让我们回到我的代码这里，让我提议我们定义这个
So let me go back to my code here and let me propose that we define this

1884
01:28:58,310 --> 01:28:59,900
也许是这样。
perhaps in this way.

1885
01:28:59,900 --> 01:29:02,660
在我的档案的最上面，我将首先
At the very top of my file, I'm going to first take

1886
01:29:02,660 --> 01:29:05,150
定义一个名为 Hello 的函数的时间
a moment to define a function called Hello

1887
01:29:05,150 --> 01:29:10,430
使用 DEF Hello，开括号，闭括号，冒号。
using DEF Hello, open parenthesis, close parenthesis, colon.

1888
01:29:10,430 --> 01:29:15,110
这意味着 Python 将处理每一行代码
What this means now is that Python is going to treat every line of code

1889
01:29:15,110 --> 01:29:20,240
我在这个下面缩进，作为这个新函数 Hello 的意思。
that I indent underneath this one as the meaning of this new function, Hello.

1890
01:29:20,240 --> 01:29:23,030
因此 DEF 和空间一样重要。
So DEF is important as is the space.

1891
01:29:23,030 --> 01:29:26,577
我可以选择函数的名称我选择称它为 Hello。
I get to choose the name of the function and I'm choosing to call it Hello.

1892
01:29:26,577 --> 01:29:29,660
没有内容的括号表示这个函数现在
The parentheses with nothing inside means that this function at the moment

1893
01:29:29,660 --> 01:29:32,540
不需要任何输入，也没有争论。
is not going to take any inputs, no arguments there too.

1894
01:29:32,540 --> 01:29:35,810
冒号的意思是，请继续关注缩进。
The colon means, stay tuned for some indentation.

1895
01:29:35,810 --> 01:29:38,750
这行代码下面缩进的所有东西
Everything that's indented beneath this line of code

1896
01:29:38,750 --> 01:29:40,310
是这个函数的一部分。
is going to be part of this function.

1897
01:29:40,310 --> 01:29:42,920
这将是一个非常简短的函数——一行代码——
It's going to be a super short function-- one line of code--

1898
01:29:42,920 --> 01:29:46,040
它只会打印出“你好”
it's just going to print out "Hello."

1899
01:29:46,040 --> 01:29:51,830
但是现在在第1行和第2行，我已经发明了自己的函数 Hello。
But now on lines 1 and 2, I have invented my own function Hello.

1900
01:29:51,830 --> 01:29:54,740
注意这些神奇地出现在这里的点。
Notice these dots that have now magically appeared here.

1901
01:29:54,740 --> 01:29:56,660
这只是我的文本编辑器的一个设置,
This is just a setting of my text editor,

1902
01:29:56,660 --> 01:30:00,470
在这种情况下 VS 代码，这只是让我超级明确，我已经
VS Code in this case, that's just making super explicit to me that I've

1903
01:30:00,470 --> 01:30:04,160
按空格键四次，或者按 Tab 键一次,
hit the space bar four times, or equivalently the Tab key once,

1904
01:30:04,160 --> 01:30:07,018
它会自动转换成四个空格。
which is converted automatically to four spaces.

1905
01:30:07,018 --> 01:30:10,310
一般来说，我需要确保所有缩进的代码
Generally speaking, I'm going to need to make sure that all of my indented code

1906
01:30:10,310 --> 01:30:14,150
这样 Python 就知道它们都是同一个东西的一部分。
lines up now so that Python knows that it's all part of the same thing.

1907
01:30:14,150 --> 01:30:16,770
但在这种情况下很容易，因为它只是一条线。
But it's easy in this case because it's just a single line.

1908
01:30:16,770 --> 01:30:20,810
但是现在，由于行1和行2，函数 Hello
But now, thanks to lines 1 and 2, the function Hello

1909
01:30:20,810 --> 01:30:24,920
当我准备好在第6行使用它时，它将绝对存在。
will absolutely exist when I'm ready to use it on line 6.

1910
01:30:24,920 --> 01:30:29,180
那么让我下到我的终端窗口，运行 Python of Hello.py，Enter。
So let me go down to my terminal window and run Python of Hello.py, Enter.

1911
01:30:29,180 --> 01:30:30,570
我的名字又来了。
Here comes my name again.

1912
01:30:30,570 --> 01:30:35,120
现在当我按回车键时，我看到你好，大卫。
And now when I hit Enter, I now see Hello, David.

1913
01:30:35,120 --> 01:30:37,190
好吧，我们有点倒退了，对吧？
All right, we've kind of regressed though, right?

1914
01:30:37,190 --> 01:30:39,960
这里已经不像以前那么漂亮了。
This is not nearly as pretty as it once was.

1915
01:30:39,960 --> 01:30:44,840
我认为我们可以通过进一步改进来做得更好。
I think we can probably do better than this by improving things further.

1916
01:30:44,840 --> 01:30:47,510
为什么我们不考虑一下，我们该怎么做呢
Why don't we consider, though, how we might

1917
01:30:47,510 --> 01:30:50,480
把这个函数参数化？
say parameterize this same function?

1918
01:30:50,480 --> 01:30:55,010
也就是说，我们是否可以定制 Hello，将用户名作为输入
That is to say, can we customize Hello to maybe take the user's name as input

1919
01:30:55,010 --> 01:31:00,020
这样我们就可以说，不仅 Hello，而且人的名字都在一行，所有
so that we can say, not only Hello, but the person's name all on one line, all

1920
01:31:00,020 --> 01:31:01,070
一口气？
in one breath?

1921
01:31:01,070 --> 01:31:02,450
我觉得我们能做到。
Well I think we can do this.

1922
01:31:02,450 --> 01:31:05,400
让我提议我们这样做。
Let me propose that we do this as follows.

1923
01:31:05,400 --> 01:31:10,100
让我继续往上写代码让我进入这些括号,
Let me go ahead and up in my code, let me inside of these parentheses,

1924
01:31:10,100 --> 01:31:12,350
让我想出我自己的参数名。
let me come up with my own parameter name.

1925
01:31:12,350 --> 01:31:14,510
我有完全的选择，我要走了
I have complete choice here and I'm going

1926
01:31:14,510 --> 01:31:17,780
表示参数的名称将为“ To”。
to say that the name of my parameter will be the word To.

1927
01:31:17,780 --> 01:31:18,500
为什么？
Why?

1928
01:31:18,500 --> 01:31:22,970
因为我希望我的函数听起来像它代表的动词
Because I want my function to sound like the verb it represents--

1929
01:31:22,970 --> 01:31:23,690
你好。
Hello.

1930
01:31:23,690 --> 01:31:25,610
但你想跟谁打招呼呢？
But who do you want to say Hello to?

1931
01:31:25,610 --> 01:31:27,860
我要调用这个函数的参数
Well I'm going to call my parameter for this function

1932
01:31:27,860 --> 01:31:30,860
对，只是因为在英语里，听起来不错。
To, just because in English, it kind of sounds nice to me.

1933
01:31:30,860 --> 01:31:32,900
你好，你想和谁打招呼？
Hello To, who do you want to say Hello to?

1934
01:31:32,900 --> 01:31:36,050
所以我把这个参数调用为 To
That's why I'm calling this parameter To instead of something

1935
01:31:36,050 --> 01:31:38,360
像 x，y，z 一样简单。
simpler like x or y or z.

1936
01:31:38,360 --> 01:31:40,798
好吧，那我该怎么处理“到”这个词呢？
All right, well what do I want to do with the word To?

1937
01:31:40,798 --> 01:31:42,590
我可以做一些不同的事情。
Well I can do a couple of different things.

1938
01:31:42,590 --> 01:31:45,320
我们已经看到了很多实现 Hello 的不同方法。
We've seen like so many different ways to implement Hello.

1939
01:31:45,320 --> 01:31:48,000
为了方便语法，我在这里加个逗号。
Let me just add a comma there for grammar's sake.

1940
01:31:48,000 --> 01:31:52,700
然后让我把“ To”放在后面作为第二个论点
And then let me put the word To after that as the second argument

1941
01:31:52,700 --> 01:31:53,715
你好。
to the function Hello.

1942
01:31:53,715 --> 01:31:56,090
还有其他办法，我们见过很多办法,
There's other ways we can do this and we've seen so many,

1943
01:31:56,090 --> 01:31:58,940
但我觉得这个看起来有点清楚。
but this one looks a little clear to me, I'll say.

1944
01:31:58,940 --> 01:32:00,380
接下来会发生什么？
What's going to happen next?

1945
01:32:00,380 --> 01:32:03,470
我觉得我不需要这条额外的打印线。
Well I don't think I need this extra print line here.

1946
01:32:03,470 --> 01:32:07,040
我想我要做的是，我要在这里继续
I think what I'm going to do is this, I'm going to go ahead here

1947
01:32:07,040 --> 01:32:12,740
而不是手动打印出这个人的名字，我会说,
and print out not the person's name manually, I'm going to instead say,

1948
01:32:12,740 --> 01:32:15,410
你好，括号中的名字。
Hello parentheses name.

1949
01:32:15,410 --> 01:32:16,880
那我现在在做什么？
So what am I now doing?

1950
01:32:16,880 --> 01:32:20,690
在第1行和第2行，我定义了我自己的函数 Hello,
On lines 1 and 2 I'm defining my very own function called Hello,

1951
01:32:20,690 --> 01:32:23,240
但是这次，这个功能已经被设计出来了
but this time that function has been designed

1952
01:32:23,240 --> 01:32:26,750
以一个参数，一个单独的参数作为输入。
to take a parameter, a single parameter, as input.

1953
01:32:26,750 --> 01:32:29,810
我使用这个参数的值
And I'm using the value of that parameter which

1954
01:32:29,810 --> 01:32:33,470
我打电话到插入打印，使我不仅看到
I called To to plug into print so that I see not only

1955
01:32:33,470 --> 01:32:35,780
你好，还有那个人的名字。
Hello but also that person's name.

1956
01:32:35,780 --> 01:32:37,070
我在5号线上做什么？
What am I doing on line 5?

1957
01:32:37,070 --> 01:32:39,140
和往常一样，我只是得到用户名。
Same as always, I'm just getting the user's name.

1958
01:32:39,140 --> 01:32:42,140
6号线，我不只是打电话给你，我是路过的
Line 6, I'm not only calling Hello, I'm passing

1959
01:32:42,140 --> 01:32:46,500
作为参数输入 name 变量
as input the name variable as an argument

1960
01:32:46,500 --> 01:32:48,912
所以这就是传递给 Hello 的东西。
so that that's what gets passed into Hello.

1961
01:32:48,912 --> 01:32:50,870
这里发生的事情本质上是这样的
And what's happening here is essentially this--

1962
01:32:50,870 --> 01:32:54,710
即使这个变量在这里被称为 Name，当函数
even though the variable is called Name here, when the function

1963
01:32:54,710 --> 01:33:00,920
则计算机假定相同的值现在被调用。
itself is called, the computer assumes that same value is now called To.

1964
01:33:00,920 --> 01:33:04,760
因此 Name 实际上被复制到另一个名为
So Name is essentially copied to another variable called

1965
01:33:04,760 --> 01:33:11,420
这样，在 Hello 的上下文中，我可以对该变量说 Hello。
To so that in the context of Hello, I can say Hello to that variable instead.

1966
01:33:11,420 --> 01:33:15,140
我们马上就会知道，如果我们不把这些都弄清楚会发生什么。
And we'll see in a moment what happens if we don't keep those straight.

1967
01:33:15,140 --> 01:33:17,600
让我继续运行 Python of Hello.py，Enter。
Let me go ahead and run Python of Hello.py, Enter.

1968
01:33:17,600 --> 01:33:18,540
你叫什么名字？
What's your name?

1969
01:33:18,540 --> 01:33:20,060
现在我祈祷吧。
And now I'm crossing my fingers.

1970
01:33:20,060 --> 01:33:20,840
进来。
Enter.

1971
01:33:20,840 --> 01:33:21,750
好了。
There we go.

1972
01:33:21,750 --> 01:33:25,700
我们重新开始了，但是现在我有了自己的定制函数 Hello
We're back in business, but now I have my own custom function called Hello

1973
01:33:25,700 --> 01:33:28,550
这样我就可以跟特定的人打招呼了。
that's allowing me to say Hello to a specific person.

1974
01:33:28,550 --> 01:33:30,980
现在事情可以变得很有趣了。
And here's where now things can get really fancy.

1975
01:33:30,980 --> 01:33:34,220
如果希望 Hello 函数对某个特定的人说 Hello,
What if you wanted your Hello function to say Hello to someone specific,

1976
01:33:34,220 --> 01:33:37,070
但是，你知道吗如果你不知道你想跟谁打招呼,
but, you know what, if you don't know who you want to say Hello to,

1977
01:33:37,070 --> 01:33:38,840
你想向全世界问好,
you want to say Hello to the whole world,

1978
01:33:38,840 --> 01:33:41,300
可以为参数提供默认值。
you can give parameters default values.

1979
01:33:41,300 --> 01:33:42,060
我们已经看到了。
We've seen that.

1980
01:33:42,060 --> 01:33:45,530
回想一下，对于 print，SEP 有一个默认值,
Recall that with print there was a default value for SEP,

1981
01:33:45,530 --> 01:33:46,550
分离器。
for the separator.

1982
01:33:46,550 --> 01:33:49,700
END 有一个默认值，行结束。
There was a default value for END, the line ending.

1983
01:33:49,700 --> 01:33:52,280
我们也可以这样做，这里是语法。
We can do that too, and here's the syntax.

1984
01:33:52,280 --> 01:33:56,390
如果希望默认情况下获取此参数的值,
If you want the value of this parameter by default,

1985
01:33:56,390 --> 01:34:00,620
如果不是程序员提供的，等于“世界”
if not provided by the programmer, to be equal to "world,"

1986
01:34:00,620 --> 01:34:05,155
你可以在定义函数的同一行中这样做。
you literally do that in the same line you're defining the function.

1987
01:34:05,155 --> 01:34:07,280
我承认，这看起来越来越神秘了,
And I'll admit, it's starting to look more cryptic,

1988
01:34:07,280 --> 01:34:10,580
但我仍然只是定义了一个名为 Hello，it 的函数
but I'm still just defining a function called Hello, it

1989
01:34:10,580 --> 01:34:13,820
接受一个名为 To 的参数，但我正在赋值它
takes a parameter called To, but I'm assigning it

1990
01:34:13,820 --> 01:34:19,340
等号为“ world”的默认值，以防程序员
with the equal sign a default value of "world," just in case the programmer

1991
01:34:19,340 --> 01:34:22,310
不会用争吵来打电话给 Hello。
doesn't call Hello with an argument.

1992
01:34:22,310 --> 01:34:23,660
我们可以在这里看到。
And we can see this here.

1993
01:34:23,660 --> 01:34:26,750
让我用两种方式更改代码以使用 Hello。
Let me change my code to use Hello in two ways.

1994
01:34:26,750 --> 01:34:31,880
在第5行，我将非常简单地调用 Hello，没有参数。
On line 5, I'm going to very simply call Hello, no arguments.

1995
01:34:31,880 --> 01:34:33,710
然后在第六行，我会得到名字。
Then on line 6, I'm going to get the name.

1996
01:34:33,710 --> 01:34:36,320
第7行，我将用一个参数调用 Hello。
Line 7, I'm going to call Hello with an argument.

1997
01:34:36,320 --> 01:34:39,060
所以您将看到 Hello 现在有两种用法。
So you'll see Hello now being used in two ways.

1998
01:34:39,060 --> 01:34:41,960
让我继续运行 Python of Hello.py。
Let me go ahead and run Python of Hello.py.

1999
01:34:41,960 --> 01:34:43,310
我输入我的名字。
I'll type in my name.

2000
01:34:43,310 --> 01:34:44,630
有意思。
Oh, interesting.

2001
01:34:44,630 --> 01:34:47,120
注意，我已经看到了 Hello，world，但那是
Notice I already see Hello, world, but that's

2002
01:34:47,120 --> 01:34:52,070
因为第5行发生在第6行之前，但是一旦我键入我的名字,
expected because line 5 happens before line 6, but once I type my name,

2003
01:34:52,070 --> 01:34:55,940
现在节目要更有礼貌一点，跟我打个招呼
now the program is going to be a little more polite and say hello to me

2004
01:34:55,940 --> 01:34:57,180
私下里。
personally.

2005
01:34:57,180 --> 01:35:01,550
因此，我们看到了相对简单但新的语法
So there too, we see with relatively simple but new syntax

2006
01:35:01,550 --> 01:35:05,990
你如何实现功能非常相似的精神打印
how you can implement functionality very similar in spirit to what the print

2007
01:35:05,990 --> 01:35:07,860
函数自动给我们。
function gave us automatically.

2008
01:35:07,860 --> 01:35:10,940
现在你可以自己控制了。
Now you have control over doing that yourself.

2009
01:35:10,940 --> 01:35:12,980
但现在让我也说明这一点。
But let me now make this point too.

2010
01:35:12,980 --> 01:35:15,530
定义自己的函数的要点之一
One of the whole points of defining your own functions

2011
01:35:15,530 --> 01:35:18,680
是一个，只是为了避免重复自己一遍又一遍。
is one, just to avoid having to repeat yourself again and again.

2012
01:35:18,680 --> 01:35:21,890
你不必真的保持重造轮子
You don't have to actually keep reinventing the wheel

2013
01:35:21,890 --> 01:35:24,480
继续使用打印函数，一次又一次,
and keep using the print function again, and again, and again,

2014
01:35:24,480 --> 01:35:25,850
如果你只是想打个招呼。
if you just want to say Hello.

2015
01:35:25,850 --> 01:35:29,780
如果我现在能移动这个代码
Wouldn't it be nice now if I could move this code

2016
01:35:29,780 --> 01:35:34,010
我为定义 Hello 函数而写的程序为了更戏剧化一点,
that I wrote for defining the Hello function, and just to be dramatic,

2017
01:35:34,010 --> 01:35:37,760
我会按回车键很多次，往下50行,
I'm going to hit Enter a whole lot of times, 50 lines down,

2018
01:35:37,760 --> 01:35:41,240
并把我的 Hello 的定义放在这个文件的后面。
and put my definition of Hello way further down in this file.

2019
01:35:41,240 --> 01:35:41,840
为什么？
Why?

2020
01:35:41,840 --> 01:35:44,720
好吧，只是为了眼不见心不烦,
Well, just for in the spirit of out of sight, out of mind,

2021
01:35:44,720 --> 01:35:48,800
因为如果我现在回到我的节目开始
because if I now rewind to the start of my program, now

2022
01:35:48,800 --> 01:35:51,240
你可以理所当然地认为 Hello 是一个函数。
you can take for granted that, oh, Hello is a function.

2023
01:35:51,240 --> 01:35:51,740
为什么？
Why?

2024
01:35:51,740 --> 01:35:54,740
因为它在第一行有一个开括号和一个闭括号
Because it's there on line 1 and it has an open parenthesis and a closed

2025
01:35:54,740 --> 01:35:57,560
括号，到目前为止它的意思是，调用这个函数。
parenthesis, which, up until now has meant, call this function.

2026
01:35:57,560 --> 01:36:00,200
然后在第2行，我们从用户那里得到一个变量
And then on line 2 we're getting a variable from the user

2027
01:36:00,200 --> 01:36:04,620
输入他们的名字然后我们调用 Hello 传递那个值。
by typing in their name and then we're calling Hello, passing in that value.

2028
01:36:04,620 --> 01:36:07,790
在这一点上，我可以理所当然地认为 Hello 是存在的,
Well at this point, I can just take for granted that Hello exists,

2029
01:36:07,790 --> 01:36:11,360
即使它在文件中的位置更低，或者，我们将在未来几周看到,
even if it's way down further in the file or, as we'll see in future weeks,

2030
01:36:11,360 --> 01:36:13,970
即使是在完全不同的文件里。
even if it's in a different file altogether.

2031
01:36:13,970 --> 01:36:15,500
但这里有个问题。
But there's a problem here.

2032
01:36:15,500 --> 01:36:19,190
让我继续运行这个版本的 Hello.py。
And let me go ahead and run this version of Hello.py.

2033
01:36:19,190 --> 01:36:23,270
注意，只要我运行解释器 Hello.py 的 Python,
Notice that as soon as I run the interpreter, Python of Hello.py,

2034
01:36:23,270 --> 01:36:26,360
我看到一个名称错误，名称 Hello 没有定义。
I see a name error, name Hello is not defined.

2035
01:36:26,360 --> 01:36:28,280
再问一次，你是说帮忙吗？
Again, did you mean Help?

2036
01:36:28,280 --> 01:36:29,480
再说一遍，很合身。
Well, again, fitting.

2037
01:36:29,480 --> 01:36:33,500
我确实需要一些帮助，但我并不想调用这个函数 Help。
I do need some help here, but I didn't mean to call the function Help.

2038
01:36:33,500 --> 01:36:36,650
但问题是，巨蟒只是字面上的意思。
The problem here, though, is that Python is just taking me literally.

2039
01:36:36,650 --> 01:36:40,610
我已经在这里定义了我的函数 Hello,
I have defined my function Hello all the way down here,

2040
01:36:40,610 --> 01:36:42,500
但我正在努力使用它的方式在这里。
but I'm trying to use it way up here.

2041
01:36:42,500 --> 01:36:43,465
这是不允许的。
And that's not allowed.

2042
01:36:43,465 --> 01:36:45,590
Python 的解释器将逐字逐句地向您介绍
Python's interpreter is going to take you literally

2043
01:36:45,590 --> 01:36:47,810
如果你使用一个函数，它必须已经
and if you use a function, it must already

2044
01:36:47,810 --> 01:36:50,390
在你调用它的时候已经存在。
exist by the time you are calling it.

2045
01:36:50,390 --> 01:36:51,600
那我该怎么补救？
So how do I fix this?

2046
01:36:51,600 --> 01:36:53,270
显然我做不到。
Well, apparently I can't do that.

2047
01:36:53,270 --> 01:36:57,440
我必须在文件的最顶部定义任何我想要的函数,
I have to define any functions I want at the very top of my file,

2048
01:36:57,440 --> 01:36:59,720
但这也会给我带来一点麻烦
but that too could get me into a bit of trouble

2049
01:36:59,720 --> 01:37:04,640
最终，因为如果我不断地在我想要的地方定义一个函数
eventually because if I constantly have to define a function above where I want

2050
01:37:04,640 --> 01:37:07,010
要使用它，你需要反向编写代码,
to use it, you're kind of writing code in reverse,

2051
01:37:07,010 --> 01:37:09,218
你不断地在这上面写函数，在这上面,
you're constantly writing functions up here, up here,

2052
01:37:09,218 --> 01:37:12,450
从上到下，而不是按逻辑编写代码。
up here, as opposed to writing your code logically, top to bottom.

2053
01:37:12,450 --> 01:37:16,190
让我用更标准的方法来解决这个问题，就是这样做。
So let me fix this in a more standard way, which is to do this.

2054
01:37:16,190 --> 01:37:20,990
一般来说，您确实希望将代码的主要部分
Generally speaking, you do want to put the main part of your code

2055
01:37:20,990 --> 01:37:22,530
在你档案的最上面。
at the top of your file.

2056
01:37:22,530 --> 01:37:27,110
实际上，我还要定义函数 Main。
And in fact, I'm going to go so far as to define my function, called Main.

2057
01:37:27,110 --> 01:37:29,540
这不是必需的，但是在数据约定中,
It's not a requirement, but it's in data convention,

2058
01:37:29,540 --> 01:37:31,910
这对读者来说意味着
and this just connotes to the reader that this

2059
01:37:31,910 --> 01:37:33,620
是我计划的主要部分。
is the main part of my program.

2060
01:37:33,620 --> 01:37:38,030
我现在要去掉我的空 Hello 调用，只传递一个版本
I'm going to get rid of my empty Hello call now and only pass in one version

2061
01:37:38,030 --> 01:37:39,110
你好，名字。
with Hello, name.

2062
01:37:39,110 --> 01:37:42,260
然后这里，再往下几行,
And then down here, a couple of lines further down,

2063
01:37:42,260 --> 01:37:45,030
实际上我将定义 Hello 函数。
I'll actually define my Hello function.

2064
01:37:45,030 --> 01:37:47,870
不幸的是，现在我已经用这种方式重新排序了函数,
Unfortunately, now that I've reordered the functions in this way,

2065
01:37:47,870 --> 01:37:51,890
将代码的主要部分放在顶部，Hello 放在底部
by putting the main part of my code at the top and Hello at the bottom

2066
01:37:51,890 --> 01:37:55,310
所以如果我继续跑的话，我的逻辑会自上而下地流动
so that my logic kind of flows top to bottom, if I go ahead and run

2067
01:37:55,310 --> 01:37:57,680
Python of Hello.py，Enter.
Python of Hello.py, Enter.

2068
01:37:57,680 --> 01:38:00,290
什么都没发生。
Nothing whatsoever happens.

2069
01:38:00,290 --> 01:38:02,630
如果我再这么做，什么都不会发生。
If I do it again, nothing whatsoever happens.

2070
01:38:02,630 --> 01:38:04,520
这到底是为什么？
Well, why in the world is this?

2071
01:38:04,520 --> 01:38:06,740
因为我定义了一个名为
Well, just because I've defined a function called

2072
01:38:06,740 --> 01:38:09,230
Main 和我已经定义了一个名为 Hello 的函数,
Main and I've defined a function called Hello,

2073
01:38:09,230 --> 01:38:11,420
并不意味着我真的打过电话
doesn't mean that I've actually called--

2074
01:38:11,420 --> 01:38:13,340
两者都是。
that is used-- either of them.

2075
01:38:13,340 --> 01:38:16,970
是的，我在 Main 中使用 Hello，但是没有人
Yes, I'm using Hello inside of Main, but no one

2076
01:38:16,970 --> 01:38:20,210
告诉 Python 实际使用或调用 Main。
is telling Python to actually use or call Main.

2077
01:38:20,210 --> 01:38:24,770
所以为了整理这个文件我最后要做的就是,
So in order to tidy this up, the last thing I need to do in this file,

2078
01:38:24,770 --> 01:38:28,100
看起来，实际上是调用我的主函数。
it seems, is actually call my main function.

2079
01:38:28,100 --> 01:38:30,890
实际上，通过这样调用 main 函数,
And, in fact, by calling my main function in this way,

2080
01:38:30,890 --> 01:38:33,890
它让我摆脱了麻烦，因为现在我首先定义了 Main
it gets me out of trouble because now I'm defining Main first

2081
01:38:33,890 --> 01:38:35,450
但我还没打电话给你。
but I'm not calling Hello yet.

2082
01:38:35,450 --> 01:38:38,760
接下来我要定义 Hello 但我不会再打 Hello 了。
I'm defining Hello next, but I'm not calling Hello next.

2083
01:38:38,760 --> 01:38:42,170
我只在这个文件的最后调用 Main
I only at the very end of this file call Main

2084
01:38:42,170 --> 01:38:45,090
它的作用就是在这里运行这个代码,
which has the effect of running this code up here,

2085
01:38:45,090 --> 01:38:47,690
它的作用就是在这里运行这个代码,
which has the effect of running this code down here,

2086
01:38:47,690 --> 01:38:50,870
因此我可以整理我的文件
and it allows me therefore to organize my file

2087
01:38:50,870 --> 01:38:55,520
按照我想要的方式来安排我的职能包括最上面的 Main,
and order my functions in any way I want, including Main at the very top,

2088
01:38:55,520 --> 01:38:59,930
并最终解决了 Python 不知道发生了什么的问题。
and solving ultimately that problem of Python not knowing what's going on.

2089
01:38:59,930 --> 01:39:02,780
现在需要注意的是，我定义了我的函数
Now it's important to note that I defined my function

2090
01:39:02,780 --> 01:39:05,690
你好，作为一个论点，然后我
Hello as taking an argument To and then I

2091
01:39:05,690 --> 01:39:08,390
将变量的值传递给该函数
passed into that function the value of the variable

2092
01:39:08,390 --> 01:39:11,570
我想对它说 Hello，这是一个名为 Name 的变量。
that I wanted to say Hello to, that is the variable called Name.

2093
01:39:11,570 --> 01:39:14,420
因为假设我做了一些不同的事情。
Because suppose I had done something a little bit differently.

2094
01:39:14,420 --> 01:39:17,670
假设我没有定义 Hello 参数,
Suppose that I hadn't defined Hello is taking an argument,

2095
01:39:17,670 --> 01:39:21,560
所以我只是删除了 To 和它的默认值“ world”
so I just remove mention of To and its default value "world."

2096
01:39:21,560 --> 01:39:25,070
回到我的主函数
And I go back up to my main function and I just

2097
01:39:25,070 --> 01:39:28,193
调用 Hello 本身而不传入任何参数。
call Hello itself without passing in any arguments.

2098
01:39:28,193 --> 01:39:30,360
现在让我再做一次改变,
And now let me go ahead and make my one more change,

2099
01:39:30,360 --> 01:39:32,760
严格来说，再犯一个错误，我就不客气了
one more mistake technically, let me go ahead

2100
01:39:32,760 --> 01:39:37,720
然后尝试天真地在 Hello 函数中打印 Name 的值。
and just try to naively print out the value of Name in the Hello function.

2101
01:39:37,720 --> 01:39:40,380
所以现在我要说清楚，在第2行的主函数中,
So now to be clear, in my main function on line 2,

2102
01:39:40,380 --> 01:39:43,740
我定义了一个名为 Name 的变量，并将返回值赋给它
I'm defining my variable called Name and assigning it the return value

2103
01:39:43,740 --> 01:39:45,480
从用户输入函数。
of the input function from the user.

2104
01:39:45,480 --> 01:39:47,010
那我就打电话给你。
I'm then just calling Hello.

2105
01:39:47,010 --> 01:39:50,700
在 Hello 函数中，它现在不再接受任何参数,
In my Hello function, which now no longer takes any arguments,

2106
01:39:50,700 --> 01:39:54,180
我正在调用 print，传入 Hello 逗号,
I am calling print, passing in Hello comma,

2107
01:39:54,180 --> 01:39:56,970
然后立即传入 Name，即变量
and then immediately passing in Name, the variable

2108
01:39:56,970 --> 01:39:58,740
我得到了用户的输入。
into which I got the user's input.

2109
01:39:58,740 --> 01:40:02,232
但问题是这个名字现在只存在于 Main 中。
But the catch is that name exists now only in Main.

2110
01:40:02,232 --> 01:40:05,190
看看我运行这个版本的程序时会发生什么
And so watch what happens when I try to run this version of the program

2111
01:40:05,190 --> 01:40:07,170
使用 Python Hello.py。
with Python Hello.py.

2112
01:40:07,170 --> 01:40:08,220
我按了回车键。
I hit Enter.

2113
01:40:08,220 --> 01:40:10,500
系统提示输入我的名字，D-A-V-I-D，回车。
I'm prompted for my name, D-A-V-I-D, Enter.

2114
01:40:10,500 --> 01:40:11,340
然后，啊！
And, argh!

2115
01:40:11,340 --> 01:40:12,450
名称错误。
A name error.

2116
01:40:12,450 --> 01:40:15,400
未定义名称“ Name”。
Name "Name" is not defined.

2117
01:40:15,400 --> 01:40:19,050
所以这实际上是一个范围的问题。
So it turns out that this is actually an issue of what's called scope.

2118
01:40:19,050 --> 01:40:23,970
范围指的是仅存在于您定义它的上下文中的变量。
Scope refers to a variable only existing in the context in which you defined it.

2119
01:40:23,970 --> 01:40:28,080
在我定义这个变量的时候，在我的 main 函数中,
So insofar as I define this variable, Name in my main function,

2120
01:40:28,080 --> 01:40:31,020
我只能在 name 函数中使用这个变量。
I can only use that variable in my name function.

2121
01:40:31,020 --> 01:40:34,380
我不能使用它，因为我尝试在 Hello 函数中使用它。
I can't use it as I've tried to here in my Hello function.

2122
01:40:34,380 --> 01:40:36,930
它不存在于那个所谓的范围内。
It doesn't exist in that so-called scope.

2123
01:40:36,930 --> 01:40:42,010
所以这就是为什么现在，如果我倒带并撤销所有这些改变,
And so this is why now, if I rewind and undo all of those changes,

2124
01:40:42,010 --> 01:40:45,690
你会看到我故意从主函数中传递 Main
you'll see that I'm deliberately passing Main from my main function

2125
01:40:45,690 --> 01:40:47,340
进入我的 Hello 函数。
into my Hello function.

2126
01:40:47,340 --> 01:40:50,260
现在在 Hello 函数中，它在技术上有一个不同的名称。
And now in the Hello function, it technically has a different name.

2127
01:40:50,260 --> 01:40:52,380
在那种情况下叫做 To，不过没关系。
It's called To in that context, but that's fine.

2128
01:40:52,380 --> 01:40:55,950
每个函数完全可以命名自己的变量
It's completely up to each individual function to name its own variables

2129
01:40:55,950 --> 01:40:58,230
或者命名它自己的论点，但这是现在的一种方式
or name its own arguments, but this is a way now

2130
01:40:58,230 --> 01:41:01,630
我把变量的值传递给 Hello 函数
that I'm handing to the Hello function the value of that variable

2131
01:41:01,630 --> 01:41:04,530
所以它也可以被 Hello 打印出来。
so it can be printed by Hello as well.

2132
01:41:04,530 --> 01:41:07,410
我们还可以在这里添加最后一个花絮。
And there's one final flourish we can add here.

2133
01:41:07,410 --> 01:41:10,590
现在我们已经实现了 Hello，您将注意到只有 Hello
Now that we've implemented Hello, you'll notice that Hello only

2134
01:41:10,590 --> 01:41:12,120
有所谓的副作用。
has a so-called side effect.

2135
01:41:12,120 --> 01:41:14,580
它只会把一些东西打印到屏幕上。
It only prints out something to the screen.

2136
01:41:14,580 --> 01:41:19,980
如果我希望我的函数本身没有副作用呢,
Well, what if I also want my function to not have a side effect, per se,

2137
01:41:19,980 --> 01:41:22,300
但实际上还给我一个值？
but actually hand me back a value?

2138
01:41:22,300 --> 01:41:25,740
回想一下，input 函数返回一个值,
Recall that the input function returns a value,

2139
01:41:25,740 --> 01:41:27,510
用户键入的字符串。
the string that the user typed in.

2140
01:41:27,510 --> 01:41:30,060
回想一下，INT 函数返回一个值。
Recall that the INT function returns a value.

2141
01:41:30,060 --> 01:41:33,960
Float 函数返回传递给它的值。
The float function returns a value that was passed into it.

2142
01:41:33,960 --> 01:41:37,260
你可以在这里用最后一个关键词，字面上的意思
Well you can use one final keyword here, literally

2143
01:41:37,260 --> 01:41:40,890
返回自己显式返回一个值。
Return to return a value explicitly yourself.

2144
01:41:40,890 --> 01:41:43,890
事实上，让我们回到 VS 代码这里，我
In fact, let me go back to VS Code here, and I

2145
01:41:43,890 --> 01:41:47,820
我想我们应该把注意力转移到 Calculator.py 上
think we'll return our attention to Calculator.py

2146
01:41:47,820 --> 01:41:53,190
看看我们能不能实现另一个版本的 Calculator.py
and see if we can't implement one other version of Calculator.py that actually

2147
01:41:53,190 --> 01:41:56,410
有我们自己的函数，甚至返回一个值。
has our own function that even returns a value.

2148
01:41:56,410 --> 01:41:59,800
现在我要打开计算器/py
So I'm going to go ahead and open up calculator/py

2149
01:41:59,800 --> 01:42:03,100
我想这次我会像以前一样把所有东西都扔掉,
and I think this time I'm going to throw everything away as before,

2150
01:42:03,100 --> 01:42:06,600
我要开始实践我们在这里所宣扬的。
and I'm just going to start practicing what we're preaching here.

2151
01:42:06,600 --> 01:42:09,120
定义一个名为 Main 的函数
Define a function called Main which is now going

2152
01:42:09,120 --> 01:42:11,070
成为我职责的主要部分。
to be the main part of my function.

2153
01:42:11,070 --> 01:42:13,980
现在声明一个变量 x,
Let's go ahead and now declare a variable called x,

2154
01:42:13,980 --> 01:42:19,350
并在询问用户后将其分配给用户输入的转换版本,
and assign it to the converted version of the user's input after asking them,

2155
01:42:19,350 --> 01:42:20,430
x 是什么？
what's x?

2156
01:42:20,430 --> 01:42:23,490
再一次，一行代码，就像我们之前做过的。
So again, a line of code quite like we've done before.

2157
01:42:23,490 --> 01:42:27,023
假设现在我要做的就是平方这个值。
And suppose now that what I want to do is square this value.

2158
01:42:27,023 --> 01:42:29,190
我想取用户输入的数字
I want to take the number that the user has typed in

2159
01:42:29,190 --> 01:42:30,840
把它提高到2的幂。
and raise it to the power of 2.

2160
01:42:30,840 --> 01:42:32,790
所以2的平方等于4。
So 2 squared would be 4.

2161
01:42:32,790 --> 01:42:34,410
3的平方等于9。
3 squared would be 9.

2162
01:42:34,410 --> 01:42:36,840
4的平方等于16等等。
4 squared would be 16, and so forth.

2163
01:42:36,840 --> 01:42:39,450
那么我该如何实现一个函数呢
Well how do I go about implementing a function literally

2164
01:42:39,450 --> 01:42:42,960
叫做 Square 实际上并没有内置 Python？
called Square which actually doesn't come with Python built-in?

2165
01:42:42,960 --> 01:42:45,660
让我暂时假设它确实存在
Well, let me assume for the moment that it does exist, and let

2166
01:42:45,660 --> 01:42:47,530
我说这样的话
me say something like this--

2167
01:42:47,530 --> 01:42:50,670
让我继续说，印刷，如何
let me go ahead and say that printing, how

2168
01:42:50,670 --> 01:42:57,720
关于 x 的平方是 x 的逗号平方。
about x squared is comma square of x.

2169
01:42:57,720 --> 01:42:59,170
我做了什么？
So what have I done?

2170
01:42:59,170 --> 01:43:02,710
我定义了一个名为 Main 的函数，并实现了两行代码。
I've defined a function called Main and I've implemented two lines.

2171
01:43:02,710 --> 01:43:05,190
第一行提示用户输入一个值
The first of these lines prompts the user for a value

2172
01:43:05,190 --> 01:43:09,330
并将其转换为 INT 并将其存储在一个名为 x 的变量中。
x and converts it to an INT and stores it in a variable called x.

2173
01:43:09,330 --> 01:43:12,930
在第3行，我说 x 的平方是，然后
On line 3, I then say x squared is and then

2174
01:43:12,930 --> 01:43:16,620
我将第二个参数传递给 print 函数，不管返回值是什么
I pass a second argument to the print function, whatever the return

2175
01:43:16,620 --> 01:43:18,780
值是一个平方函数。
value is of a square function.

2176
01:43:18,780 --> 01:43:22,230
但平方并不存在，我给你们看这个,
But squared doesn't exist and I'll show you this here,

2177
01:43:22,230 --> 01:43:30,090
如果我现在在底部调用 Main 并运行 Python 的 Calculator.py,
if I now call Main at the bottom and I run Python of Calculator.py,

2178
01:43:30,090 --> 01:43:35,100
我会看到 x 是2然后我会看到一大堆错误一个名字错误,
I'll see that x is 2 and then I see a whole bunch of errors, a name error,

2179
01:43:35,100 --> 01:43:37,090
名称 Square 未定义。
name Square is not defined.

2180
01:43:37,090 --> 01:43:39,810
这不是打错了，只是函数不存在。
So this isn't a typo here, it's just the function doesn't exist.

2181
01:43:39,810 --> 01:43:41,790
但我想我可以让它存在于这里。
But I think I can make it exist here.

2182
01:43:41,790 --> 01:43:45,180
让我继续定义另一个名为 Square 的函数。
Let me go ahead and define another function called Square.

2183
01:43:45,180 --> 01:43:47,400
接下来我要说的是一个数字
This one's going to take in a number and I'm

2184
01:43:47,400 --> 01:43:50,370
就像很多程序员一样，通常称它为 n,
going to call it generically n, as many a programmer would,

2185
01:43:50,370 --> 01:43:52,260
只是为了表示任何旧的数字。
just to represent any old number.

2186
01:43:52,260 --> 01:43:56,010
然后我要做什么，才能得到 n 的平方呢？
And then what do I want to do in order to square n?

2187
01:43:56,010 --> 01:43:59,380
一个数字的平方其实就是它自己乘以它自己,
Well a number squared is really just itself times itself,

2188
01:43:59,380 --> 01:44:00,720
所以我要这么做
so I'm going to do this--

2189
01:44:00,720 --> 01:44:02,340
N 乘以 n。
n times n.

2190
01:44:02,340 --> 01:44:06,180
但仅仅自己算 n 乘以 n 是不够的。
But it's not enough just to do the math yourself, n times n.

2191
01:44:06,180 --> 01:44:09,990
必须返回实际值 n 乘以 n
You're going to have to return the actual value n times n

2192
01:44:09,990 --> 01:44:11,970
这就是我们的新关键词。
and that's our new keyword here.

2193
01:44:11,970 --> 01:44:14,100
当我这么做的时候，看看会发生什么。
When I now do this, watch what happens.

2194
01:44:14,100 --> 01:44:16,230
Python 的 Calculator.py，Enter。
Python of Calculator.py, Enter.

2195
01:44:16,230 --> 01:44:20,250
X 说应该是2，x 的平方是4。
X say shall be 2, x squared is 4.

2196
01:44:20,250 --> 01:44:24,020
现在让我继续，说 x 现在是3。
Let me go ahead now and say x is now 3.

2197
01:44:24,020 --> 01:44:26,010
X 的平方现在是9。
X squared is now 9.

2198
01:44:26,010 --> 01:44:30,060
所以我实现了我自己的函数，它返回一个值的平方
So I've implemented my very own function that returns the square of a value

2199
01:44:30,060 --> 01:44:33,180
因为我用的是 return 关键字
and because I'm using the return keyword, that

2200
01:44:33,180 --> 01:44:36,120
确保我可以传递这个的返回值
ensures that I can pass the return value of this, just

2201
01:44:36,120 --> 01:44:40,140
比如输入或 INT 或 float 的返回值,
like the return value of input or INT or float, to another function,

2202
01:44:40,140 --> 01:44:41,460
比如印刷品。
like print instead.

2203
01:44:41,460 --> 01:44:44,520
这里也有很多方法可以解决同样的问题。
And here too there's going to be so many ways to solve this same problem.

2204
01:44:44,520 --> 01:44:47,490
实际上我可以把 n 提高到2的幂。
I can actually raise n to the power of 2.

2205
01:44:47,490 --> 01:44:49,620
我们以前没有见过这种语法，但是如果您
We've not seen this syntax before, but if you

2206
01:44:49,620 --> 01:44:54,220
像这样用两个星号，两颗星，把左边的东西举起来
use two asterisks like this, two stars, that raises the thing on the left

2207
01:44:54,220 --> 01:44:55,590
右边的电源。
to the power on the right.

2208
01:44:55,590 --> 01:44:58,290
或者在 Python 中有一个名为
Or it turns out there is in Python a function called

2209
01:44:58,290 --> 01:45:00,480
因为提升了某种东西的力量
POW for raising something to the power that

2210
01:45:00,480 --> 01:45:04,200
接受两个参数，第一个是数字，第二个是
takes two arguments, the first of which is the number, the second of which

2211
01:45:04,200 --> 01:45:05,140
是指数。
is the exponent.

2212
01:45:05,140 --> 01:45:09,810
因此，实际上有很多方法可以解决同样的问题
So there too, there's just so many ways to actually solve that same problem

2213
01:45:09,810 --> 01:45:11,290
我也是。
as well.

2214
01:45:11,290 --> 01:45:13,020
那么最终，我们在这里做了什么？
So ultimately, what have we done here?

2215
01:45:13,020 --> 01:45:15,960
我们首先介绍了函数——这些动作或动词，其中许多
We first introduced functions-- these actions or verbs, many of which

2216
01:45:15,960 --> 01:45:19,000
内置到 Python 中，可以在自己的代码中使用。
come built into Python that you can just use in your own code.

2217
01:45:19,000 --> 01:45:22,290
然后我们引入变量，通过它们可以存储这些返回值
We then introduced variables via which you could store those return values

2218
01:45:22,290 --> 01:45:24,120
然后再做点别的。
and then maybe do something more with it.

2219
01:45:24,120 --> 01:45:25,350
到头来也一样。
At the end of the day too.

2220
01:45:25,350 --> 01:45:28,260
你现在有能力去创造，去发明你自己的功能
You now have the ability to create, to invent your own functions

2221
01:45:28,260 --> 01:45:30,750
来解决像 Hello 这样的简单问题，或者在几周内
to solve simple problems like Hello, or in the weeks

2222
01:45:30,750 --> 01:45:36,590
更复杂，更有挑战性，更有趣的问题。
to come-- much more sophisticated, more challenging, more fun problems as well.

