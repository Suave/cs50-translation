1
00:00:00,000 --> 00:00:02,946
[音乐播放]
[MUSIC PLAYING]

2
00:00:25,020 --> 00:00:28,560
DAVID MALAN: 这是 CS50的 Python 编程入门。
DAVID MALAN: This is CS50's Introduction to Programming with Python.

3
00:00:28,560 --> 00:00:32,100
我的名字是大卫 · 马兰，本周我们将关注条件句。
My name is David Malan, and this week we focus on conditionals.

4
00:00:32,100 --> 00:00:36,120
条件语句，或者条件语句，在 Python 和其他语言中,
Conditionals, or conditional statements, in Python and in other languages,

5
00:00:36,120 --> 00:00:40,620
问问题和回答问题的能力
are this ability to ask questions and answer those questions, in order

6
00:00:40,620 --> 00:00:43,260
来决定是否执行这行代码？
to decide do you want to execute this line of code?

7
00:00:43,260 --> 00:00:44,220
还是这行代码？
Or this line of code?

8
00:00:44,220 --> 00:00:46,020
还是另一行代码？
Or this other line of code instead?

9
00:00:46,020 --> 00:00:48,780
他们允许你在道路上走岔路,
They allow you to take the proverbial forks in the road,

10
00:00:48,780 --> 00:00:50,730
在你自己的代码里，逻辑上。
within your own code, logically.

11
00:00:50,730 --> 00:00:54,210
那么，我们该如何做出这些决定呢？
So how might we go about making some of these decisions?

12
00:00:54,210 --> 00:00:57,592
事实证明 Python 有很多内置语法。
Well, it turns out that Python comes with a lot of built-in syntax.

13
00:00:57,592 --> 00:00:59,550
例如，这里只是一些符号
For instance, here are just some of the symbols

14
00:00:59,550 --> 00:01:01,770
您可以在 Python 中使用它来提问。
you can use in Python to ask questions.

15
00:01:01,770 --> 00:01:04,860
不可否认，这是数学问题，但是我们可以从这里开始，如果可以的话
Admittedly, mathematical questions, but we'll start there, if only

16
00:01:04,860 --> 00:01:07,470
使示例尽早保持简单。
to keep the examples simple early on.

17
00:01:07,470 --> 00:01:11,160
第一个符号，你们可能从数学中知道，代表大于。
This first symbol, as you might know from math, represents greater than.

18
00:01:11,160 --> 00:01:14,640
第二个符号可能看起来不太熟悉，因为我们通常是这样写的
The second symbol might not look too familiar, because we usually write it

19
00:01:14,640 --> 00:01:16,800
就像一张纸上的东西。
all as one thing on a piece of paper.

20
00:01:16,800 --> 00:01:19,830
但在键盘上，如果你想说大于等于,
But on a keyboard, if you want to say greater than or equal to,

21
00:01:19,830 --> 00:01:21,300
你会用这个符号代替。
you'd use this symbol instead.

22
00:01:21,300 --> 00:01:22,920
当然，这意味着小于。
This, of course, means less than.

23
00:01:22,920 --> 00:01:25,590
这意味着小于或等于。
This means less than or equal to.

24
00:01:25,590 --> 00:01:27,720
这个有点奇怪。
And this one's a bit of a curiosity.

25
00:01:27,720 --> 00:01:30,240
我们在函数和变量中看到,
We've seen, in our look at functions and variables,

26
00:01:30,240 --> 00:01:35,650
我们如何能够使用一个单一的等号赋值给变量。
how we were able to assign values to variables using a single equal sign.

27
00:01:35,650 --> 00:01:38,010
但那个等号并不代表等号。
But that equal sign didn't represent equality.

28
00:01:38,010 --> 00:01:40,230
它代表从右到左的分配。
It represented assignment, from right to left.

29
00:01:40,230 --> 00:01:42,390
那太好了，因为它解决了那个问题。
That's great, because it solved that problem.

30
00:01:42,390 --> 00:01:45,030
但这让我们陷入了困境，因为我们现在
But it left us in a bit of a bind, because how do we now

31
00:01:45,030 --> 00:01:47,190
比较两样东西，左边和右边？
compare two things, left and right?

32
00:01:47,190 --> 00:01:51,390
在 Python 和许多语言中，实际上使用了两个相等的边。
Well, in Python, and in many languages, you actually use two equal sides.

33
00:01:51,390 --> 00:01:55,200
两个相等的符号代表相等，比较这个东西
So two equal signs represents equality, comparing the thing

34
00:01:55,200 --> 00:01:56,310
在左边和右边。
on the left and the right.

35
00:01:56,310 --> 00:01:59,250
一个等号一如既往地代表赋值,
One equal sign, as always, represents assignment,

36
00:01:59,250 --> 00:02:01,650
从右到左复制东西。
copying the thing from the right to the left.

37
00:02:01,650 --> 00:02:04,650
最后，最后一个符号表示不等于。
Lastly, this last symbol represents not equal to.

38
00:02:04,650 --> 00:02:08,699
所以这个叹号或者 bang 后面跟着一个等号,
So the exclamation point, or bang, followed by an equal sign,

39
00:02:08,699 --> 00:02:12,180
意味着不等于它旁边的某个值。
means not equal to some value next to it.

40
00:02:12,180 --> 00:02:15,900
用这些符号或其他符号来问问题,
Well, to ask the questions using these symbols, or any others,

41
00:02:15,900 --> 00:02:18,240
我们需要 Python 中的另一个关键字。
we're going to need another keyword in Python.

42
00:02:18,240 --> 00:02:21,120
这个关键词，很简单，就像英语一样，是 if。
And that keyword, quite simply, as in English, is if.

43
00:02:21,120 --> 00:02:24,420
您可以在 Python 代码中提问,
You can ask questions in Python code along the lines of,

44
00:02:24,420 --> 00:02:28,890
如果这个问题的答案是真的，那么请继续
if the answer to this question is true, then go ahead

45
00:02:28,890 --> 00:02:30,760
帮我执行这个代码。
and execute this code for me.

46
00:02:30,760 --> 00:02:33,240
那么让我们继续，在这里写一些这样的例子。
So let's go ahead and write some of these examples here.

47
00:02:33,240 --> 00:02:35,073
我要去 VS 码。
I'm going to go over to VS Code.

48
00:02:35,073 --> 00:02:36,990
让我们先创建一个程序,
And let's go ahead and create a program first,

49
00:02:36,990 --> 00:02:39,900
名为 compare.py，其目标很简单
called compare.py, the goal of which is simply

50
00:02:39,900 --> 00:02:44,980
编写比较值并根据这些值做出决策的代码。
to write code that compares values and makes decisions based on those values.

51
00:02:44,980 --> 00:02:47,400
让我们继续输入 compare.py 的代码,
Let's go ahead and type code of compare.py,

52
00:02:47,400 --> 00:02:49,980
为了创建一个全新的名为比较的文件,
in order to create a brand new file called compare,

53
00:02:49,980 --> 00:02:52,415
其中我们将开始表达一些这样的逻辑。
in which we'll start to express some of this logic.

54
00:02:52,415 --> 00:02:53,790
我们要比较什么？
Well, what do we want to compare?

55
00:02:53,790 --> 00:02:56,130
为了便于讨论，我们来比较一下,
Suppose we want to compare, for the sake of discussion,

56
00:02:56,130 --> 00:02:57,540
只有几个整数。
just a couple of integers.

57
00:02:57,540 --> 00:03:00,210
但我们希望这些整数来自用户,
But we'd like those integers to come from the user,

58
00:03:00,210 --> 00:03:03,810
这样我们就可以根据数字做出决定
so that we can make decisions based on numbers

59
00:03:03,810 --> 00:03:05,915
我们不知道事先的价值。
we don't know the values of in advance.

60
00:03:05,915 --> 00:03:07,290
我们开始吧。
Well, let's go ahead and do this.

61
00:03:07,290 --> 00:03:10,350
正如我们过去所做的，让我们把它声明为一个变量，就像 x 一样。
As we've done in the past, let's declare it a variable, like x.

62
00:03:10,350 --> 00:03:15,330
让我们赋值它等于 int 函数的返回值,
Let's assign it equal to the return value of the int function,

63
00:03:15,330 --> 00:03:19,320
并将输入函数的返回值传递给 int 函数,
and pass to the int function the return value of the input function,

64
00:03:19,320 --> 00:03:22,680
问用户一个问题，比如 x 是什么，问题
asking the user a question like, what's x, question

65
00:03:22,680 --> 00:03:24,210
Mark 就像我们过去一样。
mark, as we've done in the past.

66
00:03:24,210 --> 00:03:29,490
让我们对 y 再做一次，要求用户输入 y 的值。
Let's do this one more time with y, asking the user for the value of y.

67
00:03:29,490 --> 00:03:33,790
同样，最终也将其转换为 int。
And, again, converting that, ultimately, to an int, as well.

68
00:03:33,790 --> 00:03:37,200
这么多的故事，我们有两个变量 x 和 y,
So with this amount of the story, we have two variables, x and y,

69
00:03:37,200 --> 00:03:38,622
每一个都有价值。
each of which has values.

70
00:03:38,622 --> 00:03:41,080
理想情况下，我们现在应该能够比较这些值。
And ideally, we should be able to now compare these values.

71
00:03:41,080 --> 00:03:45,510
假设我想根据这些变量的值来做决定。
So suppose I want to make a decision based on the values of these variables.

72
00:03:45,510 --> 00:03:46,848
我会用关键词。
I'm going to use the keyword if.

73
00:03:46,848 --> 00:03:49,140
我会用到一些数学符号
And I'm going to use some of those mathematical symbols

74
00:03:49,140 --> 00:03:51,100
才能真正问出问题本身。
to actually ask the question itself.

75
00:03:51,100 --> 00:03:55,860
这样吧，如果 x 小于 y 我们继续
So how about this, if x is less than y, then let's go ahead and just

76
00:03:55,860 --> 00:03:56,940
打印出来。
print as much out.

77
00:03:56,940 --> 00:03:59,700
引号 x 小于 y。
Quote, unquote x is less than y.

78
00:03:59,700 --> 00:04:02,250
所以这还不是一个非常有趣的程序。
So this isn't a very interesting program yet.

79
00:04:02,250 --> 00:04:05,580
根据数学，我只是在陈述显而易见的事实。
I'm literally just stating the obvious, based on the math.

80
00:04:05,580 --> 00:04:08,160
但现在它允许我引入一些新的语法。
But it's allowing me to now introduce some new syntax.

81
00:04:08,160 --> 00:04:10,020
具体的语法是什么？
And exactly what is the syntax?

82
00:04:10,020 --> 00:04:12,990
是这个，不仅仅是“如果”这个关键词
Well, it's this-- not just the keyword if, which

83
00:04:12,990 --> 00:04:15,180
我在第四行的开头添加了,
I've added here at the start of line four,

84
00:04:15,180 --> 00:04:18,450
然后我问了一个问题，x 小于 y。
but then I asked my question here, x less than y.

85
00:04:18,450 --> 00:04:21,450
X 是左边的一个变量，y 是右边的一个变量。
x is one variable on the left, y is one variable on the right.

86
00:04:21,450 --> 00:04:24,570
当然，小于号表示的是数学问题
And, of course, the less than sign is expressing the mathematical question

87
00:04:24,570 --> 00:04:25,200
是的。
I have.

88
00:04:25,200 --> 00:04:26,970
我在这里强调的是技术上的
What I've highlighted here is technically

89
00:04:26,970 --> 00:04:29,400
叫做布尔表达式。
called a Boolean expression.

90
00:04:29,400 --> 00:04:32,550
一个以数学家布尔命名的布尔表达式,
A Boolean expression, named after a mathematician named Bool,

91
00:04:32,550 --> 00:04:36,870
只是一个回答是或不是的问题，或者技术上来说,
is simply a question that has a yes or no answer, or technically,

92
00:04:36,870 --> 00:04:38,760
真或假的答案。
a true or false answer.

93
00:04:38,760 --> 00:04:41,670
这很好，因为如果只有两个可能的答案,
And that's nice because if there's only two possible answers,

94
00:04:41,670 --> 00:04:44,760
这对我来说很容易，反过来，电脑也可以做出决定
it's very easy for me, and in turn the computer, to make a decision--

95
00:04:44,760 --> 00:04:47,100
要么做，要么不做。
do this, or don't do this thing.

96
00:04:47,100 --> 00:04:49,800
注意，如果你来自其他语言,
Now notice, if you come from other languages,

97
00:04:49,800 --> 00:04:53,100
你可能注意到我没有输入任何括号。
you might notice that I have not typed any parentheses.

98
00:04:53,100 --> 00:04:56,190
实际上，它们并不是必需的，至少在这种情况下，在 Python 中是如此,
They are not, in fact, necessary, at least in this case, in Python,

99
00:04:56,190 --> 00:04:58,980
但是我在这一行的末尾打了一个冒号。
but I have typed a colon at the end of the line.

100
00:04:58,980 --> 00:05:01,920
更重要的是，在下一行
And even more importantly, at the next line

101
00:05:01,920 --> 00:05:04,350
我已经开始了我的线与一些压痕,
I have begun my line with some indentation,

102
00:05:04,350 --> 00:05:07,380
按四次空格键或者只按一次 Tab 键,
hitting the space bar four times, or just hitting Tab once,

103
00:05:07,380 --> 00:05:09,660
将自动转换为相同的。
which will automatically be converted to the same.

104
00:05:09,660 --> 00:05:13,980
这种缩进告诉 Python 第5行只应该
That indentation is what tells Python that line five should only

105
00:05:13,980 --> 00:05:20,260
如果第四行问题的答案事实上是正确的，则执行。
be executed if the answer to line four's question is, in fact, true.

106
00:05:20,260 --> 00:05:24,022
所以如果 x 小于 y 短语会在之后打印出来。
So if x is less than y, that phrase will be printed thereafter.

107
00:05:24,022 --> 00:05:25,730
我们再加几行代码。
Well, let's add a few more lines of code.

108
00:05:25,730 --> 00:05:26,855
再问个问题怎么样？
How about another question?

109
00:05:26,855 --> 00:05:30,550
如果 x 大于 y 那么我们继续打印它。
If x is greater than y, then let's go ahead and print that.

110
00:05:30,550 --> 00:05:33,010
X 大于 y。
x is greater than y.

111
00:05:33,010 --> 00:05:38,560
最后一个问题，如果 x 等于 y，等一下。
And let's do one final question, if x equals y, then-- wait a minute.

112
00:05:38,560 --> 00:05:41,360
我做错了什么？
What have I done wrong here?

113
00:05:41,360 --> 00:05:42,250
好眼力。
A good eye here.

114
00:05:42,250 --> 00:05:44,080
我不想把 y 赋给 x。
I don't want to assign y to x.

115
00:05:44,080 --> 00:05:48,430
如果 x 等于 y 是表示等式的方法，那么我们继续
If x equals equals y is how I express equality, let's go ahead

116
00:05:48,430 --> 00:05:52,420
打印出 x 等于 y。
and print out x is equal to y.

117
00:05:52,420 --> 00:05:56,470
现在我有三个条件,
So I now have three conditions, if you will,

118
00:05:56,470 --> 00:05:59,935
一个问题要求 x 小于 y 一个问题要求 x 大于 y,
one question asking x less than y, one asking x greater than y,

119
00:05:59,935 --> 00:06:02,860
一个问题是 x 等于 y。
one asking x equals equals y.

120
00:06:02,860 --> 00:06:03,912
运行代码。
Let's run the code.

121
00:06:03,912 --> 00:06:05,620
在我的终端窗口
Well, down here in my terminal window I'm

122
00:06:05,620 --> 00:06:08,320
将运行 compare.py 的 Python 并点击 Enter。
going to run Python of compare.py and hit Enter.

123
00:06:08,320 --> 00:06:09,190
X 是什么？
What's x?

124
00:06:09,190 --> 00:06:10,390
我们就选一个吧。
Let's go with one.

125
00:06:10,390 --> 00:06:11,140
Y 是什么？
What's y?

126
00:06:11,140 --> 00:06:12,370
那就两个吧。
Let's go with two.

127
00:06:12,370 --> 00:06:15,940
当然，这应该执行第一行代码
This should, of course, execute that first line of code

128
00:06:15,940 --> 00:06:18,970
告诉我，确实，x 小于 y。
and tell me, indeed, that x is less than y.

129
00:06:18,970 --> 00:06:21,670
正如我所料。
Exactly as I would expect there.

130
00:06:21,670 --> 00:06:24,400
刚才发生了什么，用密码吗？
Well, what just happened, though, in code?

131
00:06:24,400 --> 00:06:28,090
那么，让我们来看看，也许，在同样的代码视觉上,
Well, let's take a look, perhaps, at this same code visually,

132
00:06:28,090 --> 00:06:31,210
特别是如果你是一个视觉学习者，这个，我敢说,
particularly if you're a more visual learner, this, I dare say,

133
00:06:31,210 --> 00:06:32,500
就是刚刚发生的事。
is what just happened.

134
00:06:32,500 --> 00:06:34,840
我们现在看到的是一个流程图。
So what we're looking at here is a flow chart.

135
00:06:34,840 --> 00:06:37,900
这是这个程序的逻辑图。
It's a diagram of this program's logic.

136
00:06:37,900 --> 00:06:41,470
从技术上讲，它展示了程序的控制流程。
And more technically, it shows the program's control flow.

137
00:06:41,470 --> 00:06:43,510
也就是说，你在代码中控制的能力
That is, the ability of you, in code, to control

138
00:06:43,510 --> 00:06:46,210
程序的流程，通常从上到下。
the flow of a program, generally from top to bottom.

139
00:06:46,210 --> 00:06:49,300
事实上，让我继续放大这个流程图的顶部。
In fact, let me go ahead and zoom in on the top of this flow chart.

140
00:06:49,300 --> 00:06:52,510
你会看到顶部有一个椭圆，字面意思是，开始。
And you'll see an oval at the very top that says, quite literally, start.

141
00:06:52,510 --> 00:06:55,450
也就是说，不管是什么形状或布局
That is, irrespective of what shape or layout

142
00:06:55,450 --> 00:06:58,180
这个图表就是，你自己的思维和逻辑
the diagram is, where your own thinking and logic

143
00:06:58,180 --> 00:07:01,460
应该开始时，试图包装您的头脑在这个程序。
should start when trying to wrap your mind around this program.

144
00:07:01,460 --> 00:07:04,480
注意，从开始到这个菱形形状有一个箭头。
Notice that there's an arrow from start to this diamond shape.

145
00:07:04,480 --> 00:07:07,450
在这颗钻石里面有一个问题一个布尔表达式,
And inside of that diamond is a question, a Boolean expression,

146
00:07:07,450 --> 00:07:08,800
x 小于 y。
x less than y.

147
00:07:08,800 --> 00:07:12,190
这个形状意味着，基于这个问题的答案,
And this shape just means, based on the answer to that question,

148
00:07:12,190 --> 00:07:14,140
向左或向右。
go left or go right.

149
00:07:14,140 --> 00:07:16,690
具体来说，如果答案是真的就向左走,
Specifically, go left if the answer is true,

150
00:07:16,690 --> 00:07:19,240
如果答案是错误的，就向右走。
or go right if the answer is false.

151
00:07:19,240 --> 00:07:24,460
对于 x 和 y，我输入的输入分别是1和2。
Well, the inputs I typed were one and two, respectively, for x and y.

152
00:07:24,460 --> 00:07:26,980
所以，当然，一比二小。
So, of course, one is less than two.

153
00:07:26,980 --> 00:07:32,530
这就是为什么我的程序输出，引号，x 小于 y。
So that's why my program printed out, quote unquote, x is less than y.

154
00:07:32,530 --> 00:07:34,120
但是回想一下密码。
But recall the code.

155
00:07:34,120 --> 00:07:37,270
代码接着又问了两个问题。
The code then proceeded to ask two more questions.

156
00:07:37,270 --> 00:07:38,800
X 大于 y 吗？
Is x greater than y?

157
00:07:38,800 --> 00:07:40,570
X 等于 y 吗？
Is x equal equal to y?

158
00:07:40,570 --> 00:07:43,570
流程图也描述了这些问题。
Well, the flow chart depicts those questions, too.

159
00:07:43,570 --> 00:07:46,090
请注意，无论问题是否
Notice that no matter whether the question

160
00:07:46,090 --> 00:07:50,530
有一个真或假的答案，箭头都收敛了下来
had an answer of true or false, the arrows both converge back down

161
00:07:50,530 --> 00:07:52,990
第二个钻石形状。
to this second diamond shape here.

162
00:07:52,990 --> 00:07:57,070
第二个菱形问第二个问题，x 大于 y。
And that second diamond shape asks the second question, x greater than y.

163
00:07:57,070 --> 00:07:58,840
这也有一个正确或错误的答案。
That, too, has a true or false answer.

164
00:07:58,840 --> 00:08:00,560
所以不管怎样，我们都要去。
So we go one way or the other.

165
00:08:00,560 --> 00:08:04,600
但如果 x 是1，y 是2，那么答案是否定的。
But if x is one and y is two, then no, the answer is false.

166
00:08:04,600 --> 00:08:06,190
一个并不比 y 大。
One is not greater than y.

167
00:08:06,190 --> 00:08:09,430
所以从逻辑上来说，在流程图中，这次你要遵循错误的箭头。
So logically, in the flow chart, you follow the false arrow this time.

168
00:08:09,430 --> 00:08:13,750
注意，沿着那个错误的箭头，这次你不会打印任何东西。
And notice, along that false arrow you don't print anything this time.

169
00:08:13,750 --> 00:08:16,067
这就是为什么我们在屏幕上只看到一个打印输出。
That's why we only saw one printout on the screen.

170
00:08:16,067 --> 00:08:17,650
还有第三个问题。
Now, there was still a third question.

171
00:08:17,650 --> 00:08:19,442
这个流程图也捕捉到了这一点。
And this flow chart captures that, as well.

172
00:08:19,442 --> 00:08:22,480
第三个菱形要求 x 等于 y。
The third diamond asks x equals equals y.

173
00:08:22,480 --> 00:08:25,720
现在，在这个例子中也有一个错误的答案，因为一个，当然,
Now that, too, has a false answer in this case, because one, of course,

174
00:08:25,720 --> 00:08:27,250
不等于 y。
does not equal equal y.

175
00:08:27,250 --> 00:08:30,830
所以我们再次跟随第三个假分支。
And so we again follow the third false branch here.

176
00:08:30,830 --> 00:08:32,890
当然，这导致我们停下来。
And that leads us, of course, to stop.

177
00:08:32,890 --> 00:08:35,659
“停止”表示程序结束了。
And stop just indicates that's it for the program.

178
00:08:35,659 --> 00:08:38,020
所以我认为这是正确的。
So I think that's correct.

179
00:08:38,020 --> 00:08:40,780
这种特殊的流程图确实会发生
And that particular flow chart does happen

180
00:08:40,780 --> 00:08:44,140
代表我写的实际代码。
to represent the actual code that I wrote.

181
00:08:44,140 --> 00:08:45,220
所以是对的。
So it's correct.

182
00:08:45,220 --> 00:08:46,690
它做了它该做的事。
It does what it's supposed to do.

183
00:08:46,690 --> 00:08:50,290
它通过在屏幕上打印 x 小于 y 正确地回答了这个问题。
It answered the question correctly by printing on the screen x less than y.

184
00:08:50,290 --> 00:08:53,803
但是，它的设计可能有什么缺陷呢？
But what is, perhaps, poorly designed about it?

185
00:08:53,803 --> 00:08:55,220
让我们来做第一个区分。
Let's make this first distinction.

186
00:08:55,220 --> 00:08:56,770
对于代码来说，这是不够的
It's not enough, necessarily, for the code

187
00:08:56,770 --> 00:08:58,937
你写的是正确的，做你想做的。
that you write to be correct and do what you intend.

188
00:08:58,937 --> 00:09:02,270
长远来看，尤其是我们的项目越来越长，越来越复杂,
Longer term, especially as our programs get longer and more sophisticated,

189
00:09:02,270 --> 00:09:06,910
更复杂的是，我们也希望它们设计得很好。
more complicated, we're going to want them to be well-designed, too.

190
00:09:06,910 --> 00:09:12,610
思考一下这个项目在哪些方面设计得不够好,
Thoughts on in what way this program is arguably not well designed,

191
00:09:12,610 --> 00:09:15,230
即使它是正确的？
even though it's correct?

192
00:09:15,230 --> 00:09:16,300
让我看看。
Let's see here.

193
00:09:16,300 --> 00:09:18,880
Khalid 如果我没说错的话，你的想法呢？
Khalid, if I'm saying that right, your thoughts?

194
00:09:18,880 --> 00:09:21,730
太多的如果，我认为，正在变得重复。
KHALID: Too many ifs, I think, is getting repetitive.

195
00:09:21,730 --> 00:09:23,930
也许，我们可以使代码更简洁。
We can make our code more concise, maybe.

196
00:09:23,930 --> 00:09:25,930
大卫. 马兰: 是的，看起来有点重复。
DAVID MALAN: Yeah, it seems a little repetitive.

197
00:09:25,930 --> 00:09:28,692
我在问这个，这个，这个。
I'm asking if this, if this, if this.

198
00:09:28,692 --> 00:09:31,900
然而，从逻辑上讲，我应该知道后面一些问题的答案
And yet, logically, I should know the answer to some of those later questions

199
00:09:31,900 --> 00:09:33,040
只要我想出一个办法。
once I figure one out.

200
00:09:33,040 --> 00:09:35,350
简而言之，如果你看这张图,
And, in short, if you look at this diagram here,

201
00:09:35,350 --> 00:09:38,650
注意到不管我是向左还是向右,
notice that no matter whether I go left or I go right,

202
00:09:38,650 --> 00:09:41,110
我总是问三个问题。
I'm always asking three questions.

203
00:09:41,110 --> 00:09:45,230
不管怎样，所有的箭头都指向第一个，第二个,
No matter what, all of those arrows lead to the first, the second,

204
00:09:45,230 --> 00:09:46,480
第三颗钻石。
and the third diamond.

205
00:09:46,480 --> 00:09:49,810
所以我要问三个问题，不管是否有答案
So I'm asking three questions, no matter whether any of those answers

206
00:09:49,810 --> 00:09:50,862
是真是假。
are true or false.

207
00:09:50,862 --> 00:09:52,570
那我该怎么改进呢？
Well how might I go about improving this?

208
00:09:52,570 --> 00:09:55,240
那么，让我提议我们引入另一个关键词
Well, let me propose that we introduce another keyword

209
00:09:55,240 --> 00:09:57,760
我们的蟒蛇词汇，也就是 elif。
to our Python vocabulary, namely elif.

210
00:09:57,760 --> 00:09:59,830
这个也很简洁。
And this, too, is kind of a succinct one.

211
00:09:59,830 --> 00:10:02,770
这是 else 的连词，如果在英语中,
It's a conjunction of else if, in English,

212
00:10:02,770 --> 00:10:07,960
这使我们能够提出一个问题，考虑到是否
which allows us to ask a question that takes into account whether or not

213
00:10:07,960 --> 00:10:10,840
以前的问题有正确或错误的答案。
a previous question had a true or false answer.

214
00:10:10,840 --> 00:10:12,110
我这话什么意思？
Well, what do I mean by that?

215
00:10:12,110 --> 00:10:13,810
好吧，让我回到我的代码。
Well, let me go back to my code here.

216
00:10:13,810 --> 00:10:17,830
让我提议，我们现在改进这个，在这里,
And let me propose that we now improve upon this, here,

217
00:10:17,830 --> 00:10:22,360
通过问自己，最终，我们怎样才能问更少的问题？
by asking ourselves, ultimately, how can we ask fewer questions?

218
00:10:22,360 --> 00:10:24,460
让我继续提议
And let me go ahead here and propose that

219
00:10:24,460 --> 00:10:30,700
而不是问如果，如果，如果，让这些条件潜在地相互作用
instead of asking if, if, if, let's make these conditions potentially mutually

220
00:10:30,700 --> 00:10:31,700
独家新闻。
exclusive.

221
00:10:31,700 --> 00:10:35,920
也就是说，我们回来后不要一直回答问题
That is to say, don't keep answering questions once we get back

222
00:10:35,920 --> 00:10:37,220
一个真实的答案。
a true answer.

223
00:10:37,220 --> 00:10:39,440
所以我要在这里修改我的代码，如下所示。
So I'm going to change my code up here as follows.

224
00:10:39,440 --> 00:10:45,160
不是问，如果，如果，我要说，如果 x 小于 y，elif x
Instead of asking if, if, if, I'm going to say, if x less than y, elif x

225
00:10:45,160 --> 00:10:50,140
大于 y 的 elif x 等于 y。
greater than y, elif x equals equals y.

226
00:10:50,140 --> 00:10:52,780
所以我要含蓄地，就像一个英国人,
So I'm going to implicitly, just like an English,

227
00:10:52,780 --> 00:10:57,520
考虑到我只会一直问自己这些问题
take into account that I'm only going to keep asking myself these questions

228
00:10:57,520 --> 00:11:00,340
如果我还没有得到真正的回应。
if I haven't yet gotten a true response.

229
00:11:00,340 --> 00:11:02,080
想想这里的逻辑，英国人。
Think about the logic here, the English.

230
00:11:02,080 --> 00:11:07,660
如果 x 小于 y，在第四行，打印出 x 小于 y。
If x is less than y, on line four, print out x is less than y.

231
00:11:07,660 --> 00:11:10,300
如果是这样的话，逻辑上你就完了。
Well, if that's the case, you're done, logically.

232
00:11:10,300 --> 00:11:15,670
因为如果英国人说如果 x 小于 y 否则如果 x 大于 y,
Because if the English is saying if x less than y, else if x greater than y,

233
00:11:15,670 --> 00:11:19,030
如果第一个问题的答案是相互排斥的
those are going to be mutually exclusive if the answer to the first question

234
00:11:19,030 --> 00:11:19,625
是真的。
is true.

235
00:11:19,625 --> 00:11:22,750
你不必一直问那些你逻辑上已经知道的问题
You don't have to keep asking questions to which you already logically know

236
00:11:22,750 --> 00:11:23,570
答案。
the answer.

237
00:11:23,570 --> 00:11:25,418
现在让我继续运行这个程序。
So let me go ahead now and run this program.

238
00:11:25,418 --> 00:11:27,460
我认为行为会是一样的。
And I think the behavior is going to be the same.

239
00:11:27,460 --> 00:11:29,710
Python 的 compare.py，x 是什么？
Python of compare.py, what's x?

240
00:11:29,710 --> 00:11:30,550
让我们做一个。
Let's do one.

241
00:11:30,550 --> 00:11:31,210
Y 是什么？
What's y?

242
00:11:31,210 --> 00:11:32,400
我们做两个。
Let's do two.

243
00:11:32,400 --> 00:11:33,910
X 小于 y。
x is less than y.

244
00:11:33,910 --> 00:11:37,330
说实话，我在运行程序的时候并没有发现有什么不同。
Now, honestly, I didn't really notice a difference when I ran the program.

245
00:11:37,330 --> 00:11:41,020
说实话，现在我的 Mac 电脑，手机,
And honestly, my Mac, my PC, my phone nowadays,

246
00:11:41,020 --> 00:11:44,020
如此之快，以至于这些改进
are so darn fast that these kinds of improvements

247
00:11:44,020 --> 00:11:47,110
不会感觉更快，直到我们
aren't going to necessarily feel any faster until we're

248
00:11:47,110 --> 00:11:49,300
编写更大、更快的程序。
writing bigger, faster programs.

249
00:11:49,300 --> 00:11:52,640
但它为长期编写更好的代码奠定了基础。
But it's laying the foundation for writing better code longer term.

250
00:11:52,640 --> 00:11:54,640
我刚才的进步是什么？
Now what is the improvement I've just made?

251
00:11:54,640 --> 00:11:57,650
如果之前我的图像是这样的,
Well, if previously my diagram looked like this,

252
00:11:57,650 --> 00:12:02,740
问题是我问了三个问题
which was problematic insofar as I was asking three questions no matter

253
00:12:02,740 --> 00:12:06,280
什么，即使我已经想好要在屏幕上打印什么了。
what, even if I already figured out what I want to print on the screen.

254
00:12:06,280 --> 00:12:10,720
这个程序的新版本说如果，elif，elif
This new version of the program that says if, elif, elif, might look

255
00:12:10,720 --> 00:12:12,460
而不是像这样的小东西。
a little something like this instead.

256
00:12:12,460 --> 00:12:13,630
现在又宽了一点。
Now it got a little wider.

257
00:12:13,630 --> 00:12:16,390
那是因为我们把箭头画得更宽了。
That's just because we drew the arrows to be a bit wider here.

258
00:12:16,390 --> 00:12:19,030
但是让我们关注一下到底有多少问题被问到。
But let's focus on just how many questions are getting asked.

259
00:12:19,030 --> 00:12:20,950
让我像之前一样放大顶部。
Let me zoom in at the top, as before.

260
00:12:20,950 --> 00:12:25,030
让我提议，我们注意到起始椭圆在顶部,
And let me propose that we note that the start oval is at the very top,

261
00:12:25,030 --> 00:12:27,400
它要求我们先问一个问题。
and it's asking us to ask one question first.

262
00:12:27,400 --> 00:12:29,980
X 小于 y 1小于2吗？
x less than y, is one less than two?

263
00:12:29,980 --> 00:12:33,400
但是注意这里，让我放大，如果一个的确是更小的
But notice here, let me zoom out, if one is, indeed, less

264
00:12:33,400 --> 00:12:39,550
两个以上，我们沿着这个长箭头向下，标记为真。
than two, we follow this longer arrow down, marked true.

265
00:12:39,550 --> 00:12:42,580
我们打印出引号，引号 x 小于 y。
We print out quote, unquote x is less than y.

266
00:12:42,580 --> 00:12:48,160
然后我们立即沿着下一个箭头向下到达说“停止”的图标。
But then we immediately follow this next arrow down to the icon that says stop.

267
00:12:48,160 --> 00:12:51,670
这就是所谓的 if，elif，elif。
So that's what's implied by doing if, elif, elif.

268
00:12:51,670 --> 00:12:55,210
如果我们马上得到一个真实的答案,
If we get back a true answer right away to that first if,

269
00:12:55,210 --> 00:12:57,700
我们要打印出 x 小于 y 然后停止。
we're going to print out x is less than y and then stop.

270
00:12:57,700 --> 00:12:59,870
从逻辑上讲，我们在程序的最后。
We're logically at the end of the program.

271
00:12:59,870 --> 00:13:03,190
所以这张图片只是用图形表示,
So this picture is just representing, graphically,

272
00:13:03,190 --> 00:13:05,650
代码到底在做什么。
what the code is actually doing.

273
00:13:05,650 --> 00:13:07,330
但假设我输入了别的东西。
But suppose I typed in something else.

274
00:13:07,330 --> 00:13:13,450
假设我的代码确实运行了，输入了两个 x 和一个 y。
Suppose that my code actually ran, and I typed in two for x and one for y.

275
00:13:13,450 --> 00:13:16,430
也就是说，第一个问题的答案现在是错误的。
That is to say, the answer to the first question is now false.

276
00:13:16,430 --> 00:13:19,000
但第二个问题的答案现在是正确的。
But the answer to the second question is now true.

277
00:13:19,000 --> 00:13:23,340
因为，当然，二比一大。
Because, of course, two is greater than one.

278
00:13:23,340 --> 00:13:25,240
好吧，让我们回到图表上。
Well, let's go back to the diagram.

279
00:13:25,240 --> 00:13:28,570
和以前一样，我们从最上面写着开始的地方开始。
Same as before, we start at the very top where it says start.

280
00:13:28,570 --> 00:13:33,520
这里的第一个问题，现在，x 小于 y，是一个错误的答案,
The very first question up here, now, x less than y, is an answer of false,

281
00:13:33,520 --> 00:13:35,950
因为不，二不等于一。
because no, two is not less than one.

282
00:13:35,950 --> 00:13:39,190
所以我们沿着这个箭头找到下一个问题，这颗钻石。
So we follow this arrow to the next question, this diamond.

283
00:13:39,190 --> 00:13:40,840
X 大于 y 吗？
Is x greater than y?

284
00:13:40,840 --> 00:13:43,660
是的，两个比一个大。
Well, yes, two is greater than one.

285
00:13:43,660 --> 00:13:47,510
现在我们沿着这个左箭头，这是真的。
So now we follow this left arrow, which is true.

286
00:13:47,510 --> 00:13:52,250
我们打印出引号，引号 x 大于 y，然后停止。
We print out quote, unquote x is greater than y, and then stop.

287
00:13:52,250 --> 00:13:53,530
有什么进步吗？
So what's the improvement?

288
00:13:53,530 --> 00:13:55,810
在第一种情况下，我们很幸运
Well, in the first case, we got lucky and we only

289
00:13:55,810 --> 00:13:58,090
只要问一个问题，就搞定了。
had to ask one question and boom, we're done.

290
00:13:58,090 --> 00:14:01,420
这次，我们得问两个问题，然后砰，我们就完事了。
This time, we had to ask two questions, but then boom, we're done.

291
00:14:01,420 --> 00:14:07,390
只有当 x 恰好等于 y 时，我们才能找到自己，逻辑上,
Only if x happens to equal y do we actually find ourselves, logically,

292
00:14:07,390 --> 00:14:11,620
一直到我的代码中的最后一个小精灵。
getting all the way down to this final elif in my code.

293
00:14:11,620 --> 00:14:14,830
如图所示，只有当 x 等于 y 的时候
And pictorially, only if x is equal to y do

294
00:14:14,830 --> 00:14:17,980
我们发现自己一直走到第三颗钻石,
we find ourselves going all the way down to the third diamond,

295
00:14:17,980 --> 00:14:23,020
第三个问题，是否等于 y？
the third question, asking is it equal to y or not?

296
00:14:23,020 --> 00:14:25,850
现在，希望这个问题的答案不是错误的。
Now, hopefully, the answer at that point is not false.

297
00:14:25,850 --> 00:14:28,953
我们加入了一个错误的箭头，这样程序本身
We've included a false arrow just so that the program itself

298
00:14:28,953 --> 00:14:29,620
定义明确。
is well-defined.

299
00:14:29,620 --> 00:14:33,520
但从逻辑上讲，我们不应该真的到达那里,
But, logically, we shouldn't actually be getting there anyway,

300
00:14:33,520 --> 00:14:37,242
因为在这种情况下，它必须小于，大于，等于。
because it's got to be less than, or greater than, or equal to in this case.

301
00:14:37,242 --> 00:14:38,950
让我暂停一下，看看有没有
Well, let me pause here to see if there's

302
00:14:38,950 --> 00:14:42,340
任何问题，现在，要么在这里的代码版本,
any questions, now, either on the code version thereof here,

303
00:14:42,340 --> 00:14:47,090
或者在这个逻辑图上。
or on this diagramming of that very same logic.

304
00:14:47,090 --> 00:14:52,130
关于这个控制流有什么问题吗？
Questions here, on this control flow?

305
00:14:52,130 --> 00:14:55,872
我们不是应该在最后加一个 else 吗？
SPEAKER 1: Aren't we supposed to put an else at the end?

306
00:14:55,872 --> 00:14:57,080
问得好。
DAVID MALAN: A good question.

307
00:14:57,080 --> 00:15:00,103
是的，这将是我的第三个也是最后一个方法。
And yes-- so that's going to be my third and final approach.

308
00:15:00,103 --> 00:15:02,270
如果你不介意的话，我们现在就开始吧。
And if you don't mind, let's pivot there right away.

309
00:15:02,270 --> 00:15:04,820
确定第三个关键词，这个确实存在
Identifying a third keyword, that indeed exists

310
00:15:04,820 --> 00:15:09,020
在 Python 中，这使我们能够更好地表达这种逻辑
in Python, that allows us to be even better at expressing this logic

311
00:15:09,020 --> 00:15:10,950
把这个程序设计得更好。
to design this program even better.

312
00:15:10,950 --> 00:15:13,560
这将解决一个特殊的问题。
And that's going to solve a particular problem.

313
00:15:13,560 --> 00:15:16,820
如果我们回到这里的代码，注意
So if I take us back to our code here, notice

314
00:15:16,820 --> 00:15:20,750
我之前突出显示的 elif x 等于 y。
that what I've highlighted earlier, elif x equals equals y.

315
00:15:20,750 --> 00:15:23,180
问这个问题并没有错。
It's not wrong to ask that question.

316
00:15:23,180 --> 00:15:25,730
事实上，如果你想特别彻底,
In fact, if you're trying to be especially thorough,

317
00:15:25,730 --> 00:15:29,660
检查 x 是否小于 y 大于 y 非常有意义,
it makes perfect sense to check if x is less than y, greater than y,

318
00:15:29,660 --> 00:15:31,010
或等于 y。
or equal to y.

319
00:15:31,010 --> 00:15:37,280
但为什么我不需要问第三个也是最后一个问题呢？
But why don't I need to ask this third and final question?

320
00:15:37,280 --> 00:15:42,080
我们不需要再问 x 是否等于 y 了，因为从逻辑上讲,
SPEAKER 2: We don't need to ask if x is equal to y any more because, logically,

321
00:15:42,080 --> 00:15:45,320
如果这两个条件句的计算结果为 false,
if the two conditionals evaluate to false,

322
00:15:45,320 --> 00:15:50,250
只有一个条件会求值为 true。
there is only one conditional that will evaluate to true.

323
00:15:50,250 --> 00:15:51,885
也就是 x 等于 y。
And that is x is equal to y.

324
00:15:51,885 --> 00:15:52,760
没错。
DAVID MALAN: Exactly.

325
00:15:52,760 --> 00:15:55,250
如果我们对数学和比较都很熟悉的话
If we're all pretty comfortable with math, and comparisons

326
00:15:55,250 --> 00:15:58,820
这里，当然 x 要么小于 y 要么大于 y,
here, of course x is either going to be less than y, greater than y,

327
00:15:58,820 --> 00:15:59,750
或等于 y。
or equal to y.

328
00:15:59,750 --> 00:16:02,150
但一旦你排除了前两种情况,
But once you rule out the first two scenarios,

329
00:16:02,150 --> 00:16:05,270
逻辑上来说，x 必须等于 y。
logically, it's got to be the case that x must equal y.

330
00:16:05,270 --> 00:16:08,060
如果不是这样，那就是小于或大于。
If it wasn't the case, then it's less than or greater than.

331
00:16:08,060 --> 00:16:11,220
所以 Hope 建议我们用另一个关键词 else。
So Hope proposed that we use this other keyword, else.

332
00:16:11,220 --> 00:16:12,210
我们怎么用这个？
And how do we use this?

333
00:16:12,210 --> 00:16:13,752
就像我们用英语说的一样。
Well, exactly as we might in English.

334
00:16:13,752 --> 00:16:15,110
让我回到我的代码。
Let me go back to my code here.

335
00:16:15,110 --> 00:16:18,830
我没有问第三个也是最后一个问题,
And instead of bothering to ask the third and final question,

336
00:16:18,830 --> 00:16:20,330
我们还是别问问题了。
let's not ask a question at all.

337
00:16:20,330 --> 00:16:24,630
让我们来看看这个全面的代码，也就是说，最后一行代码说,
Let's just have this catch-all. so to speak, a final line of code that says,

338
00:16:24,630 --> 00:16:27,830
否则就假设 x 等于 y。
else just assume that x is equal to y.

339
00:16:27,830 --> 00:16:29,682
因此，也要打印出来。
Therefore, printing it as well.

340
00:16:29,682 --> 00:16:30,890
那有什么好处呢？
So what's the upside of that?

341
00:16:30,890 --> 00:16:33,570
我的代码还是一样的。
My code is still going to work exactly the same.

342
00:16:33,570 --> 00:16:35,690
再说一次，我的电脑太快了
And again, my computer is so darn fast, I

343
00:16:35,690 --> 00:16:39,480
甚至没有注意到它比以前工作得更快了。
don't even notice that it's working even faster than it was before.

344
00:16:39,480 --> 00:16:41,210
但是我们会注意到这些事情
But we would notice these kinds of things

345
00:16:41,210 --> 00:16:44,210
如果我们在这里做更多的工作，更大的项目。
if we were doing a lot more work, a lot bigger programs here.

346
00:16:44,210 --> 00:16:46,400
但是让我运行 compare.py 的 Python。
But let me run Python of compare.py.

347
00:16:46,400 --> 00:16:49,670
举个例子，一和二。
Let's do, for instance, one and two.

348
00:16:49,670 --> 00:16:50,720
现在还有用。
Still works for that.

349
00:16:50,720 --> 00:16:52,460
我们来做二加一。
Let's do two and one.

350
00:16:52,460 --> 00:16:53,630
现在还有用。
Still works for that.

351
00:16:53,630 --> 00:16:55,340
我们一对一。
Let's do one and one.

352
00:16:55,340 --> 00:16:57,540
事实上，它现在对此很有效。
And it, indeed, now works for that.

353
00:16:57,540 --> 00:17:01,370
但是在这些情况下，让我们考虑一下我们刚刚走下去的路径。
But in these cases now, let's consider the path we just went down.

354
00:17:01,370 --> 00:17:05,900
以前，我们的图表，当我们有如果，elif，elif 到位,
Previously, our diagram, when we had if, elif, elif in place,

355
00:17:05,900 --> 00:17:07,920
看起来有点像这个。
looked a little something like this.

356
00:17:07,920 --> 00:17:11,990
注意，他们开始，我们可能会问一两个问题,
And notice, they began, we might have asked one question, or two,

357
00:17:11,990 --> 00:17:13,910
或者最坏的情况，三个完整的问题。
or worst case, three whole questions.

358
00:17:13,910 --> 00:17:17,329
但我们可以做得更好用别的方法，就像霍普建议的那样,
But we can do better than that, using else, as Hope proposed,

359
00:17:17,329 --> 00:17:19,582
我们可以把这个图缩小到这个。
we can whittle this diagram, now, down to this.

360
00:17:19,582 --> 00:17:22,040
尽管图表看起来越来越大,
And even though it looks like the diagram's getting bigger,

361
00:17:22,040 --> 00:17:25,730
注意到它里面的积木越来越少。
notice that it's having fewer building blocks inside of it.

362
00:17:25,730 --> 00:17:29,240
这张图中的箭头和节点都比较少。
There's fewer arrows and there's fewer nodes in this picture.

363
00:17:29,240 --> 00:17:30,620
我们从头开始吧。
Let's start at the top now.

364
00:17:30,620 --> 00:17:34,160
开始引导我们到第一个问题，仍然。 x 小于 y？
Start leads us to the first question, still. x less than y?

365
00:17:34,160 --> 00:17:35,600
如果答案是真的，很好。
If the answer is true, great.

366
00:17:35,600 --> 00:17:38,420
我们可以这么说，x 小于 y，我们可以停止。
We can say as much, x is less than y, and we can stop.

367
00:17:38,420 --> 00:17:41,450
如果不是真的，如果是假的，我们可以问下一个问题。
If it's not true, if it's false, we can ask the next question.

368
00:17:41,450 --> 00:17:43,820
X 大于 y，对还是错？
x is greater than y, true or false?

369
00:17:43,820 --> 00:17:44,840
如果是的话，很好。
If it is, great.

370
00:17:44,840 --> 00:17:47,270
我们可以打印 x 大于 y 然后停止。
We can print x is greater than y, and stop.

371
00:17:47,270 --> 00:17:51,510
否则，如果 x 不大于 y，那么答案就是假的。
Else, if it's not the case that x is greater than y, the answer is false.

372
00:17:51,510 --> 00:17:56,060
我们可以立即，逻辑上说 x 等于 y。
We can just immediately, logically, say x is equal to y.

373
00:17:56,060 --> 00:17:58,610
我们根本不需要加上第三个问题。
We don't have to add the third question at all.

374
00:17:58,610 --> 00:18:00,740
我们可以马上得出结论。
We can just immediately conclude there.

375
00:18:00,740 --> 00:18:02,150
那么这意味着什么呢？
So what's the implication here?

376
00:18:02,150 --> 00:18:05,180
你可以看到，通过这些图片，一个相对的下降
You can see, with these pictures, a relative decrease

377
00:18:05,180 --> 00:18:07,140
在程序的复杂性中。
in the complexity of a program.

378
00:18:07,140 --> 00:18:10,670
第一个很长很细，有很多很多的问题,
The first one was very long and stringy, with lots and lots of questions,

379
00:18:10,670 --> 00:18:12,283
不必要的，最终。
unnecessarily, ultimately.

380
00:18:12,283 --> 00:18:13,700
下一个就矮了一点。
The next one got a little shorter.

381
00:18:13,700 --> 00:18:15,560
这个更短。
And this one's even shorter still.

382
00:18:15,560 --> 00:18:19,280
同样，代码行数越少，发生这种情况的可能性就越小
And again, the fewer lines of code you have, the less likely

383
00:18:19,280 --> 00:18:21,400
毫无疑问，你会犯任何错误。
you are, arguably, to make any mistakes.

384
00:18:21,400 --> 00:18:23,150
其他人读起来就越容易。
The easier it is for other people to read.

385
00:18:23,150 --> 00:18:26,930
因此，一般来说，这种可读性，这种简化,
And so, generally, this readability, this simplification,

386
00:18:26,930 --> 00:18:28,760
的确是件好事。
is, indeed, a good thing.

387
00:18:28,760 --> 00:18:33,200
那么，让我们继续向 Python 添加另一个功能,
Well, let's go ahead and add another piece of capability to Python,

388
00:18:33,200 --> 00:18:34,400
就是这个。
and that's this one here.

389
00:18:34,400 --> 00:18:37,730
就像英语一样，你可以问这个问题或者其他问题,
Just like in English, where you can ask this question or this other question,

390
00:18:37,730 --> 00:18:41,540
你可以在 Python 中使用这个单词或者。
you can say the same thing in Python using literally this word or.

391
00:18:41,540 --> 00:18:44,540
让我们回到我的 Python 代码。
So let me go back to my Python code here.

392
00:18:44,540 --> 00:18:47,150
让我们提出几个问题
And let's propose how we might ask a couple of questions

393
00:18:47,150 --> 00:18:51,860
此时此刻，也许这一次，考虑到我们可能会问不
at once this time, perhaps this time considering how we might ask not

394
00:18:51,860 --> 00:18:54,050
不管它是大于还是等于,
whether or not it's greater than or equal to,

395
00:18:54,050 --> 00:18:56,070
并且关心准确的答案。
and caring about the precise answer.

396
00:18:56,070 --> 00:18:58,190
让我们采取一个粗略的方法。
Let's take a coarser approach here.

397
00:18:58,190 --> 00:19:04,730
我们来确定 x 等于 y 还是不等于？
And let's just try to determine is x equal to y or not?

398
00:19:04,730 --> 00:19:06,980
让我来删除一些代码
Well, let me go ahead and delete some of this code

399
00:19:06,980 --> 00:19:08,540
改变我们的问题。
and change the question we're asking.

400
00:19:08,540 --> 00:19:12,290
让我这么做，如果我关心它是否平等,
Let me do this-- well, if I care about whether it's equal or not,

401
00:19:12,290 --> 00:19:14,060
我们来看看可能的情况。
let's check the possible scenarios.

402
00:19:14,060 --> 00:19:19,850
如果 x 小于 y 或者 x 大于 y 我们继续
If x is less than y or x is greater than y, let's go ahead

403
00:19:19,850 --> 00:19:23,840
并且打印出 x 不等于 y。
and print out x is not equal to y.

404
00:19:23,840 --> 00:19:26,240
这是为什么，没有双关语吗？
Now why is that, no pun intended?

405
00:19:26,240 --> 00:19:29,240
如果 x 小于 y，那么它显然不等于。
If x is less than y, well, it's obviously not equal.

406
00:19:29,240 --> 00:19:31,730
如果 x 大于 y 显然不等于。
If x is greater than y, it's obviously not equal.

407
00:19:31,730 --> 00:19:35,840
所以我们可以得出 x 不等于 y 的结论。
So we can conclude x is not equal to y.

408
00:19:35,840 --> 00:19:41,180
所以如果我们想确保它等于,
So if we, instead, want to make sure that it is equal to,

409
00:19:41,180 --> 00:19:47,940
我们可以使用 Hope 的 else，使用 print quote，unquote x 等于 y。
we can just use Hope's else, using print quote, unquote x is equal to y.

410
00:19:47,940 --> 00:19:49,410
再问一次，为什么会这样？
And again, why is this?

411
00:19:49,410 --> 00:19:52,470
如果 x 小于 y 或者 x 大于 y,
Well, if x is less than y, or x is greater than y,

412
00:19:52,470 --> 00:19:53,820
他们显然是不平等的。
they're obviously not equal.

413
00:19:53,820 --> 00:19:56,580
否则，从逻辑上讲，它们实际上必须是相等的。
Otherwise, logically, they must be equal, in fact.

414
00:19:56,580 --> 00:19:57,390
那我们来看看这个。
So let's run this.

415
00:19:57,390 --> 00:19:59,565
让我们继续运行 compare.py 的 Python。
Let's go ahead and run Python of compare.py.

416
00:19:59,565 --> 00:20:00,240
X 是什么？
What's x?

417
00:20:00,240 --> 00:20:00,930
一。
One.

418
00:20:00,930 --> 00:20:01,560
Y 是什么？
What's y?

419
00:20:01,560 --> 00:20:02,250
两个。
Two.

420
00:20:02,250 --> 00:20:03,960
X 不等于 y。
OK, x is not equal to y.

421
00:20:03,960 --> 00:20:08,550
我们再来一次，把两个代表 x，一个代表 y，x 不等于 y。
Let's do it again, put two for x, one for y. x is not equal to y.

422
00:20:08,550 --> 00:20:12,450
第三次，x 是1，y 是1怎么样。
And one third time, how about x is one and y is one.

423
00:20:12,450 --> 00:20:14,760
现在 x 等于 y。
x is now equal to y.

424
00:20:14,760 --> 00:20:17,610
现在，如果我们想在视觉上对比一下,
Now if we want to compare that visually, too,

425
00:20:17,610 --> 00:20:20,980
让我假设这幅画看起来有点像这样。
let me propose that the picture looks a little something like this.

426
00:20:20,980 --> 00:20:23,340
再说一遍，这在逻辑上是完全一样的,
And again, this is the exact same thing logically,

427
00:20:23,340 --> 00:20:25,197
但这只是一幅图画。
but it's a pictorial representation thereof.

428
00:20:25,197 --> 00:20:26,280
第一个问题是什么？
What's the first question?

429
00:20:26,280 --> 00:20:30,900
如果 x 小于 y 那我们就按照真正的箭头。
Well, if x is less than y, well, then we follow the true arrow.

430
00:20:30,900 --> 00:20:33,840
我们说，引号 x 不等于 y。
And we say quote, unquote x is not equal to y.

431
00:20:33,840 --> 00:20:35,280
然后我们停下来。
And then we stop.

432
00:20:35,280 --> 00:20:37,623
但如果 x 不小于 y 呢？
But what if x is not less than y?

433
00:20:37,623 --> 00:20:38,790
如果它比 y 大呢？
What if it's greater than y?

434
00:20:38,790 --> 00:20:40,800
如果分别是2和1呢？
What if it's two and one, respectively?

435
00:20:40,800 --> 00:20:44,590
那么 x 小于 y 的答案，第一个问题，是假的。
Then the answer to x less than y, first question, is false.

436
00:20:44,590 --> 00:20:45,480
所以我们来这里。
So we go here.

437
00:20:45,480 --> 00:20:48,720
我们问第二个问题，因为,
We ask the second question, because of the or,

438
00:20:48,720 --> 00:20:51,060
这个问题是 x 大于 y 吗？
and that asks is x greater than y?

439
00:20:51,060 --> 00:20:55,830
如果是这样，注意这个，我们可以重复使用这张图片的一些相同的部分,
If so, notice this, we can kind of reuse some of the same parts of this picture,

440
00:20:55,830 --> 00:20:58,260
就说 x 不等于 y。
and just say x is not equal to y.

441
00:20:58,260 --> 00:21:01,020
我们不需要添加不必要的箭头和广告框。
We don't need to add arrows and ad boxes unnecessarily.

442
00:21:01,020 --> 00:21:06,480
我们可以重用代码行，图片的一部分，就像我们有代码行一样。
We can reuse lines of code, parts of the picture, just as we have lines of code.

443
00:21:06,480 --> 00:21:07,620
然后我们停下来。
And then we stop.

444
00:21:07,620 --> 00:21:09,780
最后，我们有以下几点。
Lastly, we have the following.

445
00:21:09,780 --> 00:21:12,300
如果我们知道 x 不小于 y，我们就知道
If we know that x is not less than y, we know

446
00:21:12,300 --> 00:21:16,080
当 x 不大于 y 时，必须是 x 等于 y 的情况。
that x is not greater than y, it must be the case that x equals y.

447
00:21:16,080 --> 00:21:18,900
我们不需要问第三个问题，另一个钻石。
We don't need to ask a third question, another diamond.

448
00:21:18,900 --> 00:21:24,000
我们可以马上打印，然后说停止，以及。
We can just immediately print as much, and then say stop, as well.

449
00:21:24,000 --> 00:21:25,710
我能做什么？
Well, what could I do here?

450
00:21:25,710 --> 00:21:28,560
我打赌我可以稍微改进一下这个代码。
I bet I could improve this code slightly.

451
00:21:28,560 --> 00:21:31,440
如果我们真想吹毛求疵，我会的
And if we really want to be nitpicky, I would

452
00:21:31,440 --> 00:21:34,800
认为这只是一个小小的改进,
argue that this is now really just a minor refinement,

453
00:21:34,800 --> 00:21:37,410
但这是个好习惯。
but it's a good habit to get into thinking about.

454
00:21:37,410 --> 00:21:38,760
我的代码还能更好吗？
Could my code be better?

455
00:21:38,760 --> 00:21:41,100
我的代码可以更简单吗？
Could my code be simpler?

456
00:21:41,100 --> 00:21:43,740
我可以进一步改进这个代码吗？
Could I improve this code further?

457
00:21:43,740 --> 00:21:47,160
这很微妙，但我能改进一下设计吗？
It's subtle, but could I improve the design?

458
00:21:47,160 --> 00:21:48,960
我能少问几个问题吗？
Could I ask fewer questions?

459
00:21:48,960 --> 00:21:52,460
我可以把它收紧吗，可以这么说吗？
Could I tighten it up, so to speak?

460
00:21:52,460 --> 00:21:54,280
大家怎么想？
What do folks think?

461
00:21:54,280 --> 00:21:58,060
你可以问 x 等于 y。
SPEAKER 3: You can ask is x is just equal to y.

462
00:21:58,060 --> 00:22:03,625
如果你输出 x 等于 y 否则 x 不等于 y。
Then if you print x is equal to y, else x is not equal to y.

463
00:22:03,625 --> 00:22:04,500
完美。
DAVID MALAN: Perfect.

464
00:22:04,500 --> 00:22:07,560
回忆一下我们之前在可用列表中看到的其他符号之一。
Recall one of the other symbols we saw on the available list earlier.

465
00:22:07,560 --> 00:22:10,680
我们可以检查不仅小于，大于，等于。
We can check not just less than, or greater than, or equal to.

466
00:22:10,680 --> 00:22:13,410
我们可以问这个问题，它不等于？
We can literally ask the question is it not equal to?

467
00:22:13,410 --> 00:22:17,400
为什么我们要浪费时间问它是小于还是大于？
Why are we wasting time asking if it's less than or if it's greater than?

468
00:22:17,400 --> 00:22:21,100
如果你关心的只是不平等，我想我们完全可以这么做。
Well, if all you care about is is it not equal, I think we can do exactly that.

469
00:22:21,100 --> 00:22:24,610
我们只问一个我们关心的简单问题。
Let's just ask the one simple question we do care about.

470
00:22:24,610 --> 00:22:25,950
让我回到这里。
And so let me go back up here.

471
00:22:25,950 --> 00:22:29,580
我只想说，不是这两个问题，让我们去掉 or。
And let me just say not both of these questions, let's get rid of the or.

472
00:22:29,580 --> 00:22:33,840
这么说吧，如果 x 不等于 y，那就去
Let's just say if x is not equal to y, then go

473
00:22:33,840 --> 00:22:36,510
X 不等于 y。
ahead and print x is not equal to y.

474
00:22:36,510 --> 00:22:39,190
而且，我认为这也会起到同样的作用。
And that, too, I think is going to work exactly the same.

475
00:22:39,190 --> 00:22:41,980
但现在的情况看起来有点不同了。
But the picture now looks a little bit different.

476
00:22:41,980 --> 00:22:44,190
注意这是我们之前的流程图,
Notice that this was our flow chart earlier,

477
00:22:44,190 --> 00:22:45,947
代表了同样的逻辑。
that represented that same logic.

478
00:22:45,947 --> 00:22:47,280
有点复杂。
And there's a bit of complexity.

479
00:22:47,280 --> 00:22:48,690
你得左转，你得右转,
You've got to go left, you've got to go right,

480
00:22:48,690 --> 00:22:50,732
基于这几个问题的答案。
based on the answer to these couple of questions.

481
00:22:50,732 --> 00:22:53,820
如果我们现在考虑这个程序的版本,
If we now take into account what this version of the program looks like,

482
00:22:53,820 --> 00:22:56,820
它甚至更简单，也许是我们见过的最简单的一个。
it's even simpler, perhaps the simplest one we've seen yet.

483
00:22:56,820 --> 00:23:00,330
在节目开始的时候，我们只问一个问题,
When we start off the program, we ask just one, and only one, question,

484
00:23:00,330 --> 00:23:02,040
x 不等于 y 吗？
is x not equal to y?

485
00:23:02,040 --> 00:23:06,930
如果是真的，我们继续输出 x 不等于 y。
And if so, true, we go ahead and print out x not equal to y.

486
00:23:06,930 --> 00:23:10,350
如果答案是假的，那么，当然，它必须等于 y,
If the answer is false, then, of course, it must be equal to y,

487
00:23:10,350 --> 00:23:12,040
所以我们用这个代替。
so we say that instead.

488
00:23:12,040 --> 00:23:14,070
如果我们真的想要，我们可以把它倒过来。
And if we really want, we could invert this.

489
00:23:14,070 --> 00:23:17,080
如果我回到我的代码，如果，不管出于什么原因,
If I go back here to my code, and if, for whatever reason,

490
00:23:17,080 --> 00:23:20,730
你只是更愿意从平等或不平等的角度去思考,
you just prefer to think in terms of equal or not equal,

491
00:23:20,730 --> 00:23:25,270
而不是不平等或不平等，这完全取决于你。
as opposed to not equal or equal, it's really up to you.

492
00:23:25,270 --> 00:23:27,900
我们可以把它变成平等的。
We could change this to be equals equals.

493
00:23:27,900 --> 00:23:32,020
但我得把我的打印报表改成相反的顺序。
But I'm going to have to change my print statements to be in the opposite order.

494
00:23:32,020 --> 00:23:34,890
现在让我把这两个倒过来,
So let me go ahead, now, and reverse these two here,

495
00:23:34,890 --> 00:23:38,950
然后先移动第二个，再移动第一个。
and move the second one first and the first one second.

496
00:23:38,950 --> 00:23:42,240
所以现在，当我执行这段代码时，我仍然只问一个问题。
So now, when I execute this code, I'm asking still just one question.

497
00:23:42,240 --> 00:23:44,550
所以还是一样好，一样简洁。
So it's still just as good, just as succinct.

498
00:23:44,550 --> 00:23:47,070
但是现在这个图，看起来不像这样,
But now the diagram, instead of looking like this,

499
00:23:47,070 --> 00:23:50,310
将不等式改为等式。
is going to change the not equal to equal equal.

500
00:23:50,310 --> 00:23:54,400
我们只需要确保打印出来的内容是正确的。
And we just need to make sure that we print out the right thing, accordingly.

501
00:23:54,400 --> 00:23:57,990
同样，这里也是，正如代码变得更紧凑一点，一点点
And again, here too, just as the code is getting a little more compact, a little

502
00:23:57,990 --> 00:24:00,330
更紧凑，字符越来越少,
more compact, with fewer and fewer characters,

503
00:24:00,330 --> 00:24:05,460
所以这些图表，这些流程图捕捉相对简化
so are these diagrams, these flow charts capturing the relative simplification

504
00:24:05,460 --> 00:24:08,040
每一个项目也是如此。
of each of those programs, too.

505
00:24:08,040 --> 00:24:11,610
让我在这里暂停一下，看看是否有任何问题，现在，对于任何问题
Let me go ahead and pause here to see if there's any questions, now, on any

506
00:24:11,610 --> 00:24:13,140
这些版本的代码。
of these versions of code.

507
00:24:16,530 --> 00:24:19,150
我有几个问题。
SPEAKER 4: Yeah, I have a couple of questions.

508
00:24:19,150 --> 00:24:22,380
如果没有使用缩进呢？
What if indentation is not used?

509
00:24:22,380 --> 00:24:25,600
马兰: 如果不使用缩进，你的程序将无法工作。
DAVID MALAN: If indentation is not used, your program will not work.

510
00:24:25,600 --> 00:24:28,080
所以巨蟒和其他的有些不同
So Python is a little different from a lot

511
00:24:28,080 --> 00:24:32,100
的语言，因为它强制缩进的要求。
of languages in that it enforces the indentation requirement.

512
00:24:32,100 --> 00:24:34,080
你们中有些人已经编程多年了
Some of you who have been programming for years

513
00:24:34,080 --> 00:24:37,800
可能不一定是正确缩进代码的最佳习惯。
might not necessarily be in the best habit of indenting your code properly.

514
00:24:37,800 --> 00:24:40,170
可以说，Python 的一个特性
And one of the features, arguably, of Python

515
00:24:40,170 --> 00:24:44,850
它使你缩进你的代码，否则它不仅仅是工作。
is that it makes you indent your code, or it will not just work.

516
00:24:44,850 --> 00:24:47,460
我想，你还有别的问题吗？
And I think, did you have one other question?

517
00:24:47,460 --> 00:24:50,820
有必要结肠吗？
SPEAKER 4: Yeah, is the colon necessary?

518
00:24:50,820 --> 00:24:52,530
大卫. 马兰: 需要结肠吗？
DAVID MALAN: Is the colon necessary?

519
00:24:52,530 --> 00:24:55,150
是的，结肠也是必要的。
Yes, the colon, too, is necessary.

520
00:24:55,150 --> 00:24:57,960
所以对于巨蟒，你看到的就是你在这里看到的。
So with Python, what you see is what you get here.

521
00:24:57,960 --> 00:25:01,020
实际上，它需要缩进，而冒号是必需的。
And, indeed, it needs to be indented and the colon is necessary.

522
00:25:01,020 --> 00:25:05,670
Python 不像 C、 C + + 和 Java 那样按照约定使用,
Python does not use, in the same way by convention as C, and C++, and Java,

523
00:25:05,670 --> 00:25:07,410
从花括号到内涵块。
curly braces to connote blocks.

524
00:25:07,410 --> 00:25:10,680
相反，它确实依赖于这种缩进。
Instead, it relies, indeed, on this indentation.

525
00:25:10,680 --> 00:25:14,490
让我提议我们在 Python 中引入另一个关键字,
Well, let me propose that we introduce one other keyword here in Python,

526
00:25:14,490 --> 00:25:17,310
看看我们如何结合额外的想法。
to see exactly how we might combine additional thoughts.

527
00:25:17,310 --> 00:25:20,490
这就是字面上的意思，一个词的连词,
And that's going to be literally the word and, a conjunction of one,

528
00:25:20,490 --> 00:25:24,690
或者两个，或者更多的问题。
or two, or more questions that we might want to ask at once.

529
00:25:24,690 --> 00:25:28,650
让我提议，在这里，我们探索这种逻辑
And let me propose, here, that we explore this kind of logic

530
00:25:28,650 --> 00:25:32,400
通过另一个程序，在 VS 代码中，我现在继续
by way of another program altogether, in VS Code, whereby I'll go ahead now

531
00:25:32,400 --> 00:25:35,760
然后创建一个新程序，比如，叫做 grade.py。
and create a new program, say, called grade.py.

532
00:25:35,760 --> 00:25:38,160
让我们来看看一个学生应该得到什么分数,
Let's consider exactly what grade a student should get,

533
00:25:38,160 --> 00:25:40,950
根据他们在考试、测验或测验中的成绩,
based on their score on an exam, or a test, or a quiz,

534
00:25:40,950 --> 00:25:42,900
或者其他类似的任务。
or some other assignment like that.

535
00:25:42,900 --> 00:25:46,513
我将继续运行 grade.py 代码，为自己创建一个新文件。
I'm going to go ahead and run code of grade.py, to give myself a new file.

536
00:25:46,513 --> 00:25:49,680
然后我会继续，从得到用户的得分开始，再一次,
And I'm going to go ahead and start by just getting the user's score, again,

537
00:25:49,680 --> 00:25:51,700
在某些作业，或测试，或类似的。
on some assignment, or test, or the like.

538
00:25:51,700 --> 00:25:55,200
我要把它存储在一个叫做 score 的变量里，等于返回值
And I'm going to store it in a variable called score, equal the return

539
00:25:55,200 --> 00:25:58,320
整型函数的值，它将转换用户的
value of the int function, which is going to convert whatever the user's

540
00:25:58,320 --> 00:26:00,610
当提示输入这个分数时。
input is when prompted for this score.

541
00:26:00,610 --> 00:26:04,650
所以，用户只需要给我一个数字，比如0或者1,
So again, the user should just oblige by giving me a number like zero, or one,

542
00:26:04,650 --> 00:26:09,090
或者更高，比如97,98,99,100,
or two, or hopefully much higher than that, like 97, 98, 99, 100,

543
00:26:09,090 --> 00:26:13,330
假设测试或评估满分为100分。
assuming the test or assessment is out of 100 percentage points.

544
00:26:13,330 --> 00:26:17,220
现在，我该怎么给学生的分数打分呢？
Now, how could I go about assigning a grade to the student's score?

545
00:26:17,220 --> 00:26:19,710
在美国，这种情况非常普遍
Well in the US, it's very commonly the case

546
00:26:19,710 --> 00:26:22,500
如果你的分数在90到100之间，那就是 A。
that if you get between a 90 and 100, that's an A.

547
00:26:22,500 --> 00:26:29,160
如果在80和89之间就是 B 如果是70和79就是 C,
And if it's between an 80 and a 89, it's a B. If it's 70 and 79, it's a C,

548
00:26:29,160 --> 00:26:32,558
以此类推，一直到 F 应该是 E,
and so forth, all the way down to F, which should be E,

549
00:26:32,558 --> 00:26:34,350
但我们会看到有一点跳跃。
but we'll see that there's a bit of a jump.

550
00:26:34,350 --> 00:26:35,572
我该怎么表达呢？
So how might I express this?

551
00:26:35,572 --> 00:26:36,780
我可以用条件句。
Well, I can use conditionals.

552
00:26:36,780 --> 00:26:39,750
我可以问几个问题，然后打印出学生的成绩
And I can ask a few questions and then print out the student's grade

553
00:26:39,750 --> 00:26:40,600
因此。
accordingly.

554
00:26:40,600 --> 00:26:44,040
如果学生的分数是
So let me express it like this, if the student's score is

555
00:26:44,040 --> 00:26:47,820
大于或等于90，学生的分数是
greater than or equal to 90, and the student's score is

556
00:26:47,820 --> 00:26:51,750
小于或等于100，所以在这个范围内，继续
less than or equal to 100, so it's in that range, let's go ahead

557
00:26:51,750 --> 00:26:55,980
打印出他们的成绩应该是 A 因为他们是90后,
and print out that their grade shall be an A. Because they're in the 90s,

558
00:26:55,980 --> 00:26:58,080
以上级别范围。
above grades range.

559
00:26:58,080 --> 00:27:02,580
如果分数大于等于80,
elif the score is greater than or equal to 80,

560
00:27:02,580 --> 00:27:07,980
得分小于或等于，比如说，89，但是这里我有一些选择。
and the score is less than or equal to, say, 89, but here I have some options.

561
00:27:07,980 --> 00:27:11,050
逻辑上，我可以用任何方式表达自己。
Logically, I can actually express myself in any number of ways.

562
00:27:11,050 --> 00:27:12,800
也许只是为了更干净一点，我
And maybe just to be a little cleaner, I'm

563
00:27:12,800 --> 00:27:15,060
得分低于90。
going to say a score is less than 90.

564
00:27:15,060 --> 00:27:18,300
所以我使用的是 less than 而不是 less 小于等于。
So I'm using less than instead of less than or equal to.

565
00:27:18,300 --> 00:27:21,690
所以我要确保他们的分数界限是正确的。
So I'm making sure that their boundaries between these grades are correct.

566
00:27:21,690 --> 00:27:26,460
然后，如果学生的成绩是80分，我就给他 B。
Then, I'm going to go ahead and give the student a B if it's in the 80s.

567
00:27:26,460 --> 00:27:31,770
Elif 得分大于或等于70，且得分小于80,
elif score is greater than or equal to 70, and the score is less than 80,

568
00:27:31,770 --> 00:27:34,851
我要给他们打个 C。
I'm going to go ahead and give them a C.

569
00:27:34,851 --> 00:27:40,380
如果得分大于或等于60，且得分小于70,
elif the score is greater than or equal to 60, and the score is less than 70,

570
00:27:40,380 --> 00:27:43,080
我要给他打个 D
I'm going to go ahead and give him a D. And here's

571
00:27:43,080 --> 00:27:46,380
至少在这里的一些学校是有点反常的，还有呢
where it's a little anomalous, at least in some schools here, else

572
00:27:46,380 --> 00:27:51,060
我会给他们一个 F 所以我们一起跳过 E,
I'm going to go ahead and give them an F. So we're skipping E altogether,

573
00:27:51,060 --> 00:27:53,760
而我们的成绩是 F。
and we're going to give an F, instead, for the grade.

574
00:27:53,760 --> 00:27:55,080
这就是我要说的。
So that's the catch-all.

575
00:27:55,080 --> 00:27:58,020
我想，从逻辑上来说，我是对的,
And I think, logically, I've gotten this correct,

576
00:27:58,020 --> 00:28:00,360
至少从我小时候的学校来看,
at least based on where I went to school growing up,

577
00:28:00,360 --> 00:28:03,950
这样就会得到 A 或者 B 或者 C 或者 D,
such that it's going to give an A, or a B, or a C, or a D,

578
00:28:03,950 --> 00:28:06,512
否则它就会假设你得了个 F。
else it's going to assume that you got an F.

579
00:28:06,512 --> 00:28:08,220
好吧，让我们试试这里的一些。
Well, let's try just a few of these here.

580
00:28:08,220 --> 00:28:10,260
让我们运行 grade.py 的 Python。
Let's run Python of grade.py.

581
00:28:10,260 --> 00:28:13,650
我的分数是，让我们开始强大，100。
My score is, let's start strong, 100.

582
00:28:13,650 --> 00:28:17,040
我得了个 A 下次就没那么好了，也许是95分
I got an A. Didn't do as well the next time, maybe it's a 95--

583
00:28:17,040 --> 00:28:21,270
还是 A 开始下滑，所以下次我得了89分。
still an A. Starting to slip further, so I got an 89 the next time.

584
00:28:21,270 --> 00:28:25,320
现在是 B 了，假设我这周过得很糟糕,
That's now, say, a B. And let's say I really had a bad week,

585
00:28:25,320 --> 00:28:27,030
现在是71分。
and it's now a 71.

586
00:28:27,030 --> 00:28:31,830
现在是 C 了，或者我根本没提交，完全是 F。
That's now a C. Or I didn't even submit it at all, that's an F, altogether.

587
00:28:31,830 --> 00:28:32,940
看起来有用。
So it seems to work.

588
00:28:32,940 --> 00:28:35,070
这并不是一个详尽的测试，但至少
That's not really an exhaustive test, but at least

589
00:28:35,070 --> 00:28:38,810
基于那里的一些采样，我的代码似乎像我期望的那样工作。
based on some sampling there, my code seems to work as I expect.

590
00:28:38,810 --> 00:28:40,560
看看我们能不能把这个弄紧点。
But let's see if we can't tighten this up.

591
00:28:40,560 --> 00:28:41,220
这没错。
It's not wrong.

592
00:28:41,220 --> 00:28:42,070
没错。
It's correct.

593
00:28:42,070 --> 00:28:44,070
事实上，根据我自己的说明,
And, indeed, according to my own specifications,

594
00:28:44,070 --> 00:28:45,510
我敢说这个密码是正确的。
I dare say this code is correct.

595
00:28:45,510 --> 00:28:46,710
但是我们能收紧吗？
But can we tighten it up?

596
00:28:46,710 --> 00:28:50,500
我们现在还是以后能够降低错误的可能性吗？
Can we reduce the probability of bugs, now or down the line?

597
00:28:50,500 --> 00:28:52,230
我们可以提高它的可读性吗？
Can we increase the readability of it?

598
00:28:52,230 --> 00:28:54,030
我们能提高它的效率吗？
And can we increase the efficiency of it?

599
00:28:54,030 --> 00:28:57,690
我们能让电脑少回答一些问题吗
Can we get the computer to have to answer fewer questions

600
00:28:57,690 --> 00:28:59,375
结果还是一样？
and still get the same result?

601
00:28:59,375 --> 00:29:00,750
看看我们能做什么。
Well, let's see what we might do.

602
00:29:00,750 --> 00:29:03,690
让我换个方式来证明我们可以
Let me just switch things up, if only to demonstrate that we can

603
00:29:03,690 --> 00:29:05,760
以不同的方式使用这些符号。
use these symbols in different ways.

604
00:29:05,760 --> 00:29:10,200
我可以这样说，如果分数大于或等于90。
I could say, as I've done, if score is greater than or equal to 90.

605
00:29:10,200 --> 00:29:12,570
但我真的可以做到，我可以把它翻过来。
But I can actually do this, I can flip it around.

606
00:29:12,570 --> 00:29:14,800
不是说大于或等于,
Instead of saying greater than or equal to,

607
00:29:14,800 --> 00:29:19,060
假设90小于或等于得分。
let's say 90 is less than or equal to score.

608
00:29:19,060 --> 00:29:23,980
这里，假设80小于等于得分。
And here, let's say if 80 is less than or equal to score.

609
00:29:23,980 --> 00:29:28,180
这里，70小于或等于得分。
And here, 70 is less than or equal to score.

610
00:29:28,180 --> 00:29:31,390
最后，60小于等于得分。
And then, lastly, 60 is less than or equal to score.

611
00:29:31,390 --> 00:29:33,370
所以从逻辑上讲，这是一回事。
So it's the same thing, logically.

612
00:29:33,370 --> 00:29:36,460
我只是把东西换一下，就像你在纸笔上做的那样
I'm just switching things around, just like you could do on paper pencil

613
00:29:36,460 --> 00:29:37,670
如果你真的想的话。
if you really wanted.

614
00:29:37,670 --> 00:29:39,200
但现在注意这个小把戏。
But now notice this trick.

615
00:29:39,200 --> 00:29:42,460
对于那些用 C 或者 C + + 编程的人来说这是不可能的,
And this is not possible, for those of you who have programmed in C, or C++,

616
00:29:42,460 --> 00:29:44,320
或者 Java 或者其他语言。
or Java, or other languages.

617
00:29:44,320 --> 00:29:48,760
注意，我可以把这些范围结合起来。
Notice what I can do here is actually combine these ranges.

618
00:29:48,760 --> 00:29:52,000
注意我在问两个问题，两个布尔表达式。
Notice that I'm asking two questions, two Boolean expressions.

619
00:29:52,000 --> 00:29:57,250
90是否小于或等于得分，得分是否小于或等于100？
Is 90 less than or equal to score, and is score less than or equal to 100?

620
00:29:57,250 --> 00:30:01,150
巨蟒允许你像这样嵌入这些东西,
Well, Python allows you to nest these things like this,

621
00:30:01,150 --> 00:30:02,680
把他们锁在一起。
and chain them together.

622
00:30:02,680 --> 00:30:06,070
就像你在现实生活中用纸笔写字一样,
And just like you would on paper pencil in the real world,

623
00:30:06,070 --> 00:30:09,732
你可以用 Python 编码，这样做，这样会更干净一点。
you can encode in Python, do this, which is just a little cleaner.

624
00:30:09,732 --> 00:30:11,440
密码有点紧了。
It's tightening up the code a little bit.

625
00:30:11,440 --> 00:30:12,550
敲键盘的次数更少。
It's fewer keystrokes.

626
00:30:12,550 --> 00:30:13,660
打字更快。
It's faster to type.

627
00:30:13,660 --> 00:30:15,530
向前看更容易理解。
It's easier to read, moving forward.

628
00:30:15,530 --> 00:30:18,140
所以这也可以说是更好的。
So that's arguably better, as well.

629
00:30:18,140 --> 00:30:19,450
这是一个进步。
So that's one improvement.

630
00:30:19,450 --> 00:30:21,422
在这种情况下，主要是审美上的。
It's largely aesthetic, in this case.

631
00:30:21,422 --> 00:30:23,380
它仍然在问同样多的问题,
It's still asking the same number of questions,

632
00:30:23,380 --> 00:30:26,950
但它还是做得更简洁一些。
but it's doing it a little more succinctly still.

633
00:30:26,950 --> 00:30:29,500
接下来我还能做什么？
Well, what more could I do here next?

634
00:30:29,500 --> 00:30:30,730
你知道吗？
Well, you know what?

635
00:30:30,730 --> 00:30:32,920
每次我决定分数的时候，我都不知道
Each time I'm deciding these grades, I don't

636
00:30:32,920 --> 00:30:34,940
我想我得问两个问题。
think I have to ask two questions.

637
00:30:34,940 --> 00:30:38,290
我不用问，是大于90还是小于100？
I don't have to ask, is it greater than 90 and less than 100?

638
00:30:38,290 --> 00:30:40,840
是大于80还是小于90？
Is it greater than 80 and less than 90?

639
00:30:40,840 --> 00:30:45,070
如果我重新思考我的逻辑，也许我能做得更好。
If I rethink my logic, I can maybe do this better still.

640
00:30:45,070 --> 00:30:48,920
让我提议我们进一步简化这个过程，然后就这样做。
Let me propose that we simplify this further, and just do this.

641
00:30:48,920 --> 00:30:53,260
如果我们知道输入目前在0和100之间,
If we know that input, for the moment, is going to be within 0 and 100,

642
00:30:53,260 --> 00:30:54,730
我们可以做一些假设。
we can make some assumptions.

643
00:30:54,730 --> 00:30:58,870
我们可以说，如果分数大于或等于90,
We could say something like, if the score is greater than or equal to 90,

644
00:30:58,870 --> 00:31:04,150
如果分数大于或等于80，学生会得到一个 A. elif,
well, the student gets an A. elif the score is greater than or equal to 80,

645
00:31:04,150 --> 00:31:08,110
学生得到一个 B。 elif 分数大于或等于70,
the student gets a B. elif score is greater than or equal to 70,

646
00:31:08,110 --> 00:31:13,930
如果分数大于或等于60，他们得到一个 C,
they get a C. elif the score is greater than or equal to 60,

647
00:31:13,930 --> 00:31:19,940
他们得了 D 否则就得了 F 我都干了些什么？
they get a D, else they get an F. So what have I done here?

648
00:31:19,940 --> 00:31:23,200
与其每次问两个问题,
Well, instead of asking two questions every time,

649
00:31:23,200 --> 00:31:26,320
检查该范围的下界和上界,
checking the lower bounds and the upper bound of that range,

650
00:31:26,320 --> 00:31:31,030
我更聪明地问你分数是否大于90,
I'm being a little more clever here by asking if the score is greater than 90,

651
00:31:31,030 --> 00:31:33,430
他们显然得了 A 或者更好的成绩。
well, they've obviously gotten an A or better.

652
00:31:33,430 --> 00:31:36,070
如果你的分数大于80，那么，你也是
If your score is greater than 80, well, you either

653
00:31:36,070 --> 00:31:40,750
如果它真的很强，就应该得 A 如果它刚好在80以上，就应该得 B。
deserve an A if it's really strong, or a B if it's just above 80.

654
00:31:40,750 --> 00:31:44,680
但是因为精灵逻辑，我们已经检查过了
But because of the elif logic, we've already checked

655
00:31:44,680 --> 00:31:46,450
这个学生的分数大于90吗？
is the student's score greater than 90?

656
00:31:46,450 --> 00:31:50,020
如果不是，那么我们就会问这个问题，是不是大于80？
And if it's not, then we're asking the question, well, is it greater than 80?

657
00:31:50,020 --> 00:31:54,220
所以你隐含地知道它在80到89之间,
So you implicitly know it's somewhere in the 80 to 89 range,

658
00:31:54,220 --> 00:31:58,780
否则你知道它在70到79之间，否则它就在下一个范围内
else you know it's in the 70 to 79 range, else it's in the next range

659
00:31:58,780 --> 00:31:59,350
放下。
down.

660
00:31:59,350 --> 00:32:02,950
因此，这是一个小的优化，使我们能够提出更少的问题。
So it's a minor optimization that allows us to ask fewer questions.

661
00:32:02,950 --> 00:32:05,980
但是同样的，它使得代码，可以说，更具可读性,
But again, it's making the code, arguably, a little more readable,

662
00:32:05,980 --> 00:32:09,580
当然更简洁，然后，希望，更可维护
certainly more succinct, an then, hopefully, more maintainable

663
00:32:09,580 --> 00:32:10,600
长远来看。
longer term.

664
00:32:10,600 --> 00:32:15,890
那么，关于这些类型的变化,
Any questions, then, on these types of changes,

665
00:32:15,890 --> 00:32:20,200
这种逻辑与我们的代码？
and this type of logic with our code?

666
00:32:20,200 --> 00:32:22,120
如果我们根本不用小精灵呢？
SPEAKER 4: What if we don't use elif at all?

667
00:32:22,120 --> 00:32:25,345
如果我们在 if 中编写代码呢？
What if we write the code in if?

668
00:32:25,345 --> 00:32:27,220
大卫. 马兰: 是的，这是个好问题,
DAVID MALAN: Yeah, so that's a good question,

669
00:32:27,220 --> 00:32:31,360
因为它实际上会在这里产生意想不到的效果。
because it's actually going to have an unintended effect here.

670
00:32:31,360 --> 00:32:33,340
让我暂时去掉 F
Let me get rid of the F temporarily, and just

671
00:32:33,340 --> 00:32:36,460
把注意力集中在 A 到 D 如果我们回到
focus on A through D. If we revert to where

672
00:32:36,460 --> 00:32:39,190
我们用条件句开始今天的故事,
we began today's story, with conditionals, saying if,

673
00:32:39,190 --> 00:32:45,070
如果，如果，如果，现在我们聪明地使用更广泛的笔触
if, if, if, now our cleverness here of using broader strokes

674
00:32:45,070 --> 00:32:47,680
并且不使用上限和下限范围
and not using an upper and lower bound ranges

675
00:32:47,680 --> 00:32:51,010
都会成为负面影响。
is going to come back to be a downside.

676
00:32:51,010 --> 00:32:53,320
让我继续运行 grade.py 的 Python。
Let me go ahead and run Python of grade.py.

677
00:32:53,320 --> 00:32:56,560
假设我的分数是95。
And suppose my score is 95.

678
00:32:56,560 --> 00:32:58,120
我太激动了。
I am so darn excited.

679
00:32:58,120 --> 00:33:00,520
我想拿 A 但不行。
I want my A, but nope.

680
00:33:00,520 --> 00:33:06,040
我只得了 A B C 和 D 所以从逻辑上来说，这就是破碎的东西。
I just got an A, a B, a C, and a D. So logically, that's broken things.

681
00:33:06,040 --> 00:33:09,220
因为如果你不让这些条件互相排斥,
Because if you don't make these conditions mutually exclusive,

682
00:33:09,220 --> 00:33:13,540
所有这些问题都会被问到，因此也会得到答案。
every one of those questions is going to get asked, and therefore answered.

683
00:33:13,540 --> 00:33:16,720
即使你的成绩超过了90分
And even if your grade is above a 90, it's

684
00:33:16,720 --> 00:33:20,140
逻辑上也是80以上70以上60以上,
also, logically, above an 80, above a 70, above a 60,

685
00:33:20,140 --> 00:33:23,580
如果我把它放在那里，我也会不及格，得个 F。
and if I'd kept it in there, I would have failed, as well, with an F.

686
00:33:23,580 --> 00:33:24,920
问得好。
Really good question.

687
00:33:24,920 --> 00:33:28,690
关于这种逻辑形式，还有其他问题吗？
Other questions here, on this form of logic?

688
00:33:28,690 --> 00:33:30,940
还有什么更好的方法
SPEAKER 5: Would there be any better way to clean up

689
00:33:30,940 --> 00:33:33,130
即使只是这个简单的声明，就像我们以前做的那样,
even just this simple statement, like we had before,

690
00:33:33,130 --> 00:33:36,280
你和小精灵之间的那个？
the previous one that you had with the elif?

691
00:33:36,280 --> 00:33:40,270
大卫. 马兰: 我喜欢你进一步简化事情的热情。
DAVID MALAN: I like your enthusiasm for simplifying things further.

692
00:33:40,270 --> 00:33:45,010
我要大胆猜测一下这已经是最好的结果了,
I'm going to go out on a limb here and say this is about as good as it gets,

693
00:33:45,010 --> 00:33:48,070
至少只使用条件语句。
at least using only conditional statements.

694
00:33:48,070 --> 00:33:52,390
如果我走神的话，我可以想出一个更聪明的办法
I can, if my mind wanders, think of a slightly more clever way

695
00:33:52,390 --> 00:33:54,490
做这个，也许用一个叫做循环的东西,
to do this, maybe with something called a loop,

696
00:33:54,490 --> 00:33:55,902
或者其他编程构造。
or another programming construct.

697
00:33:55,902 --> 00:33:57,610
我们的字典里还没有这个词。
We don't have that yet in our vocabulary.

698
00:33:57,610 --> 00:33:59,610
但是，是的，绝对还有其他方法可以做到。
But yes, there's absolutely other ways to do it.

699
00:33:59,610 --> 00:34:01,780
但我认为如果我们想限制自己的话，现在还不是时候
But I think not yet if we want to restrict ourselves

700
00:34:01,780 --> 00:34:07,120
比如 if，and，and else，elif，and，and 等等。
to just words like if, and or, and else, and elif, and and, and the like.

701
00:34:07,120 --> 00:34:10,810
那么，让我提议我们现在转向使用另一种方法
Well, let me propose that we pivot now to use another approach here

702
00:34:10,810 --> 00:34:12,800
使用了另一个符号，直到现在,
that uses one other symbol that, up until now,

703
00:34:12,800 --> 00:34:14,409
我们还没有机会利用。
we've not really had occasion to use.

704
00:34:14,409 --> 00:34:18,580
让我提议我们实现一个程序，我们称之为奇偶校验。
Let me propose that we implement a program that we'll call parity.

705
00:34:18,580 --> 00:34:22,460
在数学中，奇偶性可以指一个数是偶数还是奇数。
In mathematics, parity can refer to whether a number is even or odd.

706
00:34:22,460 --> 00:34:24,530
这是个有趣的问题。
And that's kind of an interesting question.

707
00:34:24,530 --> 00:34:26,863
结果证明它在其他应用中也很有用,
And it turns out it can be useful in other applications,

708
00:34:26,863 --> 00:34:29,770
同样，只要问一个给定的数字是偶数还是奇数,
too, to just ask the question is a given number even or odd,

709
00:34:29,770 --> 00:34:31,300
也许是用户输入的？
maybe that the user typed in?

710
00:34:31,300 --> 00:34:33,670
让我继续写一个新程序
And let me go ahead and write a new program

711
00:34:33,670 --> 00:34:38,800
在我的终端中通过代码 parity.py 命名为 parity.py。
called parity.py, via code parity.py in my terminal.

712
00:34:38,800 --> 00:34:41,560
我建议我们利用这个机会
And let me propose that we use this as an opportunity

713
00:34:41,560 --> 00:34:45,190
介绍最后一个算术符号,
to introduce the last of those arithmetic symbols,

714
00:34:45,190 --> 00:34:48,800
至少大部分我们都很熟悉加减法,
at least most of which we're familiar with, addition, subtraction,

715
00:34:48,800 --> 00:34:49,900
乘法，除法。
multiplication, division.

716
00:34:49,900 --> 00:34:53,317
但是这个名单之前有过，最后一个，百分比符号。
But there's been on this list before, this last one here, a percent sign.

717
00:34:53,317 --> 00:34:55,150
这并不意味着百分比,
And it doesn't mean percentage in this case,

718
00:34:55,150 --> 00:34:57,850
当在 Python 编程中用作运算符时。
when used as an operator in programming in Python.

719
00:34:57,850 --> 00:35:01,000
相反，它表示所谓的模运算符,
Rather, it represents the so-called modulo operator,

720
00:35:01,000 --> 00:35:02,260
同余关系。
for modular arithmetic.

721
00:35:02,260 --> 00:35:05,710
或者，至少在我们的例子中，我们要用它来计算
Or, at least in our case, we're going to use it to calculate the remainder when

722
00:35:05,710 --> 00:35:07,930
把一个数除以另一个数。
dividing one number by another.

723
00:35:07,930 --> 00:35:09,140
我这话什么意思？
Well, what do I mean by that?

724
00:35:09,140 --> 00:35:12,070
如果你取1除以3这样的数,
Well, if you take a number like one divided by three,

725
00:35:12,070 --> 00:35:14,840
三个不会干净利落地进入一个。
three does not go into one cleanly.

726
00:35:14,840 --> 00:35:16,690
所以你得到了1的余数。
So you have a remainder of one.

727
00:35:16,690 --> 00:35:20,140
二除以三等于二的余数。
Two divided by three has a remainder of two.

728
00:35:20,140 --> 00:35:24,550
三除以三等于零的余数，因为它除得很清楚。
Three divided by three has a remainder of zero, because it divides cleanly.

729
00:35:24,550 --> 00:35:30,088
4除以3等于1的余数因为你可以把它除以一次,
Four divided by three has a remainder of one, because you can divide it in once,

730
00:35:30,088 --> 00:35:32,380
然后剩下一个，所以剩下一个。
but then that leaves one, so it has a remainder of one.

731
00:35:32,380 --> 00:35:35,692
最后是5除以3
And then lastly, something like five divided by three

732
00:35:35,692 --> 00:35:37,150
当然还有两个余数。
has a remainder, of course, of two.

733
00:35:37,150 --> 00:35:39,700
这就是我们所说的余数，剩下多少
So that's all we mean by remainder, how much is left over

734
00:35:39,700 --> 00:35:41,830
在把一个数除以另一个数之后。
after dividing one number by another.

735
00:35:41,830 --> 00:35:46,180
如果我现在回到我的代码，并考虑如何实现
Well, if I go back now to my code, and I consider how I might implement

736
00:35:46,180 --> 00:35:49,150
问题是这个数字是偶数还是奇数？
the question is this number even or odd?

737
00:35:49,150 --> 00:35:51,520
让我们考虑一下如何实现这一点,
Let's consider how we might implement that,

738
00:35:51,520 --> 00:35:53,885
因为我们如何
since it's perhaps not necessarily obvious how we

739
00:35:53,885 --> 00:35:55,510
可以使用这个额外的构件。
can use this additional building block.

740
00:35:55,510 --> 00:35:58,460
但事实证明，长期来看，这是非常有用的。
But it turns out it's going to be very useful longer term.

741
00:35:58,460 --> 00:36:01,630
首先我们从用户那里得到一个变量 x 中的数字。
Well, let's first just get a number from the user in a variable called x.

742
00:36:01,630 --> 00:36:04,570
我要把它设置为转换为 int
And I'm going to set that equal to the conversion to int

743
00:36:04,570 --> 00:36:08,890
不管用户输入什么，在问他们什么是 x 之后，问号。
of whatever the user inputs, after asking them what's x, question mark.

744
00:36:08,890 --> 00:36:10,840
我们以前也这么做过很多次。
And we've done that before, many times.

745
00:36:10,840 --> 00:36:14,750
现在如何确定 x 是偶数还是奇数？
How do I now determine if x is even or odd?

746
00:36:14,750 --> 00:36:19,270
事实证明，如果我能接触到一个程序操作员，它会告诉我
Well, it turns out, if I have access to a programmatic operator that tells me

747
00:36:19,270 --> 00:36:21,742
剩下的，我想我可以做到。
the remainder, I think I can do this.

748
00:36:21,742 --> 00:36:23,200
事实上，让我问问大家。
In fact, let me just ask the group.

749
00:36:23,200 --> 00:36:25,480
这也许只是小学数学,
And this is just from grade school math, perhaps,

750
00:36:25,480 --> 00:36:28,750
数字是偶数意味着什么？
what does it mean for a number to be even, ?

751
00:36:28,750 --> 00:36:36,235
说清楚，像0,2,4,6,8,10,12,14,16这样的数字,
To be clear, a number like 0, 2, 4, 6, 8, 10, 12, 14, 16,

752
00:36:36,235 --> 00:36:37,360
这些都是偶数。
those are all even numbers.

753
00:36:37,360 --> 00:36:38,652
但这到底意味着什么？
But what does that really mean?

754
00:36:38,652 --> 00:36:40,960
埃琳娜，如果我没说错的话？
Elena, if I'm saying that right?

755
00:36:40,960 --> 00:36:43,990
偶数可以精确地除以2。
ELENA: Even numbers that can divide it exactly by two.

756
00:36:43,990 --> 00:36:48,275
例如，2、4、6、8和10，还有——
For example, 2, 4, 6, 8, and 10, and--

757
00:36:48,275 --> 00:36:49,150
完美。
DAVID MALAN: Perfect.

758
00:36:49,150 --> 00:36:51,040
我们可以一整天都这样，真的,
And we could go on all day long, literally,

759
00:36:51,040 --> 00:36:53,332
因为偶数的数量是无限的。
since there's an infinite number of those even numbers.

760
00:36:53,332 --> 00:36:56,260
但你用问题的形式表达出来，这很好
But it's nice that you formulated it in terms of a question

761
00:36:56,260 --> 00:36:58,240
我们可以很清楚地问。
that we can ask very clearly.

762
00:36:58,240 --> 00:37:01,360
这个数字是被2整除的吗？
Is this number cleanly divided by two?

763
00:37:01,360 --> 00:37:05,460
也就是说，我们能不能把它除以二，没有余数，一个零的余数？
That is, can we divide it by two with no remainder, a remainder of zero?

764
00:37:05,460 --> 00:37:09,430
很好，因为如果我们有这个运算符，这个百分号，那个
Well, that's perfect, because if we have this operator, this percent sign, that

765
00:37:09,430 --> 00:37:13,300
让我们可以回答，余数是多少，我们大概可以检查
allows us to answer just that, what is the remainder, we can presumably check

766
00:37:13,300 --> 00:37:15,790
余数是0还是1？
is the remainder zero, or is it one?

767
00:37:15,790 --> 00:37:19,120
我们什么都没剩下，还是只剩下一个？
Do we have nothing left over, or do we have one left over?

768
00:37:19,120 --> 00:37:20,080
好吧，我们来问问。
Well, let's ask that.

769
00:37:20,080 --> 00:37:28,568
如果 x 除以2的余数为零，就像 Elena 提出的那样，让我们继续
If x divided by two has a remainder of zero, as Elena proposes, let's go ahead

770
00:37:28,568 --> 00:37:30,610
然后打印出引号，甚至引号。
and print out something like quote, unquote even.

771
00:37:30,610 --> 00:37:32,410
对使用者也这么说。
And just say as much to the user.

772
00:37:32,410 --> 00:37:35,380
否则，我认为我们可以假设，如果一个数字不是偶数,
else, I think we can assume that if a number's not even,

773
00:37:35,380 --> 00:37:38,660
如果它确实是一个整数，那么它就是奇数。
it's going to be odd, if it's, indeed, an integer.

774
00:37:38,660 --> 00:37:41,590
所以我要打印出引号，而不是引号单数。
So I'm going to go ahead and print out quote, unquote odd instead.

775
00:37:41,590 --> 00:37:45,100
现在让我们继续，在我的提示符中运行 parity.py 的 Python。
And let's go ahead and now run Python of parity.py in my prompt.

776
00:37:45,100 --> 00:37:45,760
X 是什么？
What's x?

777
00:37:45,760 --> 00:37:46,840
我们从两个开始。
Let's start with two.

778
00:37:46,840 --> 00:37:48,220
事实上，两个人甚至。
Two is, in fact, even.

779
00:37:48,220 --> 00:37:49,390
我们从四开始。
Let's start with four.

780
00:37:49,390 --> 00:37:50,560
事实上，是四个。
Four is, in fact, even.

781
00:37:50,560 --> 00:37:53,750
我们来玩三个人的游戏吧。
Let's get interesting with three.

782
00:37:53,750 --> 00:37:54,838
三现在是奇数。
Three is now odd.

783
00:37:54,838 --> 00:37:57,880
我想我们可以一整天都这样做，希望能够回来，真的,
And I think we could do that all day long and hopefully get back, indeed,

784
00:37:57,880 --> 00:37:59,770
就是这个答案。
exactly that answer.

785
00:37:59,770 --> 00:38:02,180
但我们还能做什么呢？
But what more could we do here?

786
00:38:02,180 --> 00:38:03,910
我们怎样才能改进这一点呢？
How could we improve upon this?

787
00:38:03,910 --> 00:38:08,050
回想一下，我们有能力发明我们自己的功能。
Well, recall that we have the ability to invent our own functions.

788
00:38:08,050 --> 00:38:10,270
我提议，为了讨论起见,
And let me just propose, for the sake of discussion,

789
00:38:10,270 --> 00:38:12,145
我们最终会发现
that we're going to eventually find that it's

790
00:38:12,145 --> 00:38:14,600
有助于判断一个数字是偶数还是奇数。
useful to be able to determine if a number is even or odd.

791
00:38:14,600 --> 00:38:17,080
所以我们希望内置这个功能。
And so we'd like to have that functionality built-in.

792
00:38:17,080 --> 00:38:20,230
而且我觉得 Python 没有功能告诉我这些。
And I don't think Python has a function for telling me just that.

793
00:38:20,230 --> 00:38:23,240
但是我可以用这样的代码发明它。
But I can invent it using code like just this.

794
00:38:23,240 --> 00:38:26,770
让我们回到我之前的版本。
So let me go into my earlier version here.

795
00:38:26,770 --> 00:38:29,810
让我提议我们这么做。
And let me propose that we do this.

796
00:38:29,810 --> 00:38:32,680
让我继续编写一个 main 函数。
Let me go ahead and write a main function.

797
00:38:32,680 --> 00:38:36,130
我将重新养成定义要表示的主函数的习惯
I'm going to get back into that habit of defining a main function to represent

798
00:38:36,130 --> 00:38:37,457
我计划的主要部分。
the main part of my program.

799
00:38:37,457 --> 00:38:39,040
我要重蹈覆辙。
And I'm going to do what I did before.

800
00:38:39,040 --> 00:38:41,710
我要从用户输入中得到一个整数,
I'm going to get an integer from the user's input,

801
00:38:41,710 --> 00:38:44,680
问他们 X 是什么，问号。
asking them what's x, question mark.

802
00:38:44,680 --> 00:38:46,420
然后我会问这个问题。
And then I'm going to ask this question.

803
00:38:46,420 --> 00:38:48,667
目前，我还是天真地认为
For the moment, I'm going to naively assume

804
00:38:48,667 --> 00:38:50,500
函数已经存在，但是
that the function already exists, but that's

805
00:38:50,500 --> 00:38:52,390
一种有用的解决问题的技巧。
a useful problem-solving technique.

806
00:38:52,390 --> 00:38:55,270
即使我还不知道接下来要说什么,
Even if I have no idea yet where I'm going with this,

807
00:38:55,270 --> 00:38:58,750
我将如何发明一个函数来确定一个数字是否是偶数,
how I'm going to invent a function that determines if a number is even,

808
00:38:58,750 --> 00:39:01,780
我假设有一个叫做“ is even”的函数
I'm just going to assume that there's a function called "is even,"

809
00:39:01,780 --> 00:39:04,240
我会盲目地称之为，就像这样。
and I'm going to call it, blindly, like this.

810
00:39:04,240 --> 00:39:11,470
如果是偶数，传入 x，然后继续打印引号，取消引号偶数。
If is even, passing in x, then go ahead and print quote, unquote even.

811
00:39:11,470 --> 00:39:17,650
所以如果这个神奇的函数“ is even”返回 true 作为它的返回值
So if this magical function called "is even" returns true, as its return value

812
00:39:17,650 --> 00:39:19,960
我要打印出它是偶数。
I am going to print out that it's even.

813
00:39:19,960 --> 00:39:23,710
否则，否则，我会假设，当然，这是奇怪的。
Else, otherwise, I'm going to assume that it's, of course, odd.

814
00:39:23,710 --> 00:39:27,625
现在这个程序的一个问题就算我在这里调用 main,
Now the one problem with this program, even if I call main over here,

815
00:39:27,625 --> 00:39:30,010
就是根本不存在。
is that is even does not exist.

816
00:39:30,010 --> 00:39:32,620
如果我现在运行这个程序，它就会中断。
And this program would break if I ran it right now.

817
00:39:32,620 --> 00:39:33,530
不过没关系。
But that's OK.

818
00:39:33,530 --> 00:39:35,990
我有能力，回忆，发明我自己的功能。
I have the ability, recall, to invent my own function.

819
00:39:35,990 --> 00:39:39,970
让我用 def 定义一个名为“ is even”的函数
So let me define, with def, a function called "is even."

820
00:39:39,970 --> 00:39:42,760
我想让这个函数接受一个参数。
I want this function to take an argument.

821
00:39:42,760 --> 00:39:45,550
我把它叫做 n，只是一个数字，通常来说。
And I'm going to call it n, just a number, generically.

822
00:39:45,550 --> 00:39:46,690
我可以叫它 X。
I could call it x.

823
00:39:46,690 --> 00:39:49,640
但是，我不想把自己搞糊涂，弄不清楚哪个 x 是哪个。
But again, I don't want to confuse myself as to which x is which.

824
00:39:49,640 --> 00:39:52,100
所以我要给它起个不同的名字，没关系。
So I'm going to give it a different name, and that's fine.

825
00:39:52,100 --> 00:39:54,700
我把它叫做，更一般地说，n 代表数字。
I'm just going to call it, more generically, n for number.

826
00:39:54,700 --> 00:39:56,590
然后我要做这个。
And then I'm going to do this.

827
00:39:56,590 --> 00:40:03,490
如果 N% 2等于0就像之前一样,
I'm going to say if N % two equals equals zero, just like before, then,

828
00:40:03,490 --> 00:40:06,520
这就是魔术，你，程序员,
and here's the magic, you, the programmer,

829
00:40:06,520 --> 00:40:10,660
实际上可以返回所谓的布尔值。
can actually return what are called Boolean values.

830
00:40:10,660 --> 00:40:16,430
我们已经在 Python 中看到 Python 有 Stis 或者 string 整型或者整型,
We've seen in Python that Python has stirs or strings, ints or integers,

831
00:40:16,430 --> 00:40:19,000
浮点值或浮点值，所有这些
floats or floating point values, all of which

832
00:40:19,000 --> 00:40:21,520
是 Python 中不同类型的数据。
are different types of data in Python.

833
00:40:21,520 --> 00:40:26,210
Python 还有第四种数据类型 bool，用于布尔值。
Python also has a fourth data type called bool for a Boolean value.

834
00:40:26,210 --> 00:40:29,470
虽然这只是增加了我们的名单，关于布尔的好处
And even though this is just adding to our list, the nice thing about bools

835
00:40:29,470 --> 00:40:32,890
它们只能是真或假。
is that they can only be true or false.

836
00:40:32,890 --> 00:40:36,280
Int 可以是任意数量的无限可能的值。
An int can be any number of an infinite possible values.

837
00:40:36,280 --> 00:40:39,040
愚蠢只能是真或假。
A bool can only be true or false.

838
00:40:39,040 --> 00:40:43,460
如果你写自己的话，它必须是大写的 T 和大写的 F。
And it must be capital T and capital F if you're writing itself.

839
00:40:43,460 --> 00:40:46,030
所以如果我现在回到我的代码，我考虑
So if I go back now to my code, and I consider

840
00:40:46,030 --> 00:40:49,480
正是我想回到这里的东西。
exactly what I want to return here.

841
00:40:49,480 --> 00:40:53,560
如果 n% 2等于0,
Well, if n % two equals equals zero, that is,

842
00:40:53,560 --> 00:40:58,270
如果 n 除以2的余数是0我认为它是偶数,
if n divided by two has a remainder of zero, well, I think it's even,

843
00:40:58,270 --> 00:40:59,750
埃琳娜，你的定义。
to, Elena, your definition.

844
00:40:59,750 --> 00:41:05,380
那么让我们返回真，大写的 T，如果它没有零的余项,
So let's return true, capital T. else, if it doesn't have a remainder of zero,

845
00:41:05,380 --> 00:41:08,440
我很确定，从数学上来说，它必须有1的余项。
I'm pretty sure, mathematically, it's got to have a remainder of one.

846
00:41:08,440 --> 00:41:09,400
但这不重要。
But it doesn't matter.

847
00:41:09,400 --> 00:41:13,210
我知道它不是偶数，所以我要返回 false。
I know it's not even, so I'm going to return false.

848
00:41:13,210 --> 00:41:18,610
我们返回 false，而不是大写 F，现在我们已经定义了两个主要的
And we return false, instead capital F. And now that we've defined both main

849
00:41:18,610 --> 00:41:23,350
而且是偶数，我在底部调用 main，我想我是对的。
and is even, and I'm calling main at the bottom, I think I've got this right.

850
00:41:23,350 --> 00:41:25,960
Python 的 parity. py，Enter。
Python of parity.py, Enter.

851
00:41:25,960 --> 00:41:26,650
X 是什么？
What's x?

852
00:41:26,650 --> 00:41:28,780
我们试试简单的，比如两个。
Let's try something simple, like two.

853
00:41:28,780 --> 00:41:29,890
现在扯平了。
And it's even.

854
00:41:29,890 --> 00:41:30,850
我们再来一次。
Let's do it again.

855
00:41:30,850 --> 00:41:31,420
X 是什么？
What's x?

856
00:41:31,420 --> 00:41:32,560
四个怎么样？
How about four?

857
00:41:32,560 --> 00:41:33,100
甚至。
Even.

858
00:41:33,100 --> 00:41:34,480
再问一次，X 是什么？
Once more, what's x?

859
00:41:34,480 --> 00:41:35,740
三个怎么样？
How about three?

860
00:41:35,740 --> 00:41:36,910
这很奇怪。
And it's odd.

861
00:41:36,910 --> 00:41:38,140
我到底做了什么？
Now, what have I done here?

862
00:41:38,140 --> 00:41:42,700
我只是想说，如果我想创建自己的函数“ is”
I've just made the point that if I want to create my own function called "is

863
00:41:42,700 --> 00:41:44,410
甚至,”为我回答了这个问题,
even," that answers this question for me,

864
00:41:44,410 --> 00:41:47,350
我现在可以在这个程序中使用，也许还有未来的程序
that I can now use, in this program, and heck, maybe future programs

865
00:41:47,350 --> 00:41:51,190
我现在有一个没人给我的函数,
that I write, I now have a function that no one gave me,

866
00:41:51,190 --> 00:41:53,290
我给自己，我可以使用和再利用。
I gave myself, that I can use and reuse.

867
00:41:53,290 --> 00:41:55,580
我甚至可以和其他人分享。
And I can even, perhaps, share it with others.

868
00:41:55,580 --> 00:41:59,560
我现在在第三行使用这个函数来做决定。
I'm using that function now on line three, just to make a decision.

869
00:41:59,560 --> 00:42:01,360
我在上面用了条件句。
I'm using a conditional up there.

870
00:42:01,360 --> 00:42:05,140
我的布尔表达式是对还是错,
And my Boolean expression, something that's true or false,

871
00:42:05,140 --> 00:42:08,800
不是很明确的比如 x 小于 y,
is going to be not something explicit, like x less than y,

872
00:42:08,800 --> 00:42:11,020
或者 y 大于 x 之类的。
or y greater than x, or the like.

873
00:42:11,020 --> 00:42:13,180
这将是一个函数调用。
It's going to be a function call.

874
00:42:13,180 --> 00:42:15,790
我使用一个函数作为布尔表达式。
I'm using a function as my Boolean expression.

875
00:42:15,790 --> 00:42:18,160
但是没关系，因为我知道，因为是我写的,
But that's OK because I know, because I wrote it,

876
00:42:18,160 --> 00:42:23,580
函数“ is even”返回 true 或者 false。
that that function "is even" returns true or it returns false.

877
00:42:23,580 --> 00:42:26,750
这就是我做决定所需要的条件
And that's all I need in a conditional to make a decision

878
00:42:26,750 --> 00:42:29,810
打印偶数或奇数。
to print even or print odd.

879
00:42:29,810 --> 00:42:33,110
所以让我在这里暂停一下，看看现在是否有任何问题，关于我已经
So let me pause here to see if there's any questions now on how I've

880
00:42:33,110 --> 00:42:36,875
实现的“是偶数”，使用这个 bool。
implemented "is even," using this bool.

881
00:42:36,875 --> 00:42:38,000
你好，大卫。
SPEAKER 6: Hello, hi David.

882
00:42:38,000 --> 00:42:41,120
首先，感谢你们今天给我们上了这么棒的课
First of all, thank you for this wonderful class the day

883
00:42:41,120 --> 00:42:43,340
在昨天和今天之前，先生。
before yesterday and today, sir.

884
00:42:43,340 --> 00:42:47,720
我只有一个基于 Java 背景的查询。
I have just one query, based on the background of Java.

885
00:42:47,720 --> 00:42:50,810
在这里，当我们传递论点的时候,
There, when we used to pass the argument,

886
00:42:50,810 --> 00:42:53,940
我们也可以传递变量的地址。
we can also pass the address of the variables.

887
00:42:53,940 --> 00:42:57,120
那么 Python 中有类似的概念吗？
So is there any sort of this concept in Python?

888
00:42:57,120 --> 00:42:58,370
大卫. 马兰: 简短的回答，不。
DAVID MALAN: Short answer, no.

889
00:42:58,370 --> 00:43:02,300
那些不熟悉 Java 或其他语言，或 C，或 C + + ,
Those who are unfamiliar with Java or other languages, or C, or C++,

890
00:43:02,300 --> 00:43:06,230
通常有方法在不同的机制中传递值,
there's generally ways to pass values in different mechanisms that allow you,

891
00:43:06,230 --> 00:43:07,700
或者拒绝你，去改变他们。
or disallow you, to change them.

892
00:43:07,700 --> 00:43:08,897
在巨蟒里，没有。
In Python, no.

893
00:43:08,897 --> 00:43:11,480
我们将要看到的一切实际上都是一个物体。
Everything we're going to see is actually, in fact, an object.

894
00:43:11,480 --> 00:43:13,890
不过接下来还有更多。
But more on that down the line.

895
00:43:13,890 --> 00:43:17,960
还有一个问题，关于这些布尔和这些
How about time for one more question here on these bools and these

896
00:43:17,960 --> 00:43:19,700
“是偶数”
"is evens."

897
00:43:19,700 --> 00:43:23,720
我有一个关于定义函数的问题,
SPEAKER 7: So I actually had a question about defining a function,

898
00:43:23,720 --> 00:43:24,680
如果可以的话。
if that's OK.

899
00:43:24,680 --> 00:43:25,430
当然。
DAVID MALAN: Sure.

900
00:43:25,430 --> 00:43:29,030
如果你在你的代码里定义一个，就像你自己编的一样,
SPEAKER 7: So if you define one, within your code, like you made it up,

901
00:43:29,030 --> 00:43:33,230
你是否可以使用点运算符，就像我们使用名字点条一样,
are you allowed to use the dot operator like we did name dot strip,

902
00:43:33,230 --> 00:43:34,295
然后像那样使用它？
and use it like that?

903
00:43:34,295 --> 00:43:35,420
问得好。
DAVID MALAN: Good question.

904
00:43:35,420 --> 00:43:37,880
如果您已经创建了自己的函数，那么您可以
If you've created your own function, can you

905
00:43:37,880 --> 00:43:42,350
使用其他函数，如点条、点标题或点大写,
use other functions, like dot strip, or dot title, or dot capitalize,

906
00:43:42,350 --> 00:43:44,210
我们以前见过的？
that we've seen in the past?

907
00:43:44,210 --> 00:43:46,580
你可以把它们用在琴弦上。
You can use those on strings.

908
00:43:46,580 --> 00:43:49,110
这些函数都带有字符串。
Those functions come with strings.

909
00:43:49,110 --> 00:43:51,980
你不能把它们用在你自己的功能上,
You can't necessarily use them on your own functions,

910
00:43:51,980 --> 00:43:56,030
除非你的函数返回一个字符串。
unless your function returns a string, for the examples you gave.

911
00:43:56,030 --> 00:43:57,350
我是来还债的。
I'm returning a bool.

912
00:43:57,350 --> 00:44:00,140
Bools 没有左右空白的概念。
Bools have no notion of white space to the left or the right.

913
00:44:00,140 --> 00:44:02,207
你不能给脱衣舞娘打电话，也不能给资本公司打电话。
You can't call strip, you can't call capitalize.

914
00:44:02,207 --> 00:44:04,040
但如果你写一个不同的函数
But if you were writing a different function

915
00:44:04,040 --> 00:44:06,020
返回一个字符串。
that returns a string, absolutely.

916
00:44:06,020 --> 00:44:08,015
你也可以使用这些功能。
You could use those functions, as well.

917
00:44:08,015 --> 00:44:10,640
如果可以的话，让我们把注意力转回到这个例子上
Well, let me turn our attention, if I may, back to this example

918
00:44:10,640 --> 00:44:13,220
在这里，考虑到，正如我们现在经常做的,
here, and consider, as we now frequently do,

919
00:44:13,220 --> 00:44:15,920
我们可以改进这个代码的设计吗？
can we improve on the design of this code?

920
00:44:15,920 --> 00:44:18,290
我可以把这个程序做得更好吗？
Can I make this particular program better?

921
00:44:18,290 --> 00:44:19,340
我可以。
And I can.

922
00:44:19,340 --> 00:44:20,630
有几种方法。
There's a couple of ways here.

923
00:44:20,630 --> 00:44:24,320
我会给你们看一些现在通常被称为 Python 的东西。
And I'll show you something that's now generally known as something Pythonic.

924
00:44:24,320 --> 00:44:26,840
实际上在巨蟒的世界里有一个艺术术语,
There's actually this term of art, in the Python world,

925
00:44:26,840 --> 00:44:31,468
如果只是用 Python 做事情的方式，那么它就是 Python 的。
where something is Pythonic if it's just the way you do things in Python.

926
00:44:31,468 --> 00:44:33,260
也就是说，我们已经看到
Which is to say, we've seen already there's

927
00:44:33,260 --> 00:44:35,480
有那么多不同的方法来解决某些问题。
so many different ways to solve certain problems.

928
00:44:35,480 --> 00:44:38,000
在 Python 程序员社区中,
And in the Python community of programmers,

929
00:44:38,000 --> 00:44:41,990
总有一些方法比其他方法更容易被人笑到最后。
there tend to be some ways that are smiled upon more than others.

930
00:44:41,990 --> 00:44:45,560
它们往往涉及到可能只有 Python 才有的特性,
And they tend to relate to features that maybe only Python has,

931
00:44:45,560 --> 00:44:46,785
而不是其他语言。
but not other languages.

932
00:44:46,785 --> 00:44:49,910
这里有一些你可能没有在 Java 这样的语言中看到过的语法,
And here's some syntax that you might not have seen in languages like Java,

933
00:44:49,910 --> 00:44:52,470
或者 C，或者 C + + ，如果你以前编过程序的话。
or C, or C++ if you've programmed before.

934
00:44:52,470 --> 00:44:55,700
如果你从来没有编写过程序，这也将是全新的。
And if you've never programmed before, this too is going to be new.

935
00:44:55,700 --> 00:45:02,420
与其问这样的问题不如在 Python 中使用四行代码,
Instead of asking a question like this, if else using four lines, in Python,

936
00:45:02,420 --> 00:45:07,520
如果你愿意的话，你可以把它折叠成一条更优雅的线条。
you can actually collapse this into just one more elegant line, if you will.

937
00:45:07,520 --> 00:45:12,320
不是问 n 除以2的余数是否为零,
Instead of asking if n divided by two has a remainder of zero,

938
00:45:12,320 --> 00:45:15,390
返回 true，否则返回 false。
return true, else return false.

939
00:45:15,390 --> 00:45:23,150
让我删除所有这些，如果 n 除以2返回 true
Let me delete all of that and just say this, return true if n divided by two

940
00:45:23,150 --> 00:45:27,660
有一个零的余数，否则返回 false。
has a remainder of zero, else return false.

941
00:45:27,660 --> 00:45:30,140
那些有编程经验的人
Now those of you who do have prior programming experience

942
00:45:30,140 --> 00:45:31,940
可能会觉得这样很酷。
might actually think this is kind of cool.

943
00:45:31,940 --> 00:45:35,960
你可以把同样的想法，从四行浓缩成一行。
You can condense, from four lines into one line, that very same thought.

944
00:45:35,960 --> 00:45:39,260
Python 之所以流行的原因之一就是它确实流行
And one of the reasons why Python is popular is that it does

945
00:45:39,260 --> 00:45:41,270
读起来有点像英语。
tend to read rather like English.

946
00:45:41,270 --> 00:45:44,660
它不像大多数英语或大多数人类语言那样友好。
It's not quite as user-friendly as most English, or most human languages.

947
00:45:44,660 --> 00:45:48,470
但是请注意，现在，这行确实说明了你的意思。
But notice, now, the line does rather say what you mean.

948
00:45:48,470 --> 00:45:55,190
如果 n 除以2的余数为零，则返回 true，否则返回 false。
Return true if n divided by two has a remainder of zero, else false.

949
00:45:55,190 --> 00:45:58,820
用英语来说，逻辑上来说，这非常接近你可能会说的话,
That's pretty darn close to something you might say, logically, in English,

950
00:45:58,820 --> 00:46:02,060
不管是偶数还是奇数，或者其他任何东西。
be it about even and odd or really anything else.

951
00:46:02,060 --> 00:46:04,280
所以这个程序的工作原理是一样的。
So that program is going to work exactly the same.

952
00:46:04,280 --> 00:46:06,650
Python 的 parity.py，让我输入两个。
Python of parity.py, let me type in two.

953
00:46:06,650 --> 00:46:07,520
还是扯平了。
It's still even.

954
00:46:07,520 --> 00:46:08,600
让我输入三个。
Let me type in three.

955
00:46:08,600 --> 00:46:09,830
还是很奇怪。
It's still odd.

956
00:46:09,830 --> 00:46:12,180
但我可以进一步完善。
But I can refine this even further.

957
00:46:12,180 --> 00:46:15,260
同样，与这种不只是编写正确代码的想法一致,
And again, consistent with this idea of not just writing correct code,

958
00:46:15,260 --> 00:46:19,820
但编写越来越好的代码，但仍然保持可读性,
but writing better and better code, but still keeping it readable,

959
00:46:19,820 --> 00:46:22,730
我可以做一个比这个更好的。
I can do one even better than this.

960
00:46:22,730 --> 00:46:25,760
注意这里的值是我的布尔表达式。
Notice this value here is my Boolean expression.

961
00:46:25,760 --> 00:46:28,640
它的值是真还是假。
And it is going to evaluate to true or false.

962
00:46:28,640 --> 00:46:33,800
N 除以2的余数是否为零？
Is n divided by two having a remainder of zero or not?

963
00:46:33,800 --> 00:46:35,940
根据定义，这是一个布尔表达式。
That is, by definition, a Boolean expression.

964
00:46:35,940 --> 00:46:39,600
它有一个是/否的答案，一个真/假的答案。
It has a yes/no answer, a true/false answer.

965
00:46:39,600 --> 00:46:45,290
如果你的布尔表达式本身有一个真或假的答案,
Well, if your Boolean expression itself has a true or false answer,

966
00:46:45,290 --> 00:46:48,740
你一开始为什么要问这个问题？
why are you asking a question in the first place?

967
00:46:48,740 --> 00:46:50,270
为什么问如果？
Why ask if?

968
00:46:50,270 --> 00:46:51,770
还能说什么？
Why say else?

969
00:46:51,770 --> 00:46:57,140
只需返回您自己的布尔表达式的值。
Just return the value of your own Boolean expression.

970
00:46:57,140 --> 00:47:01,670
也许是最严谨的版本，最简洁，仍然可读,
And perhaps the tightest version, the most succinct, and still readable,

971
00:47:01,670 --> 00:47:05,450
这段代码的版本就是删除这一整行，Python
version of this code would be to delete this whole line, Pythonic

972
00:47:05,450 --> 00:47:12,530
尽管如此，只要返回 n 模2等于0。
though it is, and just return n modulo two equals equals zero.

973
00:47:12,530 --> 00:47:15,530
如果有帮助的话，让我暂时加上括号,
If it helps, let me add parentheses temporarily,

974
00:47:15,530 --> 00:47:18,910
因为括号里的事情会先发生。
because what's going to happen in parentheses will happen first.

975
00:47:18,910 --> 00:47:24,160
N 除以2有或没有零的余数。
n divided by two either does or does not have a remainder of zero.

976
00:47:24,160 --> 00:47:25,990
如果真是这样，那答案就是真的。
If it does, the answer is true.

977
00:47:25,990 --> 00:47:28,130
如果答案是否定的，那么答案就是错误的。
If it doesn't, the answer is false.

978
00:47:28,130 --> 00:47:31,310
如果你愿意的话，就把问题还给我。
So just return the question, if you will.

979
00:47:31,310 --> 00:47:35,020
不需要显式地用 if 和 else 包装它。
You don't need to wrap it, explicitly, with an if and an else.

980
00:47:35,020 --> 00:47:37,780
事实上，由于行动的顺序,
And in fact, because of order of operations,

981
00:47:37,780 --> 00:47:39,620
你甚至不需要括号。
you don't even need the parentheses.

982
00:47:39,620 --> 00:47:45,370
所以现在这可能是实现这个想法的最优雅的方式。
So now this is perhaps the most elegant way to implement this same idea.

983
00:47:45,370 --> 00:47:46,540
现在，哪个更好？
Now, which is better?

984
00:47:46,540 --> 00:47:47,870
这真是太棒了。
This is pretty darn good.

985
00:47:47,870 --> 00:47:51,010
这很难挑剔，因为它是如此的简洁。
And it's hard to take fault with this because it's so very succinct.

986
00:47:51,010 --> 00:47:54,250
但这完全没问题，而且正确无误,
But it's perfectly OK, and just as correct,

987
00:47:54,250 --> 00:47:56,500
有一个如果，然后一个别的。
to have an if and then an else.

988
00:47:56,500 --> 00:47:59,260
虽然总共可能有四行，如果有帮助的话
Even though it might be four total lines, if that helps

989
00:47:59,260 --> 00:48:01,480
你可以更清楚地思考你的代码，这会有所帮助
you think about your code more clearly, and it helps

990
00:48:01,480 --> 00:48:04,100
其他人也会对此进行推理。
other people reason about it, as well.

991
00:48:04,100 --> 00:48:06,490
这里还有另一种语法
So it turns out there's another syntax that you

992
00:48:06,490 --> 00:48:08,920
可以用来实现条件的相同思想,
can use to implement the same idea of a conditional,

993
00:48:08,920 --> 00:48:12,910
你可以根据布尔函数的答案选择性地做某件事
whereby you do something optionally, based on the answer to some Boolean

994
00:48:12,910 --> 00:48:13,720
表情。
expression.

995
00:48:13,720 --> 00:48:17,020
在最新版本的 Python 中，您现在可以使用的关键字是,
And the keyword that you can now use, in recent versions of Python,

996
00:48:17,020 --> 00:48:18,610
叫做，火柴。
is called this-- match.

997
00:48:18,610 --> 00:48:21,850
匹配是一种机制，如果你以前编写过程序，在精神上是相似的
Match is a mechanism that, if you've programmed before, is similar in spirit

998
00:48:21,850 --> 00:48:24,340
在其他语言中叫做开关。
to something called switch in other languages.

999
00:48:24,340 --> 00:48:28,450
例如，让我在这里结束 parity.py，然后让我继续
For instance, let me go ahead here and close out parity.py And let me go ahead

1000
00:48:28,450 --> 00:48:31,750
并创建一个名为 house.py 的新文件。
and create a new file called house.py.

1001
00:48:31,750 --> 00:48:33,700
还有 House 我想我们要去的地方
And in house.py, I think what we're going

1002
00:48:33,700 --> 00:48:37,243
要做的就是尝试实现一个程序，提示用户输入他们的名字,
to do is try to implement a program that prompts the user for their name,

1003
00:48:37,243 --> 00:48:39,160
然后输出他们所知道的房子
and then just outputs what house they're known

1004
00:48:39,160 --> 00:48:41,110
进入哈利波特的世界。
to be in in the world of Harry Potter.

1005
00:48:41,110 --> 00:48:43,040
例如，让我继续做这个。
So for instance, let me go ahead and do this.

1006
00:48:43,040 --> 00:48:46,450
让我给自己一个名为 name 的变量，设置它等于 return
Let me give myself a variable called name, set it equal to the return

1007
00:48:46,450 --> 00:48:47,860
输入函数的值。
value of the input function.

1008
00:48:47,860 --> 00:48:50,890
我会说，你叫什么名字，问号。
And I'll say something like, what's your name, question mark.

1009
00:48:50,890 --> 00:48:52,750
在那之后，我会用
And then after that, I'm just going to use

1010
00:48:52,750 --> 00:48:58,210
一个传统的 if，elif，else 结构来决定这个人在哪个房子里。
a traditional if, elif, else construct to decide what house this person is in.

1011
00:48:58,210 --> 00:49:03,100
如果名字等于哈利，比如哈利波特,
So let me say if name equals equals, say Harry, as in Harry Potter, well,

1012
00:49:03,100 --> 00:49:06,280
我们把哈利的房子打印出来，也就是格兰芬多
let's go ahead and print out Harry's house, which is Gryffindor

1013
00:49:06,280 --> 00:49:08,060
在哈利波特的世界里。
in the world of Harry Potter.

1014
00:49:08,060 --> 00:49:11,890
那就叫小精灵吧，赫敏
elif the name is, instead, Hermione, then

1015
00:49:11,890 --> 00:49:15,280
打印出格兰芬多的原话,
go ahead and print out also quote, unquote Gryffindor,

1016
00:49:15,280 --> 00:49:16,750
因为她也在同一个屋檐下。
as she's in the same house, too.

1017
00:49:16,750 --> 00:49:19,900
Elif 名字等于 Ron 我们继续
elif name equals equals Ron, let's go ahead

1018
00:49:19,900 --> 00:49:23,487
打印出格兰芬多的名言。
and similarly print out Gryffindor quote, unquote.

1019
00:49:23,487 --> 00:49:25,570
现在让我们把这个变得更有趣一点。
And let's make this a little more interesting now.

1020
00:49:25,570 --> 00:49:29,230
小精灵的名字等于引号，那德拉科呢？
elif name equals quote, unquote how about Draco?

1021
00:49:29,230 --> 00:49:32,110
德拉科 · 马尔福，在书里我们打印出引文,
Draco Malfoy, in the books-- let's go ahead and print out quote,

1022
00:49:32,110 --> 00:49:33,760
引用斯莱特林的话。
unquote Slytherin.

1023
00:49:33,760 --> 00:49:36,640
以防有人输入了别人的名字,
And just in case someone else's name gets inputted,

1024
00:49:36,640 --> 00:49:39,550
现在，假设我们不认识他们,
for now, let's just suppose that we don't recognize them,

1025
00:49:39,550 --> 00:49:41,890
默认情况下，输出引号,
and say, by default, else print out quote,

1026
00:49:41,890 --> 00:49:44,530
问号，只是为了表达
unquote who, question mark, just to convey

1027
00:49:44,530 --> 00:49:48,130
我们对这个名字并没有固定的反应。
that we don't actually have a hard-coded response to that particular name.

1028
00:49:48,130 --> 00:49:52,635
现在，让我继续前进，并以 house.py 和 Enter 的 Python 方式运行它。
Let me go ahead, now, and run this as Python of house.py, Enter.

1029
00:49:52,635 --> 00:49:54,760
然后我会继续输入像哈利这样的东西。
And I'll go ahead and type in something like Harry.

1030
00:49:54,760 --> 00:49:57,250
瞧，我们看到哈利确实在格兰芬多。
And voila, we see that Harry is, indeed, in Gryffindor.

1031
00:49:57,250 --> 00:50:00,040
让我们再运行一次，house.py 的 Python。
Let's run it one more time, Python of house.py.

1032
00:50:00,040 --> 00:50:01,690
这次我们输入 Draco。
Let's type in Draco this time.

1033
00:50:01,690 --> 00:50:02,500
斯莱特林。
Slytherin.

1034
00:50:02,500 --> 00:50:05,140
现在，让我们输入一个无法识别的名称。
And now, let's type in an unrecognized name.

1035
00:50:05,140 --> 00:50:07,540
让我们继续并重新运行 house.py 的 Python。
Let's go ahead and rerun Python of house.py.

1036
00:50:07,540 --> 00:50:10,000
然后输入博多河回车。
And let's go ahead and type in Padma, Enter.

1037
00:50:10,000 --> 00:50:10,570
还有谁？
And who?

1038
00:50:10,570 --> 00:50:14,800
因为在这种情况下我们没有用 elif 条件进行硬编码,
Because we haven't actually hard-coded with an elif condition in this case,

1039
00:50:14,800 --> 00:50:17,290
帕德玛应该住在什么样的房子里。
what house Padma is meant to be in.

1040
00:50:17,290 --> 00:50:19,750
事实证明，还有其他方法可以实现这一点。
Well, it turns out there's other ways to implement this.

1041
00:50:19,750 --> 00:50:22,030
事实上，这里有一些冗余，在那里
Indeed, there's some redundancy here, in that

1042
00:50:22,030 --> 00:50:25,837
我们在查哈利，赫敏，罗恩是不是都在格兰芬多。
we're checking if Harry, or Hermione, or Ron are all in Gryffindor.

1043
00:50:25,837 --> 00:50:28,420
我觉得我们至少可以把代码收紧一点,
I feel like we can at least tighten this code up a little bit,

1044
00:50:28,420 --> 00:50:30,260
使用我们已经见过的技术。
using techniques we've seen already.

1045
00:50:30,260 --> 00:50:31,640
所以让我来做这个。
So let me go ahead and do this.

1046
00:50:31,640 --> 00:50:34,370
让我上去做这样的事情。
Let me go up here and instead do something like this.

1047
00:50:34,370 --> 00:50:37,120
让我们摆脱这两个小精灵,
Let's get rid of these two blocks of elifs,

1048
00:50:37,120 --> 00:50:38,890
暂时离开哈利家。
leaving just Harry's for a moment.

1049
00:50:38,890 --> 00:50:41,980
让我们再次使用“或”关键字，并说或名称
And let's use that "or" keyword again, and say or name

1050
00:50:41,980 --> 00:50:47,080
等于引号，赫敏，或者名字等于引号，罗恩,
equals equals quote, unquote Hermione, or name equals quote, unquote Ron,

1051
00:50:47,080 --> 00:50:51,370
这样就可以把三个案子合并成一个
thereby consolidating all three cases, if you will, into just one

1052
00:50:51,370 --> 00:50:52,360
如果声明。
if statement.

1053
00:50:52,360 --> 00:50:55,270
那我们还有一个单独的精灵给德拉科，因为他不是,
Then we still have a separate elif for Draco because he's not,

1054
00:50:55,270 --> 00:50:56,230
事实上，在格兰芬多。
in fact, in Gryffindor.

1055
00:50:56,230 --> 00:50:59,260
然后是最后一个能抓住其他人的人。
And then the final else to catch anyone else.

1056
00:50:59,260 --> 00:51:03,280
现在让我继续运行该程序的这个版本: house.py 的 Python。
Let me go ahead now and run this version of the program, Python of house.py.

1057
00:51:03,280 --> 00:51:05,470
这次我输入赫敏。
I'll type in Hermione this time.

1058
00:51:05,470 --> 00:51:07,030
她也还在格兰芬多。
She, too, is still in Gryffindor.

1059
00:51:07,030 --> 00:51:08,170
让我和罗恩试试。
Let me try it with Ron.

1060
00:51:08,170 --> 00:51:10,582
这一点似乎也是正确的。
And that, too, still seems to be correct.

1061
00:51:10,582 --> 00:51:13,540
事实证明还有另一种方法也许可以
Well, it turns out there's another approach altogether that can perhaps

1062
00:51:13,540 --> 00:51:16,000
使您的代码不那么冗长。
make your code a little less verbose.

1063
00:51:16,000 --> 00:51:18,790
你可以想象这个代码有多复杂
You could imagine how complicated this code might

1064
00:51:18,790 --> 00:51:21,940
如果我们不是只有哈利，赫敏和罗恩，而是一大群人
get if we had not just Harry, and Hermione, and Ron, but a whole bunch

1065
00:51:21,940 --> 00:51:25,030
还有其他的名字，格兰芬多，Slytherin，以及所有的名字
of other names as well, for Gryffindor, for Slytherin, and for all

1066
00:51:25,030 --> 00:51:26,650
其他霍格沃茨的房子。
of the other Hogwarts houses.

1067
00:51:26,650 --> 00:51:29,737
所以你可以想象这些代码会变得非常笨拙，非常快。
So you could imagine that code just getting pretty unwieldy pretty fast.

1068
00:51:29,737 --> 00:51:31,570
事实证明，你可以用另一种方法
Well, it turns out another technique you can

1069
00:51:31,570 --> 00:51:34,940
使用的确是这个叫做“匹配”的关键词，在精神上非常相似,
use is, indeed, this keyword called match, which is very similar in spirit,

1070
00:51:34,940 --> 00:51:36,130
但语法不同。
but the syntax is different.

1071
00:51:36,130 --> 00:51:39,580
它允许你更简洁地表达同样的想法。
And it allows you to express the same ideas a little more compactly.

1072
00:51:39,580 --> 00:51:41,620
那就让我回 House 吧 Py。
So let me go back to house.py.

1073
00:51:41,620 --> 00:51:45,700
让我提议我去掉现在的 if，elif，else 方法,
And let me propose that I get rid of my current if, elif, else approach,

1074
00:51:45,700 --> 00:51:47,080
而不是这样做。
and instead do this.

1075
00:51:47,080 --> 00:51:51,070
字面上使用关键字 match，然后键入变量的名称,
Literally use the keyword match, and type the name of the variable,

1076
00:51:51,070 --> 00:51:53,055
或价值，我们希望匹配。
or value, that we want to match on.

1077
00:51:53,055 --> 00:51:55,180
然后我将继续，包括一个结肠。
And then I'm going to go ahead and include a colon.

1078
00:51:55,180 --> 00:51:58,240
然后在下面，我会包括，真的,
And then underneath that, I'm going to include, literally,

1079
00:51:58,240 --> 00:51:59,740
一个叫 case 的关键词。
a keyword called case.

1080
00:51:59,740 --> 00:52:02,290
我要考虑的第一个案子就是哈利。
And the first case I want to consider is going to be Harry.

1081
00:52:02,290 --> 00:52:05,690
我要把哈利放在引号里，因为它是一根绳子或者一个搅拌器。
And I'm going to put Harry in quotes, because it's a string or a stir.

1082
00:52:05,690 --> 00:52:08,350
在这一行的末尾还有一个冒号。
And I'm going to have another colon at the end of this line.

1083
00:52:08,350 --> 00:52:11,020
在这个下面缩进了，我要继续了，现在,
And indented under that one, I'm going to go ahead and, for now,

1084
00:52:11,020 --> 00:52:13,990
把格兰芬多打印出来当然，那是哈利的家。
print out Gryffindor, which, of course, is Harry's house.

1085
00:52:13,990 --> 00:52:17,590
否则，我会有另一个案子，引用赫敏的话。
Otherwise, I'm going to have another case for quote, unquote Hermione.

1086
00:52:17,590 --> 00:52:20,350
同样的，在这个缩进的下面,
And similarly, I'm going to have under that indented,

1087
00:52:20,350 --> 00:52:23,560
引用格兰芬多的话，结束引用。
print quote, unquote Gryffindor, close quote.

1088
00:52:23,560 --> 00:52:27,740
现在我要给 Ron 另一个例子，也是引号，带有冒号。
Now I'm going to have another case for Ron, also in quotes, with a colon.

1089
00:52:27,740 --> 00:52:29,950
现在引用格兰芬多的原话。
Now print quote, unquote Gryffindor.

1090
00:52:29,950 --> 00:52:33,122
现在我又有了一个案子，比如说，德拉科。
And now I'm going to have a other case for, let's say, Draco.

1091
00:52:33,122 --> 00:52:35,830
这个更有趣，因为德拉科，当然,
This one gets a little more interesting because Draco, of course,

1092
00:52:35,830 --> 00:52:37,750
现在是在 Slytherin。
now is in Slytherin.

1093
00:52:37,750 --> 00:52:40,830
然后我会继续，暂时就这样。
And then I'm going to go ahead and leave it as that for now.

1094
00:52:40,830 --> 00:52:44,080
让我继续保存这个文件回到我的终端窗口,
So let me go ahead and save this file, and go back down to my terminal window,

1095
00:52:44,080 --> 00:52:46,930
运行 Python of house.py，Enter。
running Python of house.py, Enter.

1096
00:52:46,930 --> 00:52:48,485
我们试试哈利吧。
And let's go ahead and try Harry.

1097
00:52:48,485 --> 00:52:50,110
他好像还在格兰芬多。
And he seems still to be in Gryffindor.

1098
00:52:50,110 --> 00:52:52,810
再给赫敏放一遍，回车。
Let's run it again for Hermione, Enter.

1099
00:52:52,810 --> 00:52:53,560
格兰芬多。
Gryffindor.

1100
00:52:53,560 --> 00:52:56,653
我们跳到德拉科，输入德拉科的名字。
Let's skip ahead to Draco, and type in Draco's name.

1101
00:52:56,653 --> 00:52:57,820
他确实在 Slytherin。
He is, indeed, in Slytherin.

1102
00:52:57,820 --> 00:53:00,790
现在让我们试试另一个我们还没处理过的名字
Now let's try another name that we haven't handled

1103
00:53:00,790 --> 00:53:03,310
像帕德玛一样的情况再次出现。
a case for, like Padma again, Enter.

1104
00:53:03,310 --> 00:53:04,540
我们只是被忽视了。
And we're just ignored.

1105
00:53:04,540 --> 00:53:07,660
没有任何输出，因为没有帕德玛的案子。
There's no output whatsoever because there wasn't a case for Padma.

1106
00:53:07,660 --> 00:53:11,440
当然，现在我们可以回过头来明确地为 Padma 加一个。
Now we could, of course, go back in and explicitly add one for Padma.

1107
00:53:11,440 --> 00:53:14,440
但是如果我们，类似于 else 结构,
But what if we, similarly to the else construct,

1108
00:53:14,440 --> 00:53:18,700
只是想要一个处理任何名字没有明确指定的人的概括？
just want a catchall that handles anyone whose name is not explicitly specified?

1109
00:53:18,700 --> 00:53:22,150
根据这个新的 match 语句的语法,
Well, turns out the syntax for that, using this new match statement,

1110
00:53:22,150 --> 00:53:24,730
就是还有一个案子，然后用
is to still have another case, but then to use

1111
00:53:24,730 --> 00:53:28,480
这个单一的下划线字符，在 Python 的其他上下文中使用。
this single underscore character, which is used in other contexts in Python.

1112
00:53:28,480 --> 00:53:32,440
但在这里，它意味着无论什么案子还没有处理,
But for here, it's meant to say whatever case has not yet been handled,

1113
00:53:32,440 --> 00:53:35,410
打印出来，就像我们之前做的那样,
go ahead and print out, as we did before, for instance,

1114
00:53:35,410 --> 00:53:38,900
引号，引号，谁，最后加个问号。
quote, unquote who, with a question mark at the end.

1115
00:53:38,900 --> 00:53:42,310
现在让我们继续并重新运行 house.py 的 Python。
Now let's go ahead and rerun this Python of house.py.

1116
00:53:42,310 --> 00:53:43,668
我再打一遍帕德玛的名字。
I'll type Padma's name again.

1117
00:53:43,668 --> 00:53:45,460
这次，我想我们至少要去
And this time, I think we're at least going

1118
00:53:45,460 --> 00:53:48,250
得到一个明确的响应，指出是谁,
to get an explicit response indicating who,

1119
00:53:48,250 --> 00:53:50,920
而以前我们没有这样的等价物。
whereas previously we did not have the equivalent of that.

1120
00:53:50,920 --> 00:53:53,440
现在，我觉得我们倒退了一点。
Now, I think we've regressed a little bit.

1121
00:53:53,440 --> 00:53:56,590
我们把哈利和赫敏从紧凑的关系中解放出来,
We went from tightening things up by putting Harry, and Hermione,

1122
00:53:56,590 --> 00:53:59,650
和 Ron 都在同一行的 if 语句中。
and Ron all on the same line in the same if statement.

1123
00:53:59,650 --> 00:54:02,780
但是这里，我们现在有三个案例陈述，同样，对于所有三个
But here, we have now three case statements, again, for all three

1124
00:54:02,780 --> 00:54:03,280
那些。
of those.

1125
00:54:03,280 --> 00:54:05,950
我们也可以加强这个代码。
Well, we can tighten this code up, as well.

1126
00:54:05,950 --> 00:54:08,240
但是语法会有点不同。
But the syntax is going to be a little bit different.

1127
00:54:08,240 --> 00:54:12,160
我要删除赫敏和罗恩的这两个中间案例。
I'm going to go ahead and delete these two middle cases for Hermione and Ron.

1128
00:54:12,160 --> 00:54:15,320
然后这里，哈利的名字旁边，冒号前面,
And then up here, next to Harry's name, before the colon,

1129
00:54:15,320 --> 00:54:18,070
我要用一根竖直的杆，然后
I'm going to go ahead and use a single vertical bar, and then

1130
00:54:18,070 --> 00:54:19,810
引用赫敏的话。
a quote, unquote Hermione.

1131
00:54:19,810 --> 00:54:23,110
然后再来一小节，引用罗恩的话。
Then another single bar and do quote, unquote Ron.

1132
00:54:23,110 --> 00:54:26,140
这就是如何使用这个相对较新的匹配语句,
And this is how, using this relatively new match statement,

1133
00:54:26,140 --> 00:54:30,220
你可以说相当于哈利，或赫敏，或罗恩,
you can say the equivalent of Harry, or Hermione, or Ron,

1134
00:54:30,220 --> 00:54:33,640
但比使用 if 语句更简洁
but more concisely than you could using an if statement

1135
00:54:33,640 --> 00:54:35,870
单独使用，正如我们以前实现的那样。
alone, as we implemented it previously.

1136
00:54:35,870 --> 00:54:40,210
现在，使用 house.py 的 Python 对该程序进行最后一次运行。
So now, one final run of the program with Python of house.py.

1137
00:54:40,210 --> 00:54:42,490
确保哈利还在格兰芬多。
Let's make sure that Harry is still in Gryffindor.

1138
00:54:42,490 --> 00:54:44,920
确保赫敏还在格兰芬多。
Let's make sure that Hermione is still in Gryffindor.

1139
00:54:44,920 --> 00:54:46,990
我们得确保罗恩还在格兰芬多。
Let's make sure that Ron is still in Gryffindor.

1140
00:54:46,990 --> 00:54:48,880
事实上，他们三个都是。
And indeed, all three of them are.

1141
00:54:48,880 --> 00:54:51,553
现在，一如既往地使用 Python 和更一般的编程,
Now, as always with Python and programming more generally,

1142
00:54:51,553 --> 00:54:54,220
你可以用不同的方法来解决这些问题。
there's going to be different ways you can solve these problems.

1143
00:54:54,220 --> 00:54:56,290
这只是您工具箱中的另一个工具。
This is just another tool in your toolkit.

1144
00:54:56,290 --> 00:54:58,240
可以说，它已经让事情变得更加紧张。
Arguably, it has tightened things up.

1145
00:54:58,240 --> 00:55:00,190
可以说，它可能更易读一些
Arguably, it's perhaps a little more readable

1146
00:55:00,190 --> 00:55:02,500
因为语法比较简单,
because there's a little less syntax going on,

1147
00:55:02,500 --> 00:55:05,710
少一点等号和 elif 的重复,
a little less duplication of equal signs and elif,

1148
00:55:05,710 --> 00:55:07,390
到处都是 Elif 和 Elif。
and elif, and elif all over the place.

1149
00:55:07,390 --> 00:55:11,740
但归根结底，这将是解决同一问题的同样正确的方法。
But ultimately, this would be an equally correct approach to that same problem.

1150
00:55:11,740 --> 00:55:13,600
但结果证明，你的匹配声明
But it turns out with a match statement you

1151
00:55:13,600 --> 00:55:16,360
也可以进行更强大的匹配。
can do even more powerful forms of matching, as well.

1152
00:55:16,360 --> 00:55:20,500
在这里，我们只是用它来实现与 if，elif 相同的思想,
Here, we've used it simply to implement the same idea as that if, elif,

1153
00:55:20,500 --> 00:55:21,460
else 构造。
else construct.

1154
00:55:21,460 --> 00:55:24,700
值得一提的是，如果你用其他语言编程,
And it's worth noting, if you've programmed in some other language,

1155
00:55:24,700 --> 00:55:26,200
这里的语法确实是正确的。
the syntax here is, indeed, correct.

1156
00:55:26,200 --> 00:55:28,600
例如，您不需要 break 语句,
You do not need, for instance, a break statement,

1157
00:55:28,600 --> 00:55:29,950
就像撒满了胡椒粉一样。
as has been peppered throughout.

1158
00:55:29,950 --> 00:55:32,665
你不需要什么默认值，或者什么明确的东西。
And you don't need something like default, or something explicit.

1159
00:55:32,665 --> 00:55:37,700
实际上，您只需在比赛结束时使用这个下划线作为总括。
You, indeed, just use this underscore as your catchall at the end of the match.

1160
00:55:37,700 --> 00:55:40,900
只要加入一些新的关键词
So just by adding in some of these new keywords

1161
00:55:40,900 --> 00:55:45,340
这里，比如 if 和 elif，还有 else，我们现在有能力
here, like if, and elif, and else, we have now the ability

1162
00:55:45,340 --> 00:55:47,320
提出有关价值观的问题。
to ask questions about values.

1163
00:55:47,320 --> 00:55:50,140
我们有能力分析来自用户的输入,
We have the ability to analyze input from users,

1164
00:55:50,140 --> 00:55:52,090
并最终做出决定。
and ultimately make decisions about it.

1165
00:55:52,090 --> 00:55:54,730
还有这些条件句。
And these, then, where our conditionals.

1166
00:55:54,730 --> 00:55:58,180
我们不仅可以使用函数,
Lying ahead is going to be the ability for us to not only use functions,

1167
00:55:58,180 --> 00:56:00,380
和变量，还有这些条件,
and variables, and also these conditionals,

1168
00:56:00,380 --> 00:56:06,330
而且，下一步，循环——现在，一次又一次做某事的能力。
but also, next, loops-- the ability to do something, now, again and again.

